#!/usr/bin/env python3
import os
import sys

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(CURRENT_DIR)
from ams_model import create_ams_model

import argparse
from pathlib import Path
from typing import Any, Dict, List, Tuple

import torch
import torch.nn as nn

# ---------------------------
# Torch modules
# ---------------------------


class SimpleNet(nn.Module):
    def __init__(self, in_features: int = 4, out_features: int = 2):
        super().__init__()
        self.lin = nn.Linear(in_features, out_features)

    def forward(self, x):
        return self.lin(x)


class NoAMSInfoModel(nn.Module):
    """Valid TS model but no get_ams_info exported."""

    def __init__(self):
        super().__init__()
        self.net = SimpleNet()

    def forward(self, x):
        return self.net(x)

class BadDeviceAMSModel(nn.Module):
    """ams_device is not a device, but a string; C++ isDevice() == false."""
    _ams_dtype: torch.dtype
    _ams_device: str 

    def __init__(self):
        super().__init__()
        self.net = SimpleNet()
        self._ams_dtype = torch.float32 
        self._ams_device = "something" 


    @torch.jit.export
    def get_ams_dtype(self) -> torch.dtype:
        return self._ams_dtype

    @torch.jit.export
    def get_ams_device(self) -> str:
        return self._ams_device


    def forward(self, x):
        return self.net(x)


# ---------------------------
# Generation helpers
# ---------------------------


def write_header(
    header_path: Path,
    simple_models: List[Tuple[str, str, str, str]],
    failing_models: List[Tuple[str, str, str]],
) -> None:
    """
    simple_models: list of (path, precision, device, uq_type)
    failing_models: list of (path, expected_error_type, description)
    """
    lines: List[str] = []

    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <string>")
    lines.append("#include <vector>")
    lines.append("#include <ostream>")
    lines.append("")
    lines.append("/// Autogenerated by generate_ams_test_models.py")
    lines.append("/// Do not edit by hand.")
    lines.append("")
    lines.append("struct TestModel {")
    lines.append("  std::string ModelPath;")
    lines.append("  std::string ModelPrecision;")
    lines.append("  std::string ModelDevice;")
    lines.append("};")
    lines.append("")
    lines.append("struct FailingModel {")
    lines.append("  std::string ModelPath;")
    lines.append("  std::string ExpectedErrorType; // AMSErrorType as string")
    lines.append("  std::string Description;")
    lines.append("};")
    lines.append("")
    lines.append("inline std::ostream &operator<<(std::ostream &OS, " "TestModel const &M) {")
    lines.append(
        '  return OS << "path=" << M.ModelPath'
        ' << " | precision=" << M.ModelPrecision'
        ' << " | device=" << M.ModelDevice;'
    )
    lines.append("}")
    lines.append("")
    lines.append("inline std::ostream &operator<<(std::ostream &OS, " "FailingModel const &M) {")
    lines.append(
        '  return OS << "path=" << M.ModelPath'
        ' << " | expected_error=" << M.ExpectedErrorType'
        ' << " | desc=" << M.Description;'
    )
    lines.append("}")
    lines.append("")

    # C++17 inline variables to keep this header-only.
    lines.append("inline const std::vector<TestModel> simple_models = {")
    for path, prec, dev in simple_models:
        lines.append(f'  {{"{path}", "{prec}", "{dev}"}},')
    lines.append("};")
    lines.append("")

    lines.append("inline const std::vector<FailingModel> failing_models = {")
    for path, err, desc in failing_models:
        print(path)
        lines.append(f'  {{"{path}", "{err}", "{desc}"}},')
    lines.append("};")
    lines.append("")

    header_path.write_text("\n".join(lines))
    print(f"[info] Wrote header: {header_path}")


# ---------------------------
# Main
# ---------------------------


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--out-dir",
        type=Path,
        required=True,
        help="Output directory where models and header will be written.",
    )
    parser.add_argument(
        "--header-name",
        type=str,
        default="GeneratedBaseModels.hpp",
        help="Name of the generated C++ header.",
    )
    args = parser.parse_args()

    out_dir: Path = args.out_dir.resolve()
    models_dir = out_dir
    models_dir.mkdir(parents=True, exist_ok=True)

    header_path = out_dir / args.header_name

    simple_models: List[Tuple[str, str, str, str]] = []
    failing_models: List[Tuple[str, str, str]] = []

    # -----------------------
    # Generate "good" models
    # -----------------------
    precisions = ["single", "double"]
    devices = ["cpu", "gpu"]

    for precision in precisions:
        for dev in devices:
            # Skip GPU if CUDA is not available.
            if dev == "gpu" and not torch.cuda.is_available():
                print(f"[warn] Skipping {prec}/{dev} because CUDA not available")
                continue

            filename = f"{precision}_{dev}.pt"
            path = (models_dir / filename).resolve()
            device = torch.device("cpu")
            if (dev == "gpu") and torch.cuda.is_available():
                device = torch.device("cuda")
            model = SimpleNet()
            prec = torch.float32
            if precision == "single":
                model = model.float()
                prec = torch.float32
            elif precision == "double":
                model = model.double()
                prec = torch.float64

            model = model.to(device) 
            model = model.to(prec)

            scripted = create_ams_model(model, device, prec)
            scripted.save(str(path))

            simple_models.append((str(path), precision, dev))
            print(f"[info] Saved simple model: {path}")

    # ---------------------------------------
    # Failing model: file does not exist
    # ---------------------------------------
    missing_path = (models_dir / "missing_model.pt").resolve()
    failing_models.append(
        (str(missing_path), "FileDoesNotExist", "Non-existent file path should yield FileDoesNotExist")
    )

    # ---------------------------------------
    # Failing model: invalid TorchScript file
    # (file exists but not a TS archive) -> TorchInternal
    # ---------------------------------------
    invalid_ts_path = (models_dir / "invalid_torch_file.pt").resolve()
    invalid_ts_path.write_text("this is not a torchscript model\n")
    failing_models.append(
        (str(invalid_ts_path), "TorchInternal", "Existing file that is not a valid TorchScript model")
    )
    print(f"[info] Wrote invalid TS file: {invalid_ts_path}")

    # ---------------------------------------
    # Failing model: valid TS but no get_ams_info -> InvalidModel
    # ---------------------------------------
    no_info_model_path = (models_dir / "no_ams_info.pt").resolve()
    no_info_model = NoAMSInfoModel()
    scripted_no_info = torch.jit.script(no_info_model)
    scripted_no_info.save(str(no_info_model_path))
    failing_models.append(
        (str(no_info_model_path), "InvalidModel", "Valid TorchScript model without get_ams_info method")
    )
    print(f"[info] Saved no_ams_info model: {no_info_model_path}")

    # ---------------------------------------
    # Failing model: ams_device is not a device -> InvalidModel
    # ---------------------------------------
    bad_dev_model_path = (models_dir / "bad_device_ams_info.pt").resolve()
    bad_dev_model = BadDeviceAMSModel()
    scripted_bad_dev = torch.jit.script(bad_dev_model)
    scripted_bad_dev.save(str(bad_dev_model_path))
    failing_models.append(
        (str(bad_dev_model_path), "InvalidModel", "get_ams_info returns ams_device that is not a device")
    )
    print(f"[info] Saved bad_device_ams_info model: {bad_dev_model_path}")

    # ---------------------------------------
    # Write the header
    # ---------------------------------------
    write_header(header_path, simple_models, failing_models)


if __name__ == "__main__":
    main()
