#ifndef __DATACRUMBS_SERVER_BPF_COMMON_H
#define __DATACRUMBS_SERVER_BPF_COMMON_H

// Generated by DataCrumbs during system build
#include <datacrumbs/server/bpf/vmlinux.h>
// bpf headers
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/usdt.bpf.h>
// internal headers
#include <datacrumbs/server/bpf/macros.bpf.h>
#include <datacrumbs/server/bpf/shared.h>

DATACRUMBS_MAP_EXTERN(pid_map, u32, u64, 1024);
DATACRUMBS_MAP_EXTERN(fn_pid_map, struct fn_key_t, struct fn_value_t);

#if defined(DATACRUMBS_MODE) && (DATACRUMBS_MODE == 1)
DATACRUMBS_MAP_EXTERN(failed_request, u32, u32, 128);
DATACRUMBS_RINGBUF_EXTERN(output, 1024 * 1024U * DATACRUMBS_TRACE_RINGBUF_SIZE_MB);
#else
DATACRUMBS_MAP_EXTERN(profile, struct profile_key_t, struct profile_value_t, 1024);
DATACRUMBS_MAP_EXTERN(usdt_profile, struct usdt_profile_key_t, struct profile_value_t, 1024);
DATACRUMBS_MAP_EXTERN(latest_interval, int, unsigned long long, 128);
#endif
DATACRUMBS_MAP_EXTERN(file_map, char[MAX_STR_READ_LEN], u32, 1024);

#if defined(DATACRUMBS_ENABLE_INCLUSION_PATH) && (DATACRUMBS_ENABLE_INCLUSION_PATH == 1)
DATACRUMBS_TRIE_EXTERN(inclusion_path_trie, struct string_t, struct string_t);
#endif

static inline __attribute__((always_inline)) u32 hash_str(const char* str, size_t len) {
  u32 hash = 5381;
#pragma unroll
  for (int i = 0; i < 128; ++i) {
    if (i >= len) break;
    hash = ((hash << 5) + hash) + str[i];
  }
  return hash;
}

static inline __attribute__((always_inline)) u32 hash_and_store(struct string_t* str, size_t len) {
  u32* existing = bpf_map_lookup_elem(&file_map, str);
  if (existing) {
    return *existing;  // Return existing hash
  }
  u32 hash = hash_str(str->str, len);
  // Store new hash
  bpf_map_update_elem(&file_map, str, &hash, BPF_ANY);
  return hash;
}

#if defined(DATACRUMBS_ENABLE_INCLUSION_PATH) && (DATACRUMBS_ENABLE_INCLUSION_PATH == 1)
// Returns 1 if any prefix in trie matches 'str' of length 'len', else 0
static inline __attribute__((always_inline)) int prefix_search(void* trie, struct string_t* key) {
  struct string_t* found = (struct string_t*)bpf_map_lookup_elem(trie, key);
  if (found) {
    int prefix_len = 0;
    int is_prefix = 1;
    for (int i = 0; i < MAX_STR_READ_LEN && i < found->len; ++i) {
      if (found->str[i] == '\0') break;
      if (found->str[i] != key->str[i]) {
        is_prefix = 0;
        break;
      }
      prefix_len++;
    }
    if (is_prefix && prefix_len * 8 == found->len) {
      // found->str is an exact prefix of key->str
      is_prefix = 1;
    } else {
      is_prefix = 0;
    }
    if (is_prefix) {
      DBG_PRINTK("Found prefix:%s value:%u", key->str, prefix_len);
      return 1;
    } else {
      DBG_PRINTK("Not Found prefix:%s value:%d found-len:%d", key->str, prefix_len, found->len);
      return 0;
    }
  }
  DBG_PRINTK("Not Found prefix:%s", key->str);
  return 0;
}
#else
static inline __attribute__((always_inline)) int prefix_search(void* trie, struct string_t* key) {
  return 1;
}
#endif

#if defined(DATACRUMBS_ENABLE) && (DATACRUMBS_ENABLE == 1)
#if defined(DATACRUMBS_MODE) && (DATACRUMBS_MODE == 1)
static inline __attribute__((always_inline)) int mark_failed_events() {
  u32 key = DATACRUMBS_FAILED_EVENTS_KEY;
  u32* failed_value = bpf_map_lookup_elem(&failed_request, &key);
  if (failed_value == NULL) {
    u32 init_val = 0;
    bpf_map_update_elem(&failed_request, &key, &init_val, BPF_NOEXIST);
    failed_value =
        bpf_map_lookup_elem(&failed_request, &key);  // Lookup again to get the new value's address
  }
  if (failed_value != NULL) {
    (*failed_value)++;
    DBG_PRINTK("Captured failed event: %d %d\n", key, *failed_value);
    return *failed_value;
  }
  return 0;
}
#else
static inline __attribute__((always_inline)) int mark_failed_events() {
  return 0;
}
#endif
#endif

#if defined(DATACRUMBS_TRACE_ALL_PROCESSES) && (DATACRUMBS_TRACE_ALL_PROCESSES == 1)
static inline __attribute__((always_inline)) int need_tracing(struct fn_key_t* key, u64* start_ts) {
  key->id = bpf_get_current_pid_tgid();
  return 1;
}
#else
static inline __attribute__((always_inline)) int need_tracing(struct fn_key_t* key, u64* start_ts) {
  key->id = bpf_get_current_pid_tgid();
  u32 pid = key->id & 0xFFFFFFFF;
  (void)pid;
  start_ts = (u64*)bpf_map_lookup_elem(&pid_map, &pid);
  if (start_ts == 0 || key->id == 0) return 0;
  return 1;
}
#endif

#if defined(DATACRUMBS_ENABLE) && (DATACRUMBS_ENABLE == 1)
#if defined(DATACRUMBS_MODE) && (DATACRUMBS_MODE == 1)
static inline __attribute__((always_inline)) int generic_entry(struct pt_regs* ctx, u64 event_id) {
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts = 0;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t fn = {};
  fn.ts = bpf_ktime_get_ns();
  bpf_map_update_elem(&fn_pid_map, &key, &fn, BPF_ANY);
  DBG_PRINTK("Pushed pid:%d, event_id:%llu to map\n", (u32)key.id, event_id);
  return 0;
}
#else
static inline __attribute__((always_inline)) int generic_entry(struct pt_regs* ctx, u64 event_id) {
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t fn = {};
  fn.ts = bpf_ktime_get_ns();
  bpf_map_update_elem(&fn_pid_map, &key, &fn, BPF_ANY);
  DBG_PRINTK("Pushed pid:%d, event_id:%llu to map\n", (u32)key.id, event_id);
  return 0;
}
#endif
#else
static inline __attribute__((always_inline)) int generic_entry(struct pt_regs* ctx, u64 event_id) {
  return 0;
}
#endif
#if defined(DATACRUMBS_ENABLE) && (DATACRUMBS_ENABLE == 1)
#if defined(DATACRUMBS_MODE) && (DATACRUMBS_MODE == 1)
static inline __attribute__((always_inline)) int generic_exit(struct pt_regs* ctx, u64 event_id) {
  u64 te = bpf_ktime_get_ns();
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts = 0;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t* fn = bpf_map_lookup_elem(&fn_pid_map, &key);
  if (fn == 0) return 0;  // missed entry
  DATACRUMBS_SKIP_SMALL_EVENTS(fn, te);
  struct general_event_t* event;
  DATACRUMBS_RB_RESERVE(output, struct general_event_t, event);
  event->type = 1;
  event->id = key.id;
  event->event_id = event_id;
  DATACRUMBS_COLLECT_TIME(event);
  DATACRUMBS_EVENT_SUBMIT(event, key.id, event_id);
  return 0;
}
#else
static inline __attribute__((always_inline)) int generic_exit(struct pt_regs* ctx, u64 event_id) {
  u64 te = bpf_ktime_get_ns();
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t* fn = bpf_map_lookup_elem(&fn_pid_map, &key);
  if (fn == 0) return 0;  // missed entry
  struct profile_key_t profile_key = {};
  profile_key.type = 1;
  profile_key.id = key.id;
  profile_key.event_id = key.event_id;
  profile_key.time_interval = fn->ts / DATACRUMBS_TIME_INTERVAL_NS;
  struct profile_value_t* profile_value = bpf_map_lookup_elem(&profile, &profile_key);
  if (profile_value == NULL) {
    // Key not found, initialize a new value
    struct profile_value_t new_value;
    new_value.frequency = 0;
    new_value.duration = 0;
    bpf_map_update_elem(&profile, &profile_key, &new_value, BPF_NOEXIST);
    profile_value =
        bpf_map_lookup_elem(&profile, &profile_key);  // Lookup again to get the new value's address
  }
  if (profile_value != NULL) {
    profile_value->frequency++;
    profile_value->duration += (te - fn->ts);
    DBG_PRINTK("Captured event: %d, %d, %d, %d\n", profile_key.type, profile_key.id,
               profile_key.event_id, profile_key.time_interval);
  }
  bpf_map_update_elem(&latest_interval, &DATACRUMBS_TS_KEY, &profile_key.time_interval, BPF_ANY);
  return 0;
}
#endif
#else
static inline __attribute__((always_inline)) int generic_exit(struct pt_regs* ctx, u64 event_id) {
  return 0;
}
#endif

#if defined(DATACRUMBS_ENABLE) && (DATACRUMBS_ENABLE == 1)
static inline __attribute__((always_inline)) int usdt_entry(struct pt_regs* ctx, u64 event_id) {
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t fn = {};
  fn.ts = bpf_ktime_get_ns();
  bpf_map_update_elem(&fn_pid_map, &key, &fn, BPF_ANY);
  DBG_PRINTK("USDT  Pushed pid:%d, event_id:%llu to map\n", (u32)key.id, event_id);
  return 0;
}

#else
static inline __attribute__((always_inline)) int usdt_entry(struct pt_regs* ctx, u64 event_id) {
  return 0;
}
#endif

#if defined(DATACRUMBS_ENABLE) && (DATACRUMBS_ENABLE == 1)
#if defined(DATACRUMBS_MODE) && (DATACRUMBS_MODE == 1)
static inline __attribute__((always_inline)) int usdt_exit(struct pt_regs* ctx, u64 event_id,
                                                           long clazz, long method) {
  u64 te = bpf_ktime_get_ns();
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t* fn = bpf_map_lookup_elem(&fn_pid_map, &key);
  if (fn == 0) return 0;  // missed entry
  DATACRUMBS_SKIP_SMALL_EVENTS(fn, te);
  struct string_t local_str = {};                                                      // 100
  long len = bpf_probe_read_user_str(&local_str.str, MAX_STR_READ_LEN, (void*)clazz);  // 90
  local_str.len = len * 8;
#if defined(DATACRUMBS_ENABLE_INCLUSION_PATH) && (DATACRUMBS_ENABLE_INCLUSION_PATH == 1)
  int found = prefix_search(&inclusion_path_trie, &local_str);
  if (!found) {
    DBG_PRINTK("Skipping usdt for %s as it is not in inclusion path trie\n", local_str.str);
    return 0;  // Skip if not in inclusion path
  }
#endif

  struct usdt_event_t* event;
  DATACRUMBS_RB_RESERVE(output, struct usdt_event_t, event);
  event->type = 3;
  event->id = key.id;
  event->event_id = event_id;
  DATACRUMBS_COLLECT_TIME(event);

  u32 class_hash = hash_and_store(&local_str, len);
  event->class_hash = class_hash;                                                  // 100
  len = bpf_probe_read_user_str(&local_str.str, MAX_STR_READ_LEN, (void*)method);  // 90

  u32 method_hash = hash_and_store(&local_str, len);
  event->method_hash = method_hash;  // 100
  DATACRUMBS_EVENT_SUBMIT(event, key.id, event_id);
  return 0;
}
#else
static inline __attribute__((always_inline)) int usdt_exit(struct pt_regs* ctx, u64 event_id,
                                                           long clazz, long method) {
  u64 te = bpf_ktime_get_ns();
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts;
  if (!need_tracing(&key, &start_ts)) {
    return 0;  // not tracing this pid
  }
  struct fn_value_t* fn = bpf_map_lookup_elem(&fn_pid_map, &key);
  if (fn == 0) return 0;  // missed entry
  DATACRUMBS_SKIP_SMALL_EVENTS(fn, te);
  struct string_t local_str = {};                                                      // 100
  long len = bpf_probe_read_user_str(&local_str.str, MAX_STR_READ_LEN, (void*)clazz);  // 90
  local_str.len = len * 8;

#if defined(DATACRUMBS_ENABLE_INCLUSION_PATH) && (DATACRUMBS_ENABLE_INCLUSION_PATH == 1)
  int found = prefix_search(&inclusion_path_trie, &local_str);
  if (!found) {
    DBG_PRINTK("Skipping usdt for %s as it is not in inclusion path trie\n", local_str.str);
    return 0;  // Skip if not in inclusion path
  }
#endif
  struct usdt_profile_key_t profile_key = {};
  profile_key.type = 3;
  profile_key.id = key.id;
  profile_key.event_id = key.event_id;
  u32 class_hash = hash_and_store(&local_str, len);                                // 100
  len = bpf_probe_read_user_str(&local_str.str, MAX_STR_READ_LEN, (void*)method);  // 90
  u32 method_hash = hash_and_store(&local_str, len);
  profile_key.class_hash = class_hash;
  profile_key.method_hash = method_hash;
  profile_key.time_interval = fn->ts / DATACRUMBS_TIME_INTERVAL_NS;
  struct profile_value_t* profile_value = bpf_map_lookup_elem(&usdt_profile, &profile_key);
  if (profile_value == NULL) {
    // Key not found, initialize a new value
    struct profile_value_t new_value;
    bpf_map_update_elem(&usdt_profile, &profile_key, &new_value, BPF_NOEXIST);
    profile_value = bpf_map_lookup_elem(
        &usdt_profile, &profile_key);  // Lookup again to get the new value's address
  }
  if (profile_value != NULL) {
    profile_value->frequency++;
    profile_value->duration += (te - fn->ts);
    DBG_PRINTK("Captured usdt event: %d, %d, %d, %d\n", profile_key.type, profile_key.id,
               profile_key.event_id, profile_key.time_interval);
  }
  bpf_map_update_elem(&latest_interval, &DATACRUMBS_TS_KEY, &profile_key.time_interval, BPF_ANY);
  return 0;
}
#endif
#else
static inline __attribute__((always_inline)) int usdt_exit(struct pt_regs* ctx, u64 event_id,
                                                           long clazz, long method) {
  return 0;
}
#endif

#if defined(DATACRUMBS_ENABLE) && (DATACRUMBS_ENABLE == 1)
static inline __attribute__((always_inline)) int generic_fork_exit(struct pt_regs* ctx,
                                                                   u64 event_id) {
  struct fn_key_t key = {};
  key.event_id = event_id;
  u64 start_ts;
  if (need_tracing(&key, &start_ts)) {
    u64 tsp = bpf_ktime_get_ns();
    u32 pid = PT_REGS_RC(ctx);
    (void)pid;
    if (pid != 0) {
      DBG_PRINTK("Collect forked tracing PID %d", pid);
      bpf_map_update_elem(&pid_map, &pid, &tsp, BPF_ANY);
    }
  }
  return generic_exit(ctx, event_id);
}

#else
static inline __attribute__((always_inline)) int generic_fork_exit(struct pt_regs* ctx,
                                                                   u64 event_id) {
  return 0;
}
#endif

char LICENSE[] SEC("license") = "Dual BSD/GPL";
#endif  // __DATACRUMBS_SERVER_BPF_COMMON_H
