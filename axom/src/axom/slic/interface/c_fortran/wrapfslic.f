! wrapfslic.f
! This file is generated by Shroud 0.14.0. Do not edit.
!
! Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
! other Axom Project Developers. See the top-level LICENSE file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!>
!! \file wrapfslic.f
!! \brief Shroud generated wrapper for slic namespace
!<
! splicer begin file_top
! splicer end file_top
module axom_slic
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper type_defines
    ! Shroud type defines from helper type_defines
    integer, parameter, private :: &
        SH_TYPE_SIGNED_CHAR= 1, &
        SH_TYPE_SHORT      = 2, &
        SH_TYPE_INT        = 3, &
        SH_TYPE_LONG       = 4, &
        SH_TYPE_LONG_LONG  = 5, &
        SH_TYPE_SIZE_T     = 6, &
        SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &
        SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &
        SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &
        SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &
        SH_TYPE_INT8_T    =  7, &
        SH_TYPE_INT16_T   =  8, &
        SH_TYPE_INT32_T   =  9, &
        SH_TYPE_INT64_T   = 10, &
        SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &
        SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &
        SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &
        SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &
        SH_TYPE_FLOAT       = 22, &
        SH_TYPE_DOUBLE      = 23, &
        SH_TYPE_LONG_DOUBLE = 24, &
        SH_TYPE_FLOAT_COMPLEX      = 25, &
        SH_TYPE_DOUBLE_COMPLEX     = 26, &
        SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &
        SH_TYPE_BOOL      = 28, &
        SH_TYPE_CHAR      = 29, &
        SH_TYPE_CPTR      = 30, &
        SH_TYPE_STRUCT    = 31, &
        SH_TYPE_OTHER     = 32

    ! helper array_context
    type, bind(C) :: SLIC_SHROUD_array
        ! address of data
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type SLIC_SHROUD_array

    ! helper capsule_data
    type, bind(C) :: SLIC_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
        integer(C_INT) :: cmemflags = 0   ! memory flags
    end type SLIC_SHROUD_capsule_data

    !  enum axom::slic::message::Level
    integer, parameter :: message_level = C_INT
    ! splicer begin namespace.message.enum.Level
    integer(message_level), parameter :: message_error = 0
    integer(message_level), parameter :: message_warning = 1
    integer(message_level), parameter :: message_info = 2
    integer(message_level), parameter :: message_debug = 3
    integer(message_level), parameter :: message_num_levels = 4
    ! splicer end namespace.message.enum.Level

    type SlicGenericOutputStream
        type(SLIC_SHROUD_capsule_data) :: cxxmem = &
            SLIC_SHROUD_capsule_data()
        ! splicer begin class.GenericOutputStream.component_part
        ! splicer end class.GenericOutputStream.component_part
    contains
        procedure :: delete => slic_generic_output_stream_delete
        procedure :: get_instance => slic_generic_output_stream_get_instance
        procedure :: set_instance => slic_generic_output_stream_set_instance
        procedure :: associated => slic_generic_output_stream_associated
        ! splicer begin class.GenericOutputStream.type_bound_procedure_part
        ! splicer end class.GenericOutputStream.type_bound_procedure_part
    end type SlicGenericOutputStream

    interface operator (.eq.)
        module procedure generic_output_stream_eq
    end interface

    interface operator (.ne.)
        module procedure generic_output_stream_ne
    end interface

    interface assignment (=)
        module procedure slic_generic_output_stream_assign_GenericOutputStream
    end interface

    interface

        function c_generic_output_stream_ctor_default(stream, SHT_rv) &
                result(SHT_rv_ptr) &
                bind(C, name="SLIC_GenericOutputStream_ctor_default")
            use iso_c_binding, only : C_CHAR, C_PTR
            import :: SLIC_SHROUD_capsule_data
            implicit none
            character(kind=C_CHAR), intent(IN) :: stream(*)
            type(SLIC_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_rv_ptr
        end function c_generic_output_stream_ctor_default

        subroutine c_generic_output_stream_ctor_default_bufferify( &
                stream, SHT_stream_len, SHT_rv) &
                bind(C, name="SLIC_GenericOutputStream_ctor_default_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: SLIC_SHROUD_capsule_data
            implicit none
            character(kind=C_CHAR), intent(IN) :: stream(*)
            integer(C_INT), value, intent(IN) :: SHT_stream_len
            type(SLIC_SHROUD_capsule_data), intent(OUT) :: SHT_rv
        end subroutine c_generic_output_stream_ctor_default_bufferify

        function c_generic_output_stream_ctor_format(stream, format, &
                SHT_rv) &
                result(SHT_rv_ptr) &
                bind(C, name="SLIC_GenericOutputStream_ctor_format")
            use iso_c_binding, only : C_CHAR, C_PTR
            import :: SLIC_SHROUD_capsule_data
            implicit none
            character(kind=C_CHAR), intent(IN) :: stream(*)
            character(kind=C_CHAR), intent(IN) :: format(*)
            type(SLIC_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_rv_ptr
        end function c_generic_output_stream_ctor_format

        subroutine c_generic_output_stream_ctor_format_bufferify(stream, &
                SHT_stream_len, format, SHT_format_len, SHT_rv) &
                bind(C, name="SLIC_GenericOutputStream_ctor_format_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: SLIC_SHROUD_capsule_data
            implicit none
            character(kind=C_CHAR), intent(IN) :: stream(*)
            integer(C_INT), value, intent(IN) :: SHT_stream_len
            character(kind=C_CHAR), intent(IN) :: format(*)
            integer(C_INT), value, intent(IN) :: SHT_format_len
            type(SLIC_SHROUD_capsule_data), intent(OUT) :: SHT_rv
        end subroutine c_generic_output_stream_ctor_format_bufferify

        subroutine c_generic_output_stream_delete(self) &
                bind(C, name="SLIC_GenericOutputStream_delete")
            import :: SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_capsule_data), intent(INOUT) :: self
        end subroutine c_generic_output_stream_delete

        subroutine slic_initialize() &
                bind(C, name="SLIC_initialize")
            implicit none
        end subroutine slic_initialize

        function c_is_initialized() &
                result(SHT_rv) &
                bind(C, name="SLIC_isInitialized")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL) :: SHT_rv
        end function c_is_initialized

        subroutine c_create_logger(name, imask) &
                bind(C, name="SLIC_createLogger")
            use iso_c_binding, only : C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            character(kind=C_CHAR), value, intent(IN) :: imask
        end subroutine c_create_logger

        subroutine c_create_logger_bufferify(name, SHT_name_len, imask) &
                bind(C, name="SLIC_createLogger_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
            character(kind=C_CHAR), value, intent(IN) :: imask
        end subroutine c_create_logger_bufferify

        function c_activate_logger(name) &
                result(SHT_rv) &
                bind(C, name="SLIC_activateLogger")
            use iso_c_binding, only : C_BOOL, C_CHAR
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            logical(C_BOOL) :: SHT_rv
        end function c_activate_logger

        function c_activate_logger_bufferify(name, SHT_name_len) &
                result(SHT_rv) &
                bind(C, name="SLIC_activateLogger_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT
            implicit none
            character(kind=C_CHAR), intent(IN) :: name(*)
            integer(C_INT), value, intent(IN) :: SHT_name_len
            logical(C_BOOL) :: SHT_rv
        end function c_activate_logger_bufferify

        function c_get_active_logger_name(SHT_rv_capsule) &
                result(SHT_rv) &
                bind(C, name="SLIC_getActiveLoggerName")
            use iso_c_binding, only : C_PTR
            import :: SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
            type(C_PTR) :: SHT_rv
        end function c_get_active_logger_name

        subroutine c_get_active_logger_name_bufferify(SHT_rv_cdesc, &
                SHT_rv_capsule) &
                bind(C, name="SLIC_getActiveLoggerName_bufferify")
            import :: SLIC_SHROUD_array, SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_array), intent(OUT) :: SHT_rv_cdesc
            type(SLIC_SHROUD_capsule_data), intent(OUT) :: SHT_rv_capsule
        end subroutine c_get_active_logger_name_bufferify

        function c_get_logging_msg_level() &
                result(SHT_rv) &
                bind(C, name="SLIC_getLoggingMsgLevel")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT) :: SHT_rv
        end function c_get_logging_msg_level

        function slic_get_logging_msg_level() &
                result(SHT_rv) &
                bind(C, name="SLIC_getLoggingMsgLevel_bufferify")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT) :: SHT_rv
        end function slic_get_logging_msg_level

        subroutine c_set_logging_msg_level(level) &
                bind(C, name="SLIC_setLoggingMsgLevel")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
        end subroutine c_set_logging_msg_level

        subroutine slic_set_logging_msg_level(level) &
                bind(C, name="SLIC_setLoggingMsgLevel_bufferify")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
        end subroutine slic_set_logging_msg_level

        subroutine c_add_stream_to_msg_level(ls, level) &
                bind(C, name="SLIC_addStreamToMsgLevel")
            use iso_c_binding, only : C_INT
            import :: SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_capsule_data), intent(INOUT) :: ls
            integer(C_INT), value, intent(IN) :: level
        end subroutine c_add_stream_to_msg_level

        subroutine c_add_stream_to_msg_level_bufferify(ls, level) &
                bind(C, name="SLIC_addStreamToMsgLevel_bufferify")
            use iso_c_binding, only : C_INT
            import :: SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_capsule_data), intent(INOUT) :: ls
            integer(C_INT), value, intent(IN) :: level
        end subroutine c_add_stream_to_msg_level_bufferify

        subroutine c_add_stream_to_all_msg_levels(ls) &
                bind(C, name="SLIC_addStreamToAllMsgLevels")
            import :: SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_capsule_data), intent(INOUT) :: ls
        end subroutine c_add_stream_to_all_msg_levels

        subroutine c_set_abort_on_error(status) &
                bind(C, name="SLIC_setAbortOnError")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL), value, intent(IN) :: status
        end subroutine c_set_abort_on_error

        subroutine slic_enable_abort_on_error() &
                bind(C, name="SLIC_enableAbortOnError")
            implicit none
        end subroutine slic_enable_abort_on_error

        subroutine slic_disable_abort_on_error() &
                bind(C, name="SLIC_disableAbortOnError")
            implicit none
        end subroutine slic_disable_abort_on_error

        function c_is_abort_on_errors_enabled() &
                result(SHT_rv) &
                bind(C, name="SLIC_isAbortOnErrorsEnabled")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL) :: SHT_rv
        end function c_is_abort_on_errors_enabled

        subroutine c_set_abort_on_warning(status) &
                bind(C, name="SLIC_setAbortOnWarning")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL), value, intent(IN) :: status
        end subroutine c_set_abort_on_warning

        subroutine slic_enable_abort_on_warning() &
                bind(C, name="SLIC_enableAbortOnWarning")
            implicit none
        end subroutine slic_enable_abort_on_warning

        subroutine slic_disable_abort_on_warning() &
                bind(C, name="SLIC_disableAbortOnWarning")
            implicit none
        end subroutine slic_disable_abort_on_warning

        function c_is_abort_on_warnings_enabled() &
                result(SHT_rv) &
                bind(C, name="SLIC_isAbortOnWarningsEnabled")
            use iso_c_binding, only : C_BOOL
            implicit none
            logical(C_BOOL) :: SHT_rv
        end function c_is_abort_on_warnings_enabled

        subroutine c_log_message_file_line(level, message, fileName, &
                line) &
                bind(C, name="SLIC_logMessage_file_line")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: line
        end subroutine c_log_message_file_line

        subroutine c_log_message_file_line_bufferify(level, message, &
                SHT_message_len, fileName, SHT_fileName_len, line) &
                bind(C, name="SLIC_logMessage_file_line_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            integer(C_INT), value, intent(IN) :: SHT_message_len
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: SHT_fileName_len
            integer(C_INT), value, intent(IN) :: line
        end subroutine c_log_message_file_line_bufferify

        subroutine c_log_message_file_line_filter(level, message, &
                fileName, line, filter_duplicates) &
                bind(C, name="SLIC_logMessage_file_line_filter")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: line
            logical(C_BOOL), value, intent(IN) :: filter_duplicates
        end subroutine c_log_message_file_line_filter

        subroutine c_log_message_file_line_filter_bufferify(level, &
                message, SHT_message_len, fileName, SHT_fileName_len, &
                line, filter_duplicates) &
                bind(C, name="SLIC_logMessage_file_line_filter_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            integer(C_INT), value, intent(IN) :: SHT_message_len
            character(kind=C_CHAR), intent(IN) :: fileName(*)
            integer(C_INT), value, intent(IN) :: SHT_fileName_len
            integer(C_INT), value, intent(IN) :: line
            logical(C_BOOL), value, intent(IN) :: filter_duplicates
        end subroutine c_log_message_file_line_filter_bufferify

        subroutine c_log_message(level, message) &
                bind(C, name="SLIC_logMessage")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
        end subroutine c_log_message

        subroutine c_log_message_bufferify(level, message, &
                SHT_message_len) &
                bind(C, name="SLIC_logMessage_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            integer(C_INT), value, intent(IN) :: SHT_message_len
        end subroutine c_log_message_bufferify

        subroutine c_log_message_filter(level, message, &
                filter_duplicates) &
                bind(C, name="SLIC_logMessage_filter")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            logical(C_BOOL), value, intent(IN) :: filter_duplicates
        end subroutine c_log_message_filter

        subroutine c_log_message_filter_bufferify(level, message, &
                SHT_message_len, filter_duplicates) &
                bind(C, name="SLIC_logMessage_filter_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: level
            character(kind=C_CHAR), intent(IN) :: message(*)
            integer(C_INT), value, intent(IN) :: SHT_message_len
            logical(C_BOOL), value, intent(IN) :: filter_duplicates
        end subroutine c_log_message_filter_bufferify

        subroutine slic_flush_streams() &
                bind(C, name="SLIC_flushStreams")
            implicit none
        end subroutine slic_flush_streams

        subroutine slic_finalize() &
                bind(C, name="SLIC_finalize")
            implicit none
        end subroutine slic_finalize
    end interface

    interface SlicGenericOutputStream
        module procedure slic_generic_output_stream_ctor_default
        module procedure slic_generic_output_stream_ctor_format
    end interface SlicGenericOutputStream

    interface log_message
        module procedure slic_log_message_file_line
        module procedure slic_log_message_file_line_filter
        module procedure slic_log_message
        module procedure slic_log_message_filter
    end interface log_message

    interface
        ! helper capsule_dtor
        ! Delete memory in a capsule.
        subroutine SLIC_SHROUD_capsule_dtor(ptr) &
            bind(C, name="SLIC_SHROUD_memory_destructor")
            import SLIC_SHROUD_capsule_data
            implicit none
            type(SLIC_SHROUD_capsule_data), intent(INOUT) :: ptr
        end subroutine SLIC_SHROUD_capsule_dtor
    end interface

    interface
        ! helper copy_string
        ! Copy the char* or std::string in context into c_var.
        subroutine SLIC_SHROUD_copy_string(context, c_var, c_var_size) &
             bind(c,name="SLIC_ShroudCopyString")
            use, intrinsic :: iso_c_binding, only : C_CHAR, C_SIZE_T
            import SLIC_SHROUD_array
            type(SLIC_SHROUD_array), intent(IN) :: context
            character(kind=C_CHAR), intent(OUT) :: c_var(*)
            integer(C_SIZE_T), value :: c_var_size
        end subroutine SLIC_SHROUD_copy_string
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

    function slic_generic_output_stream_ctor_default(stream) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: stream
        type(SlicGenericOutputStream) :: SHT_rv
        ! splicer begin class.GenericOutputStream.method.ctor_default
        integer(C_INT) SHT_stream_len
        SHT_stream_len = len(stream, kind=C_INT)
        call c_generic_output_stream_ctor_default_bufferify(stream, &
            SHT_stream_len, SHT_rv%cxxmem)
        ! splicer end class.GenericOutputStream.method.ctor_default
    end function slic_generic_output_stream_ctor_default

    function slic_generic_output_stream_ctor_format(stream, format) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: stream
        character(len=*), intent(IN) :: format
        type(SlicGenericOutputStream) :: SHT_rv
        ! splicer begin class.GenericOutputStream.method.ctor_format
        integer(C_INT) SHT_stream_len
        integer(C_INT) SHT_format_len
        SHT_stream_len = len(stream, kind=C_INT)
        SHT_format_len = len(format, kind=C_INT)
        call c_generic_output_stream_ctor_format_bufferify(stream, &
            SHT_stream_len, format, SHT_format_len, SHT_rv%cxxmem)
        ! splicer end class.GenericOutputStream.method.ctor_format
    end function slic_generic_output_stream_ctor_format

    subroutine slic_generic_output_stream_delete(obj)
        class(SlicGenericOutputStream), intent(INOUT) :: obj
        ! splicer begin class.GenericOutputStream.method.delete
        call c_generic_output_stream_delete(obj%cxxmem)
        ! splicer end class.GenericOutputStream.method.delete
    end subroutine slic_generic_output_stream_delete

    ! Return pointer to C++ memory.
    function slic_generic_output_stream_get_instance(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(SlicGenericOutputStream), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function slic_generic_output_stream_get_instance

    subroutine slic_generic_output_stream_set_instance(obj, cxxmem)
        use iso_c_binding, only: C_PTR
        class(SlicGenericOutputStream), intent(INOUT) :: obj
        type(C_PTR), intent(IN) :: cxxmem
        obj%cxxmem%addr = cxxmem
        obj%cxxmem%idtor = 0
    end subroutine slic_generic_output_stream_set_instance

    function slic_generic_output_stream_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(SlicGenericOutputStream), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function slic_generic_output_stream_associated

    ! splicer begin class.GenericOutputStream.additional_functions
    ! splicer end class.GenericOutputStream.additional_functions

    function slic_is_initialized() &
            result(SHT_rv)
        logical :: SHT_rv
        ! splicer begin function.is_initialized
        SHT_rv = c_is_initialized()
        ! splicer end function.is_initialized
    end function slic_is_initialized

    subroutine slic_create_logger(name, imask)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: name
        character, value, intent(IN) :: imask
        ! splicer begin function.create_logger
        integer(C_INT) SHT_name_len
        SHT_name_len = len(name, kind=C_INT)
        call c_create_logger_bufferify(name, SHT_name_len, imask)
        ! splicer end function.create_logger
    end subroutine slic_create_logger

    function slic_activate_logger(name) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        character(len=*), intent(IN) :: name
        logical :: SHT_rv
        ! splicer begin function.activate_logger
        integer(C_INT) SHT_name_len
        SHT_name_len = len(name, kind=C_INT)
        SHT_rv = c_activate_logger_bufferify(name, SHT_name_len)
        ! splicer end function.activate_logger
    end function slic_activate_logger

    function slic_get_active_logger_name() &
            result(SHT_rv)
        character(len=:), allocatable :: SHT_rv
        ! splicer begin function.get_active_logger_name
        type(SLIC_SHROUD_array) :: SHT_rv_cdesc
        type(SLIC_SHROUD_capsule_data) :: SHT_rv_capsule
        call c_get_active_logger_name_bufferify(SHT_rv_cdesc, &
            SHT_rv_capsule)
        allocate(character(len=SHT_rv_cdesc%elem_len):: SHT_rv)
        call SLIC_SHROUD_copy_string(SHT_rv_cdesc, SHT_rv, &
            SHT_rv_cdesc%elem_len)
        call SLIC_SHROUD_capsule_dtor(SHT_rv_capsule)
        ! splicer end function.get_active_logger_name
    end function slic_get_active_logger_name

    subroutine slic_add_stream_to_msg_level(ls, level)
        use iso_c_binding, only : C_INT
        type(SlicGenericOutputStream), intent(INOUT) :: ls
        integer(C_INT), value, intent(IN) :: level
        ! splicer begin function.add_stream_to_msg_level
        call c_add_stream_to_msg_level_bufferify(ls%cxxmem, level)
        ! splicer end function.add_stream_to_msg_level
    end subroutine slic_add_stream_to_msg_level

    subroutine slic_add_stream_to_all_msg_levels(ls)
        type(SlicGenericOutputStream), intent(INOUT) :: ls
        ! splicer begin function.add_stream_to_all_msg_levels
        call c_add_stream_to_all_msg_levels(ls%cxxmem)
        ! splicer end function.add_stream_to_all_msg_levels
    end subroutine slic_add_stream_to_all_msg_levels

    subroutine slic_set_abort_on_error(status)
        use iso_c_binding, only : C_BOOL
        logical, value, intent(IN) :: status
        ! splicer begin function.set_abort_on_error
        logical(C_BOOL) :: SHT_status_cxx
        SHT_status_cxx = status  ! coerce to C_BOOL
        call c_set_abort_on_error(SHT_status_cxx)
        ! splicer end function.set_abort_on_error
    end subroutine slic_set_abort_on_error

    function slic_is_abort_on_errors_enabled() &
            result(SHT_rv)
        logical :: SHT_rv
        ! splicer begin function.is_abort_on_errors_enabled
        SHT_rv = c_is_abort_on_errors_enabled()
        ! splicer end function.is_abort_on_errors_enabled
    end function slic_is_abort_on_errors_enabled

    subroutine slic_set_abort_on_warning(status)
        use iso_c_binding, only : C_BOOL
        logical, value, intent(IN) :: status
        ! splicer begin function.set_abort_on_warning
        logical(C_BOOL) :: SHT_status_cxx
        SHT_status_cxx = status  ! coerce to C_BOOL
        call c_set_abort_on_warning(SHT_status_cxx)
        ! splicer end function.set_abort_on_warning
    end subroutine slic_set_abort_on_warning

    function slic_is_abort_on_warnings_enabled() &
            result(SHT_rv)
        logical :: SHT_rv
        ! splicer begin function.is_abort_on_warnings_enabled
        SHT_rv = c_is_abort_on_warnings_enabled()
        ! splicer end function.is_abort_on_warnings_enabled
    end function slic_is_abort_on_warnings_enabled

    subroutine slic_log_message_file_line(level, message, fileName, &
            line)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: level
        character(len=*), intent(IN) :: message
        character(len=*), intent(IN) :: fileName
        integer(C_INT), value, intent(IN) :: line
        ! splicer begin function.log_message_file_line
        integer(C_INT) SHT_message_len
        integer(C_INT) SHT_fileName_len
        SHT_message_len = len(message, kind=C_INT)
        SHT_fileName_len = len(fileName, kind=C_INT)
        call c_log_message_file_line_bufferify(level, message, &
            SHT_message_len, fileName, SHT_fileName_len, line)
        ! splicer end function.log_message_file_line
    end subroutine slic_log_message_file_line

    subroutine slic_log_message_file_line_filter(level, message, &
            fileName, line, filter_duplicates)
        use iso_c_binding, only : C_BOOL, C_INT
        integer(C_INT), value, intent(IN) :: level
        character(len=*), intent(IN) :: message
        character(len=*), intent(IN) :: fileName
        integer(C_INT), value, intent(IN) :: line
        logical, value, intent(IN) :: filter_duplicates
        ! splicer begin function.log_message_file_line_filter
        integer(C_INT) SHT_message_len
        integer(C_INT) SHT_fileName_len
        logical(C_BOOL) :: SHT_filter_duplicates_cxx
        SHT_message_len = len(message, kind=C_INT)
        SHT_fileName_len = len(fileName, kind=C_INT)
        SHT_filter_duplicates_cxx = filter_duplicates  ! coerce to C_BOOL
        call c_log_message_file_line_filter_bufferify(level, message, &
            SHT_message_len, fileName, SHT_fileName_len, line, &
            SHT_filter_duplicates_cxx)
        ! splicer end function.log_message_file_line_filter
    end subroutine slic_log_message_file_line_filter

    subroutine slic_log_message(level, message)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: level
        character(len=*), intent(IN) :: message
        ! splicer begin function.log_message
        integer(C_INT) SHT_message_len
        SHT_message_len = len(message, kind=C_INT)
        call c_log_message_bufferify(level, message, SHT_message_len)
        ! splicer end function.log_message
    end subroutine slic_log_message

    subroutine slic_log_message_filter(level, message, &
            filter_duplicates)
        use iso_c_binding, only : C_BOOL, C_INT
        integer(C_INT), value, intent(IN) :: level
        character(len=*), intent(IN) :: message
        logical, value, intent(IN) :: filter_duplicates
        ! splicer begin function.log_message_filter
        integer(C_INT) SHT_message_len
        logical(C_BOOL) :: SHT_filter_duplicates_cxx
        SHT_message_len = len(message, kind=C_INT)
        SHT_filter_duplicates_cxx = filter_duplicates  ! coerce to C_BOOL
        call c_log_message_filter_bufferify(level, message, &
            SHT_message_len, SHT_filter_duplicates_cxx)
        ! splicer end function.log_message_filter
    end subroutine slic_log_message_filter

    ! axom::slic::GenericOutputStream = axom::slic::GenericOutputStream
    subroutine slic_generic_output_stream_assign_GenericOutputStream(lhs, rhs)
        use iso_c_binding, only : c_associated, c_f_pointer
        class(SlicGenericOutputStream), intent(INOUT) :: lhs
        type(SlicGenericOutputStream), intent(IN) :: rhs
        interface
            subroutine do_assign(lhs, rhs) bind(C, &
                name="SLIC_GenericOutputStream_assign_GenericOutputStream")
                import :: SLIC_SHROUD_capsule_data
                type(SLIC_SHROUD_capsule_data), intent(INOUT) :: lhs
                type(SLIC_SHROUD_capsule_data), intent(IN) :: rhs
            end subroutine do_assign
        end interface
        call do_assign(lhs%cxxmem, rhs%cxxmem)
    end subroutine slic_generic_output_stream_assign_GenericOutputStream

    ! splicer begin additional_functions
    ! splicer end additional_functions

    function generic_output_stream_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(SlicGenericOutputStream), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function generic_output_stream_eq

    function generic_output_stream_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(SlicGenericOutputStream), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function generic_output_stream_ne

end module axom_slic
