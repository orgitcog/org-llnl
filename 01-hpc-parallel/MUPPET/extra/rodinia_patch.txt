Binary files rodinia_3.1/bin/linux/cuda/backprop and rodinia_3.1_new/bin/linux/cuda/backprop differ
Binary files rodinia_3.1/bin/linux/cuda/bfs and rodinia_3.1_new/bin/linux/cuda/bfs differ
diff -ruN rodinia_3.1/openmp/b+tree/command.txt rodinia_3.1_new/openmp/b+tree/command.txt
--- rodinia_3.1/openmp/b+tree/command.txt	2024-08-29 14:54:54.340427597 -0700
+++ rodinia_3.1_new/openmp/b+tree/command.txt	2024-08-29 14:50:14.134123783 -0700
@@ -1,4 +1,6 @@
-j 6000 3000
-k 10000
-
-
+j 1000000 8000
+k 60000
+j 1000000 8000
+k 60000
+j 1000000 8000
+k 60000
diff -ruN rodinia_3.1/openmp/b+tree/.gitattributes rodinia_3.1_new/openmp/b+tree/.gitattributes
--- rodinia_3.1/openmp/b+tree/.gitattributes	1969-12-31 16:00:00.000000000 -0800
+++ rodinia_3.1_new/openmp/b+tree/.gitattributes	2024-08-29 14:50:14.134123783 -0700
@@ -0,0 +1 @@
+mil.txt filter=lfs diff=lfs merge=lfs -text
diff -ruN rodinia_3.1/openmp/b+tree/kernel/kernel_cpu_2.c rodinia_3.1_new/openmp/b+tree/kernel/kernel_cpu_2.c
--- rodinia_3.1/openmp/b+tree/kernel/kernel_cpu_2.c	2024-08-29 14:54:06.589368094 -0700
+++ rodinia_3.1_new/openmp/b+tree/kernel/kernel_cpu_2.c	2024-08-29 14:50:14.139123787 -0700
@@ -12,6 +12,7 @@
 
 #include <omp.h>									// (in directory known to compiler)
 #include <stdlib.h>									// (in directory known to compiler)
+#include <stdio.h>									// (in directory known to compiler)			needed by printf, stderr
 
 //======================================================================================================================================================150
 //	COMMON
diff -ruN rodinia_3.1/openmp/b+tree/main.c rodinia_3.1_new/openmp/b+tree/main.c
--- rodinia_3.1/openmp/b+tree/main.c	2024-08-29 14:54:06.589368094 -0700
+++ rodinia_3.1_new/openmp/b+tree/main.c	2024-08-29 14:50:14.134123783 -0700
@@ -59,10 +59,10 @@
 
 #include <stdio.h>									// (in directory known to compiler)			needed by printf, stderr
 #include <limits.h>									// (in directory known to compiler)			needed by INT_MIN, INT_MAX
-// #include <sys/time.h>							// (in directory known to compiler)			needed by ???
+#include <sys/time.h>								// (in directory known to compiler)			needed by ???
 #include <math.h>									// (in directory known to compiler)			needed by log, pow
 #include <string.h>									// (in directory known to compiler)			needed by memset
-
+#include <omp.h>
 //======================================================================================================================================================150
 //	COMMON
 //======================================================================================================================================================150
@@ -1846,7 +1846,7 @@
 {
 	// assing default values
 	int cur_arg;
-	int cores_arg =1;
+	int cores_arg = omp_get_max_threads();
 	char *input_file = NULL;
 	char *command_file = NULL;
 	char *output="output.txt";
@@ -2016,6 +2016,11 @@
 	// ------------------------------------------------------------60
 	char *commandPointer=commandBuffer;
 
+	long long time0;
+	long long time1;
+
+	time0 = get_time();
+
 	printf("Waiting for command\n");
 	printf("> ");
 	while (sscanf(commandPointer, "%c", &instruction) != EOF) {
@@ -2414,6 +2419,9 @@
 	}
 	printf("\n");
 
+	time1 = get_time();
+	printf("total runtime: %.17g\n", (double)(time1 - time0) / 1000000.0);
+
 	// ------------------------------------------------------------60
 	// free remaining memory and exit
 	// ------------------------------------------------------------60
diff -ruN rodinia_3.1/openmp/b+tree/util/timer/timer.c rodinia_3.1_new/openmp/b+tree/util/timer/timer.c
--- rodinia_3.1/openmp/b+tree/util/timer/timer.c	2024-08-29 14:54:06.589368094 -0700
+++ rodinia_3.1_new/openmp/b+tree/util/timer/timer.c	2024-08-29 14:50:14.139123787 -0700
@@ -11,6 +11,7 @@
 //======================================================================================================================================================150
 
 #include <stdlib.h>
+#include <sys/time.h>
 
 //======================================================================================================================================================150
 //	FUNCTIONS
diff -ruN rodinia_3.1/openmp/cfd/euler3d_cpu_double.cpp rodinia_3.1_new/openmp/cfd/euler3d_cpu_double.cpp
--- rodinia_3.1/openmp/cfd/euler3d_cpu_double.cpp	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/cfd/euler3d_cpu_double.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,468 +0,0 @@
-// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu
-// This code is from the AIAA-2009-4001 paper
-
-#include <iostream>
-#include <fstream>
-#include <cmath>
-#include <omp.h>
-
-struct double3 { double x, y, z; };
-
-#ifndef block_length
-#error "you need to define block_length"
-#endif
-
-/*
- * Options
- *
- */
-#define GAMMA 1.4
-#define iterations 2000
-
-#define NDIM 3
-#define NNB 4
-
-#define RK 3	// 3rd order RK
-#define ff_mach 1.2
-#define deg_angle_of_attack 0.0
-
-/*
- * not options
- */
-#define VAR_DENSITY 0
-#define VAR_MOMENTUM  1
-#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)
-#define NVAR (VAR_DENSITY_ENERGY+1)
-
-
-/*
- * Generic functions
- */
-template <typename T>
-T* alloc(int N)
-{
-	return new T[N];
-}
-
-template <typename T>
-void dealloc(T* array)
-{
-	delete[] array;
-}
-
-template <typename T>
-void copy(T* dst, T* src, int N)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < N; i++)
-	{
-		dst[i] = src[i];
-	}
-}
-
-
-void dump(double* variables, int nel, int nelr)
-{
-
-
-	{
-		std::ofstream file("density");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;
-	}
-
-
-	{
-		std::ofstream file("momentum");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++)
-		{
-			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << " ";
-			file << std::endl;
-		}
-	}
-
-	{
-		std::ofstream file("density_energy");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;
-	}
-
-}
-
-/*
- * Element-based Cell-centered FVM solver functions
- */
-double ff_variable[NVAR];
-double3 ff_flux_contribution_momentum_x;
-double3 ff_flux_contribution_momentum_y;
-double3 ff_flux_contribution_momentum_z;
-double3 ff_flux_contribution_density_energy;
-
-
-void initialize_variables(int nelr, double* variables)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];
-	}
-}
-
-inline void compute_flux_contribution(double& density, double3& momentum, double& density_energy, double& pressure, double3& velocity, double3& fc_momentum_x, double3& fc_momentum_y, double3& fc_momentum_z, double3& fc_density_energy)
-{
-	fc_momentum_x.x = velocity.x*momentum.x + pressure;
-	fc_momentum_x.y = velocity.x*momentum.y;
-	fc_momentum_x.z = velocity.x*momentum.z;
-
-	fc_momentum_y.x = fc_momentum_x.y;
-	fc_momentum_y.y = velocity.y*momentum.y + pressure;
-	fc_momentum_y.z = velocity.y*momentum.z;
-
-	fc_momentum_z.x = fc_momentum_x.z;
-	fc_momentum_z.y = fc_momentum_y.z;
-	fc_momentum_z.z = velocity.z*momentum.z + pressure;
-
-	double de_p = density_energy+pressure;
-	fc_density_energy.x = velocity.x*de_p;
-	fc_density_energy.y = velocity.y*de_p;
-	fc_density_energy.z = velocity.z*de_p;
-}
-
-inline void compute_velocity(double& density, double3& momentum, double3& velocity)
-{
-	velocity.x = momentum.x / density;
-	velocity.y = momentum.y / density;
-	velocity.z = momentum.z / density;
-}
-
-inline double compute_speed_sqd(double3& velocity)
-{
-	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;
-}
-
-inline double compute_pressure(double& density, double& density_energy, double& speed_sqd)
-{
-	return (double(GAMMA)-double(1.0))*(density_energy - double(0.5)*density*speed_sqd);
-}
-
-inline double compute_speed_of_sound(double& density, double& pressure)
-{
-	return std::sqrt(double(GAMMA)*pressure/density);
-}
-
-
-
-void compute_step_factor(int nelr, double* variables, double* areas, double* step_factors)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		double density = variables[NVAR*i + VAR_DENSITY];
-
-		double3 momentum;
-		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-
-		double density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];
-		double3 velocity;	   compute_velocity(density, momentum, velocity);
-		double speed_sqd      = compute_speed_sqd(velocity);
-		double pressure       = compute_pressure(density, density_energy, speed_sqd);
-		double speed_of_sound = compute_speed_of_sound(density, pressure);
-
-		// dt = double(0.5) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once
-		step_factors[i] = double(0.5) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));
-	}
-}
-
-
-/*
- *
- *
-*/
-
-void compute_flux(int nelr, int* elements_surrounding_elements, double* normals, double* variables, double* fluxes)
-{
-	const double smoothing_coefficient = double(0.2f);
-
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		int j, nb;
-		double3 normal; double normal_len;
-		double factor;
-
-		double density_i = variables[NVAR*i + VAR_DENSITY];
-		double3 momentum_i;
-		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-
-		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];
-
-		double3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);
-		double speed_sqd_i                          = compute_speed_sqd(velocity_i);
-		double speed_i                              = std::sqrt(speed_sqd_i);
-		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);
-		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);
-		double3 flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z;
-		double3 flux_contribution_i_density_energy;
-		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z, flux_contribution_i_density_energy);
-
-		double flux_i_density = double(0.0);
-		double3 flux_i_momentum;
-		flux_i_momentum.x = double(0.0);
-		flux_i_momentum.y = double(0.0);
-		flux_i_momentum.z = double(0.0);
-		double flux_i_density_energy = double(0.0);
-
-		double3 velocity_nb;
-		double density_nb, density_energy_nb;
-		double3 momentum_nb;
-		double3 flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z;
-		double3 flux_contribution_nb_density_energy;
-		double speed_sqd_nb, speed_of_sound_nb, pressure_nb;
-
-		for(j = 0; j < NNB; j++)
-		{
-			nb = elements_surrounding_elements[i*NNB + j];
-			normal.x = normals[(i*NNB + j)*NDIM + 0];
-			normal.y = normals[(i*NNB + j)*NDIM + 1];
-			normal.z = normals[(i*NNB + j)*NDIM + 2];
-			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
-
-			if(nb >= 0) 	// a legitimate neighbor
-			{
-				density_nb =        variables[nb*NVAR + VAR_DENSITY];
-				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];
-				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];
-				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];
-				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];
-													compute_velocity(density_nb, momentum_nb, velocity_nb);
-				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);
-				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);
-				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);
-													compute_flux_contribution(density_nb, momentum_nb, density_energy_nb, pressure_nb, velocity_nb, flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z, flux_contribution_nb_density_energy);
-
-				// artificial viscosity
-				factor = -normal_len*smoothing_coefficient*double(0.5)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);
-				flux_i_density += factor*(density_i-density_nb);
-				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);
-				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);
-				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);
-				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);
-
-				// accumulate cell-centered fluxes
-				factor = double(0.5)*normal.x;
-				flux_i_density += factor*(momentum_nb.x+momentum_i.x);
-				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.x+flux_contribution_i_density_energy.x);
-				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.x+flux_contribution_i_momentum_x.x);
-				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.x+flux_contribution_i_momentum_y.x);
-				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.x+flux_contribution_i_momentum_z.x);
-
-				factor = double(0.5)*normal.y;
-				flux_i_density += factor*(momentum_nb.y+momentum_i.y);
-				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.y+flux_contribution_i_density_energy.y);
-				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.y+flux_contribution_i_momentum_x.y);
-				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.y+flux_contribution_i_momentum_y.y);
-				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.y+flux_contribution_i_momentum_z.y);
-
-				factor = double(0.5)*normal.z;
-				flux_i_density += factor*(momentum_nb.z+momentum_i.z);
-				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.z+flux_contribution_i_density_energy.z);
-				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.z+flux_contribution_i_momentum_x.z);
-				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.z+flux_contribution_i_momentum_y.z);
-				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.z+flux_contribution_i_momentum_z.z);
-			}
-			else if(nb == -1)	// a wing boundary
-			{
-				flux_i_momentum.x += normal.x*pressure_i;
-				flux_i_momentum.y += normal.y*pressure_i;
-				flux_i_momentum.z += normal.z*pressure_i;
-			}
-			else if(nb == -2) // a far field boundary
-			{
-				factor = double(0.5)*normal.x;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);
-				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.x+flux_contribution_i_density_energy.x);
-				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.x + flux_contribution_i_momentum_x.x);
-				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.x + flux_contribution_i_momentum_y.x);
-				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.x + flux_contribution_i_momentum_z.x);
-
-				factor = double(0.5)*normal.y;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);
-				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.y+flux_contribution_i_density_energy.y);
-				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.y + flux_contribution_i_momentum_x.y);
-				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.y + flux_contribution_i_momentum_y.y);
-				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.y + flux_contribution_i_momentum_z.y);
-
-				factor = double(0.5)*normal.z;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);
-				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.z+flux_contribution_i_density_energy.z);
-				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.z + flux_contribution_i_momentum_x.z);
-				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.z + flux_contribution_i_momentum_y.z);
-				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.z + flux_contribution_i_momentum_z.z);
-
-			}
-		}
-
-		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;
-		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;
-		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;
-		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;
-		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;
-	}
-}
-
-void time_step(int j, int nelr, double* old_variables, double* variables, double* step_factors, double* fluxes)
-{
-	#pragma omp parallel for  default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		double factor = step_factors[i]/double(RK+1-j);
-
-		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];
-		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];
-		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];
-		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];
-		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];
-	}
-}
-/*
- * Main function
- */
-int main(int argc, char** argv)
-{
-	if (argc < 2)
-	{
-		std::cout << "specify data file name" << std::endl;
-		return 0;
-	}
-	const char* data_file_name = argv[1];
-
-	// set far field conditions
-	{
-		const double angle_of_attack = double(3.1415926535897931 / 180.0) * double(deg_angle_of_attack);
-
-		ff_variable[VAR_DENSITY] = double(1.4);
-
-		double ff_pressure = double(1.0);
-		double ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);
-		double ff_speed = double(ff_mach)*ff_speed_of_sound;
-
-		double3 ff_velocity;
-		ff_velocity.x = ff_speed*double(cos((double)angle_of_attack));
-		ff_velocity.y = ff_speed*double(sin((double)angle_of_attack));
-		ff_velocity.z = 0.0;
-
-		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;
-		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;
-		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;
-
-		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(double(0.5)*(ff_speed*ff_speed)) + (ff_pressure / double(GAMMA-1.0));
-
-		double3 ff_momentum;
-		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);
-		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);
-		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);
-		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy);
-	}
-	int nel;
-	int nelr;
-
-	// read in domain geometry
-	double* areas;
-	int* elements_surrounding_elements;
-	double* normals;
-	{
-		std::ifstream file(data_file_name);
-
-		file >> nel;
-		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));
-
-		areas = new double[nelr];
-		elements_surrounding_elements = new int[nelr*NNB];
-		normals = new double[NDIM*NNB*nelr];
-
-		// read in data
-		for(int i = 0; i < nel; i++)
-		{
-			file >> areas[i];
-			for(int j = 0; j < NNB; j++)
-			{
-				file >> elements_surrounding_elements[i*NNB + j];
-				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;
-				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering
-
-				for(int k = 0; k < NDIM; k++)
-				{
-					file >>  normals[(i*NNB + j)*NDIM + k];
-					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];
-				}
-			}
-		}
-
-		// fill in remaining data
-		int last = nel-1;
-		for(int i = nel; i < nelr; i++)
-		{
-			areas[i] = areas[last];
-			for(int j = 0; j < NNB; j++)
-			{
-				// duplicate the last element
-				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];
-				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];
-			}
-		}
-	}
-
-	// Create arrays and set initial conditions
-	double* variables = alloc<double>(nelr*NVAR);
-	initialize_variables(nelr, variables);
-
-	double* old_variables = alloc<double>(nelr*NVAR);
-	double* fluxes = alloc<double>(nelr*NVAR);
-	double* step_factors = alloc<double>(nelr);
-
-	// these need to be computed the first time in order to compute time step
-	std::cout << "Starting..." << std::endl;
-	double start = omp_get_wtime();
-
-	// Begin iterations
-	for(int i = 0; i < iterations; i++)
-	{
-		copy<double>(old_variables, variables, nelr*NVAR);
-
-		// for the first iteration we compute the time step
-		compute_step_factor(nelr, variables, areas, step_factors);
-
-		for(int j = 0; j < RK; j++)
-		{
-			compute_flux(nelr, elements_surrounding_elements, normals, variables, fluxes);
-			time_step(j, nelr, old_variables, variables, step_factors, fluxes);
-		}
-	}
-
-	double end = omp_get_wtime();
-	std::cout  << (end-start)  / iterations << " seconds per iteration" << std::endl;
-
-	std::cout << "Saving solution..." << std::endl;
-	dump(variables, nel, nelr);
-	std::cout << "Saved solution..." << std::endl;
-
-
-	std::cout << "Cleaning up..." << std::endl;
-	dealloc<double>(areas);
-	dealloc<int>(elements_surrounding_elements);
-	dealloc<double>(normals);
-
-	dealloc<double>(variables);
-	dealloc<double>(old_variables);
-	dealloc<double>(fluxes);
-	dealloc<double>(step_factors);
-
-	std::cout << "Done..." << std::endl;
-
-	return 0;
-}
diff -ruN rodinia_3.1/openmp/cfd/.gitattributes rodinia_3.1_new/openmp/cfd/.gitattributes
--- rodinia_3.1/openmp/cfd/.gitattributes	1969-12-31 16:00:00.000000000 -0800
+++ rodinia_3.1_new/openmp/cfd/.gitattributes	2024-08-29 14:50:13.867123554 -0700
@@ -0,0 +1 @@
+fvcorr.domn.193K filter=lfs diff=lfs merge=lfs -text
diff -ruN rodinia_3.1/openmp/cfd/makefile rodinia_3.1_new/openmp/cfd/makefile
--- rodinia_3.1/openmp/cfd/makefile	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/cfd/makefile	2024-08-29 14:50:13.866123553 -0700
@@ -3,6 +3,9 @@
 OMP_NUM_THREADS = 8
 MIC_OMP_NUM_THREADS = 216
 
+CC = gcc
+CC_FLAGS = -g -fopenmp  -O2
+
 all: euler3d_cpu euler3d_cpu_double pre_euler3d_cpu pre_euler3d_cpu_double euler3d_cpu_offload
 
 #euler3d: euler3d.cu
@@ -12,10 +15,10 @@
 #	nvcc -Xptxas -v -O3 --gpu-architecture=compute_13 --gpu-code=compute_13 euler3d_double.cu -o euler3d_double -I$(CUDA_SDK_PATH)/common/inc  -L$(CUDA_SDK_PATH)/lib  -lcutil
 
 euler3d_cpu: euler3d_cpu.cpp
-	g++ -O3 -Dblock_length=$(OMP_NUM_THREADS) -fopenmp euler3d_cpu.cpp -o euler3d_cpu
+	$(CC) $(CC_FLAGS) -O3 -Dblock_length=$(OMP_NUM_THREADS) -fopenmp euler3d_cpu.cpp -o euler3d_cpu -lm
 
 euler3d_cpu_offload:
-	icc -g -O3 -DOMP_OFFLOAD -Dblock_length=$(MIC_OMP_NUM_THREADS) -fopenmp -offload-option,mic,compiler,"-no-opt-prefetch" euler3d_cpu.cpp -o euler3d_cpu_offload
+	icpx -g -O3 -DOMP_OFFLOAD -Dblock_length=$(MIC_OMP_NUM_THREADS) -fopenmp -offload-option,mic,compiler,"-no-opt-prefetch" euler3d_cpu.cpp -o euler3d_cpu_offload
 
 euler3d_cpu_double: euler3d_cpu_double.cpp
 	g++ -O3 -Dblock_length=$(OMP_NUM_THREADS) -fopenmp euler3d_cpu_double.cpp -o euler3d_cpu_double
diff -ruN rodinia_3.1/openmp/cfd/pre_euler3d_cpu.cpp rodinia_3.1_new/openmp/cfd/pre_euler3d_cpu.cpp
--- rodinia_3.1/openmp/cfd/pre_euler3d_cpu.cpp	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/cfd/pre_euler3d_cpu.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,547 +0,0 @@
-// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu
-// This code is from the AIAA-2009-4001 paper
-
-#include <iostream>
-#include <fstream>
-#include <cmath>
-#include <omp.h>
-
-struct float3 { float x, y, z; };
-
-#ifndef block_length
-#error "you need to define block_length"
-#endif
-
-/*
- * Options
- *
- */
-#define GAMMA 1.4
-#define iterations 2000
-
-#define NDIM 3
-#define NNB 4
-
-#define RK 3	// 3rd order RK
-#define ff_mach 1.2
-#define deg_angle_of_attack 0.0f
-
-/*
- * not options
- */
-#define VAR_DENSITY 0
-#define VAR_MOMENTUM  1
-#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)
-#define NVAR (VAR_DENSITY_ENERGY+1)
-
-
-/*
- * Generic functions
- */
-template <typename T>
-T* alloc(int N)
-{
-	return new T[N];
-}
-
-template <typename T>
-void dealloc(T* array)
-{
-	delete[] array;
-}
-
-template <typename T>
-void copy(T* dst, T* src, int N)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < N; i++)
-	{
-		dst[i] = src[i];
-	}
-}
-
-
-void dump(float* variables, int nel, int nelr)
-{
-
-
-	{
-		std::ofstream file("density");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;
-	}
-
-
-	{
-		std::ofstream file("momentum");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++)
-		{
-			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << " ";
-			file << std::endl;
-		}
-	}
-
-	{
-		std::ofstream file("density_energy");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;
-	}
-
-}
-
-/*
- * Element-based Cell-centered FVM solver functions
- */
-float ff_variable[NVAR];
-float3 ff_fc_momentum_x;
-float3 ff_fc_momentum_y;
-float3 ff_fc_momentum_z;
-float3 ff_fc_density_energy;
-
-
-void initialize_variables(int nelr, float* variables)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];
-	}
-}
-
-inline void compute_flux_contribution(float& density, float3& momentum, float& density_energy, float& pressure, float3& velocity, float3& fc_momentum_x, float3& fc_momentum_y, float3& fc_momentum_z, float3& fc_density_energy)
-{
-	fc_momentum_x.x = velocity.x*momentum.x + pressure;
-	fc_momentum_x.y = velocity.x*momentum.y;
-	fc_momentum_x.z = velocity.x*momentum.z;
-
-	fc_momentum_y.x = fc_momentum_x.y;
-	fc_momentum_y.y = velocity.y*momentum.y + pressure;
-	fc_momentum_y.z = velocity.y*momentum.z;
-
-	fc_momentum_z.x = fc_momentum_x.z;
-	fc_momentum_z.y = fc_momentum_y.z;
-	fc_momentum_z.z = velocity.z*momentum.z + pressure;
-
-	float de_p = density_energy+pressure;
-	fc_density_energy.x = velocity.x*de_p;
-	fc_density_energy.y = velocity.y*de_p;
-	fc_density_energy.z = velocity.z*de_p;
-}
-
-inline void compute_velocity(float& density, float3& momentum, float3& velocity)
-{
-	velocity.x = momentum.x / density;
-	velocity.y = momentum.y / density;
-	velocity.z = momentum.z / density;
-}
-
-inline float compute_speed_sqd(float3& velocity)
-{
-	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;
-}
-
-inline float compute_pressure(float& density, float& density_energy, float& speed_sqd)
-{
-	return (float(GAMMA)-float(1.0f))*(density_energy - float(0.5f)*density*speed_sqd);
-}
-
-inline float compute_speed_of_sound(float& density, float& pressure)
-{
-	return std::sqrt(float(GAMMA)*pressure/density);
-}
-
-
-
-void compute_step_factor(int nelr, float* variables, float* areas, float* step_factors)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		float density = variables[NVAR*i + VAR_DENSITY];
-
-		float3 momentum;
-		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-
-		float density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];
-		float3 velocity;	   compute_velocity(density, momentum, velocity);
-		float speed_sqd      = compute_speed_sqd(velocity);
-		float pressure       = compute_pressure(density, density_energy, speed_sqd);
-		float speed_of_sound = compute_speed_of_sound(density, pressure);
-
-		// dt = float(0.5f) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once
-		step_factors[i] = float(0.5f) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));
-	}
-}
-
-void compute_flux_contributions(int nelr, float* variables, float* fc_momentum_x, float* fc_momentum_y, float* fc_momentum_z, float* fc_density_energy)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		float density_i = variables[NVAR*i + VAR_DENSITY];
-		float3 momentum_i;
-		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-		float density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];
-
-		float3 velocity_i;             				compute_velocity(density_i, momentum_i, velocity_i);
-		float speed_sqd_i                          = compute_speed_sqd(velocity_i);
-		float speed_i                              = sqrtf(speed_sqd_i);
-		float pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);
-		float speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);
-		float3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;
-		float3 fc_i_density_energy;	
-		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z, fc_i_density_energy);
-
-		fc_momentum_x[i*NDIM + 0] = fc_i_momentum_x.x;
-		fc_momentum_x[i*NDIM + 1] = fc_i_momentum_x.y;
-		fc_momentum_x[i*NDIM+  2] = fc_i_momentum_x.z;
-
-		fc_momentum_y[i*NDIM+ 0] = fc_i_momentum_y.x;
-		fc_momentum_y[i*NDIM+ 1] = fc_i_momentum_y.y;
-		fc_momentum_y[i*NDIM+ 2] = fc_i_momentum_y.z;
-
-
-		fc_momentum_z[i*NDIM+ 0] = fc_i_momentum_z.x;
-		fc_momentum_z[i*NDIM+ 1] = fc_i_momentum_z.y;
-		fc_momentum_z[i*NDIM+ 2] = fc_i_momentum_z.z;
-
-		fc_density_energy[i*NDIM+ 0] = fc_i_density_energy.x;
-		fc_density_energy[i*NDIM+ 1] = fc_i_density_energy.y;
-		fc_density_energy[i*NDIM+ 2] = fc_i_density_energy.z;
-	}
-
-}
-
-/*
- *
- *
-*/
-
-void compute_flux(int nelr, int* elements_surrounding_elements, float* normals, float* variables, float* fc_momentum_x, float* fc_momentum_y, float* fc_momentum_z, float* fc_density_energy, float* fluxes)
-{
-	const float smoothing_coefficient = float(0.2f);
-
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		int j, nb;
-		float3 normal; float normal_len;
-		float factor;
-
-		float density_i = variables[NVAR*i + VAR_DENSITY];
-		float3 momentum_i;
-		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-		float density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];
-
-		float3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);
-		float speed_sqd_i                          = compute_speed_sqd(velocity_i);
-		float speed_i                              = std::sqrt(speed_sqd_i);
-		float pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);
-		float speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);
-		float3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;
-		float3 fc_i_density_energy;
-
-		fc_i_momentum_x.x = fc_momentum_x[i*NDIM + 0];
-		fc_i_momentum_x.y = fc_momentum_x[i*NDIM + 1];
-		fc_i_momentum_x.z = fc_momentum_x[i*NDIM + 2];
-
-		fc_i_momentum_y.x = fc_momentum_y[i*NDIM + 0];
-		fc_i_momentum_y.y = fc_momentum_y[i*NDIM + 1];
-		fc_i_momentum_y.z = fc_momentum_y[i*NDIM + 2];
-
-		fc_i_momentum_z.x = fc_momentum_z[i*NDIM + 0];
-		fc_i_momentum_z.y = fc_momentum_z[i*NDIM + 1];
-		fc_i_momentum_z.z = fc_momentum_z[i*NDIM + 2];
-
-		fc_i_density_energy.x = fc_density_energy[i*NDIM + 0];
-		fc_i_density_energy.y = fc_density_energy[i*NDIM + 1];
-		fc_i_density_energy.z = fc_density_energy[i*NDIM + 2];
-
-		float flux_i_density = float(0.0f);
-		float3 flux_i_momentum;
-		flux_i_momentum.x = float(0.0f);
-		flux_i_momentum.y = float(0.0f);
-		flux_i_momentum.z = float(0.0f);
-		float flux_i_density_energy = float(0.0f);
-
-		float3 velocity_nb;
-		float density_nb, density_energy_nb;
-		float3 momentum_nb;
-		float3 fc_nb_momentum_x, fc_nb_momentum_y, fc_nb_momentum_z;
-		float3 fc_nb_density_energy;
-		float speed_sqd_nb, speed_of_sound_nb, pressure_nb;
-
-		for(j = 0; j < NNB; j++)
-		{
-			nb = elements_surrounding_elements[i*NNB + j];
-			normal.x = normals[(i*NNB + j)*NDIM + 0];
-			normal.y = normals[(i*NNB + j)*NDIM + 1];
-			normal.z = normals[(i*NNB + j)*NDIM + 2];
-			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
-
-			if(nb >= 0) 	// a legitimate neighbor
-			{
-				density_nb =        variables[nb*NVAR + VAR_DENSITY];
-				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];
-				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];
-				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];
-				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];
-													compute_velocity(density_nb, momentum_nb, velocity_nb);
-				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);
-				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);
-				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);
-				fc_nb_momentum_x.x = fc_momentum_x[nb*NDIM + 0];
-				fc_nb_momentum_x.y = fc_momentum_x[nb*NDIM + 1];
-				fc_nb_momentum_x.z = fc_momentum_x[nb*NDIM + 2];
-
-				fc_nb_momentum_y.x = fc_momentum_y[nb*NDIM + 0];
-				fc_nb_momentum_y.y = fc_momentum_y[nb*NDIM + 1];
-				fc_nb_momentum_y.z = fc_momentum_y[nb*NDIM + 2];
-
-				fc_nb_momentum_z.x = fc_momentum_z[nb*NDIM + 0];
-				fc_nb_momentum_z.y = fc_momentum_z[nb*NDIM + 1];
-				fc_nb_momentum_z.z = fc_momentum_z[nb*NDIM + 2];
-
-				fc_nb_density_energy.x = fc_density_energy[nb*NDIM + 0];
-				fc_nb_density_energy.y = fc_density_energy[nb*NDIM + 1];
-				fc_nb_density_energy.z = fc_density_energy[nb*NDIM + 2];
-
-				// artificial viscosity
-				factor = -normal_len*smoothing_coefficient*float(0.5f)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);
-				flux_i_density += factor*(density_i-density_nb);
-				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);
-				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);
-				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);
-				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);
-
-				// accumulate cell-centered fluxes
-				factor = float(0.5f)*normal.x;
-				flux_i_density += factor*(momentum_nb.x+momentum_i.x);
-				flux_i_density_energy += factor*(fc_nb_density_energy.x+fc_i_density_energy.x);
-				flux_i_momentum.x += factor*(fc_nb_momentum_x.x+fc_i_momentum_x.x);
-				flux_i_momentum.y += factor*(fc_nb_momentum_y.x+fc_i_momentum_y.x);
-				flux_i_momentum.z += factor*(fc_nb_momentum_z.x+fc_i_momentum_z.x);
-
-				factor = float(0.5f)*normal.y;
-				flux_i_density += factor*(momentum_nb.y+momentum_i.y);
-				flux_i_density_energy += factor*(fc_nb_density_energy.y+fc_i_density_energy.y);
-				flux_i_momentum.x += factor*(fc_nb_momentum_x.y+fc_i_momentum_x.y);
-				flux_i_momentum.y += factor*(fc_nb_momentum_y.y+fc_i_momentum_y.y);
-				flux_i_momentum.z += factor*(fc_nb_momentum_z.y+fc_i_momentum_z.y);
-
-				factor = float(0.5f)*normal.z;
-				flux_i_density += factor*(momentum_nb.z+momentum_i.z);
-				flux_i_density_energy += factor*(fc_nb_density_energy.z+fc_i_density_energy.z);
-				flux_i_momentum.x += factor*(fc_nb_momentum_x.z+fc_i_momentum_x.z);
-				flux_i_momentum.y += factor*(fc_nb_momentum_y.z+fc_i_momentum_y.z);
-				flux_i_momentum.z += factor*(fc_nb_momentum_z.z+fc_i_momentum_z.z);
-			}
-			else if(nb == -1)	// a wing boundary
-			{
-				flux_i_momentum.x += normal.x*pressure_i;
-				flux_i_momentum.y += normal.y*pressure_i;
-				flux_i_momentum.z += normal.z*pressure_i;
-			}
-			else if(nb == -2) // a far field boundary
-			{
-				factor = float(0.5f)*normal.x;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);
-				flux_i_density_energy += factor*(ff_fc_density_energy.x+fc_i_density_energy.x);
-				flux_i_momentum.x += factor*(ff_fc_momentum_x.x + fc_i_momentum_x.x);
-				flux_i_momentum.y += factor*(ff_fc_momentum_y.x + fc_i_momentum_y.x);
-				flux_i_momentum.z += factor*(ff_fc_momentum_z.x + fc_i_momentum_z.x);
-
-				factor = float(0.5f)*normal.y;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);
-				flux_i_density_energy += factor*(ff_fc_density_energy.y+fc_i_density_energy.y);
-				flux_i_momentum.x += factor*(ff_fc_momentum_x.y + fc_i_momentum_x.y);
-				flux_i_momentum.y += factor*(ff_fc_momentum_y.y + fc_i_momentum_y.y);
-				flux_i_momentum.z += factor*(ff_fc_momentum_z.y + fc_i_momentum_z.y);
-
-				factor = float(0.5f)*normal.z;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);
-				flux_i_density_energy += factor*(ff_fc_density_energy.z+fc_i_density_energy.z);
-				flux_i_momentum.x += factor*(ff_fc_momentum_x.z + fc_i_momentum_x.z);
-				flux_i_momentum.y += factor*(ff_fc_momentum_y.z + fc_i_momentum_y.z);
-				flux_i_momentum.z += factor*(ff_fc_momentum_z.z + fc_i_momentum_z.z);
-
-			}
-		}
-
-		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;
-		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;
-		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;
-		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;
-		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;
-	}
-}
-
-void time_step(int j, int nelr, float* old_variables, float* variables, float* step_factors, float* fluxes)
-{
-	#pragma omp parallel for  default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		float factor = step_factors[i]/float(RK+1-j);
-
-		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];
-		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];
-		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];
-		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];
-		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];
-	}
-}
-/*
- * Main function
- */
-int main(int argc, char** argv)
-{
-	if (argc < 2)
-	{
-		std::cout << "specify data file name" << std::endl;
-		return 0;
-	}
-	const char* data_file_name = argv[1];
-
-	// set far field conditions
-	{
-		const float angle_of_attack = float(3.1415926535897931 / 180.0f) * float(deg_angle_of_attack);
-
-		ff_variable[VAR_DENSITY] = float(1.4);
-
-		float ff_pressure = float(1.0f);
-		float ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);
-		float ff_speed = float(ff_mach)*ff_speed_of_sound;
-
-		float3 ff_velocity;
-		ff_velocity.x = ff_speed*float(cos((float)angle_of_attack));
-		ff_velocity.y = ff_speed*float(sin((float)angle_of_attack));
-		ff_velocity.z = 0.0f;
-
-		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;
-		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;
-		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;
-
-		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(float(0.5f)*(ff_speed*ff_speed)) + (ff_pressure / float(GAMMA-1.0f));
-
-		float3 ff_momentum;
-		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);
-		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);
-		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);
-		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_fc_momentum_x, ff_fc_momentum_y, ff_fc_momentum_z, ff_fc_density_energy);
-	}
-	int nel;
-	int nelr;
-
-
-	// read in domain geometry
-	float* areas;
-	int* elements_surrounding_elements;
-	float* normals;
-	{
-		std::ifstream file(data_file_name);
-
-		file >> nel;
-		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));
-
-		areas = new float[nelr];
-		elements_surrounding_elements = new int[nelr*NNB];
-		normals = new float[NDIM*NNB*nelr];
-
-		// read in data
-		for(int i = 0; i < nel; i++)
-		{
-			file >> areas[i];
-			for(int j = 0; j < NNB; j++)
-			{
-				file >> elements_surrounding_elements[i*NNB + j];
-				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;
-				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering
-
-				for(int k = 0; k < NDIM; k++)
-				{
-					file >>  normals[(i*NNB + j)*NDIM + k];
-					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];
-				}
-			}
-		}
-
-		// fill in remaining data
-		int last = nel-1;
-		for(int i = nel; i < nelr; i++)
-		{
-			areas[i] = areas[last];
-			for(int j = 0; j < NNB; j++)
-			{
-				// duplicate the last element
-				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];
-				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];
-			}
-		}
-	}
-
-	// Create arrays and set initial conditions
-	float* variables = alloc<float>(nelr*NVAR);
-	initialize_variables(nelr, variables);
-
-	float* old_variables = alloc<float>(nelr*NVAR);
-	float* fluxes = alloc<float>(nelr*NVAR);
-	float* step_factors = alloc<float>(nelr);
-	float* fc_momentum_x = alloc<float>(nelr*NDIM); 
-	float* fc_momentum_y = alloc<float>(nelr*NDIM);
-	float* fc_momentum_z = alloc<float>(nelr*NDIM);
-	float* fc_density_energy = alloc<float>(nelr*NDIM);
-
-	// these need to be computed the first time in order to compute time step
-	std::cout << "Starting..." << std::endl;
-	double start = omp_get_wtime();
-
-	// Begin iterations
-	for(int i = 0; i < iterations; i++)
-	{
-		copy<float>(old_variables, variables, nelr*NVAR);
-
-		// for the first iteration we compute the time step
-		compute_step_factor(nelr, variables, areas, step_factors);
-
-		for(int j = 0; j < RK; j++)
-		{
-			compute_flux_contributions(nelr, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy);
-			compute_flux(nelr, elements_surrounding_elements, normals, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy, fluxes);
-			time_step(j, nelr, old_variables, variables, step_factors, fluxes);
-		}
-	}
-
-	double end = omp_get_wtime();
-	std::cout  << (end-start)  / iterations << " seconds per iteration" << std::endl;
-
-
-
-	std::cout << "Saving solution..." << std::endl;
-	dump(variables, nel, nelr);
-	std::cout << "Saved solution..." << std::endl;
-
-
-	std::cout << "Cleaning up..." << std::endl;
-	dealloc<float>(areas);
-	dealloc<int>(elements_surrounding_elements);
-	dealloc<float>(normals);
-
-	dealloc<float>(variables);
-	dealloc<float>(old_variables);
-	dealloc<float>(fluxes);
-	dealloc<float>(step_factors);
-	dealloc<float>(fc_momentum_x); 
-	dealloc<float>(fc_momentum_y);
-	dealloc<float>(fc_momentum_z);
-	dealloc<float>(fc_density_energy);
-	std::cout << "Done..." << std::endl;
-
-	return 0;
-}
diff -ruN rodinia_3.1/openmp/cfd/pre_euler3d_cpu_double.cpp rodinia_3.1_new/openmp/cfd/pre_euler3d_cpu_double.cpp
--- rodinia_3.1/openmp/cfd/pre_euler3d_cpu_double.cpp	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/cfd/pre_euler3d_cpu_double.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,547 +0,0 @@
-// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu
-// This code is from the AIAA-2009-4001 paper
-
-
-#include <iostream>
-#include <fstream>
-#include <cmath>
-#include <omp.h>
-
-struct double3 { double x, y, z; };
-
-#ifndef block_length
-#error "you need to define block_length"
-#endif
-
-/*
- * Options
- *
- */
-#define GAMMA 1.4
-#define iterations 2000
-
-#define NDIM 3
-#define NNB 4
-
-#define RK 3	// 3rd order RK
-#define ff_mach 1.2
-#define deg_angle_of_attack 0.0
-
-/*
- * not options
- */
-#define VAR_DENSITY 0
-#define VAR_MOMENTUM  1
-#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)
-#define NVAR (VAR_DENSITY_ENERGY+1)
-
-
-/*
- * Generic functions
- */
-template <typename T>
-T* alloc(int N)
-{
-	return new T[N];
-}
-
-template <typename T>
-void dealloc(T* array)
-{
-	delete[] array;
-}
-
-template <typename T>
-void copy(T* dst, T* src, int N)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < N; i++)
-	{
-		dst[i] = src[i];
-	}
-}
-
-
-void dump(double* variables, int nel, int nelr)
-{
-
-
-	{
-		std::ofstream file("density");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;
-	}
-
-
-	{
-		std::ofstream file("momentum");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++)
-		{
-			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << " ";
-			file << std::endl;
-		}
-	}
-
-	{
-		std::ofstream file("density_energy");
-		file << nel << " " << nelr << std::endl;
-		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;
-	}
-
-}
-
-/*
- * Element-based Cell-centered FVM solver functions
- */
-double ff_variable[NVAR];
-double3 ff_fc_momentum_x;
-double3 ff_fc_momentum_y;
-double3 ff_fc_momentum_z;
-double3 ff_fc_density_energy;
-
-
-void initialize_variables(int nelr, double* variables)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];
-	}
-}
-
-inline void compute_flux_contribution(double& density, double3& momentum, double& density_energy, double& pressure, double3& velocity, double3& fc_momentum_x, double3& fc_momentum_y, double3& fc_momentum_z, double3& fc_density_energy)
-{
-	fc_momentum_x.x = velocity.x*momentum.x + pressure;
-	fc_momentum_x.y = velocity.x*momentum.y;
-	fc_momentum_x.z = velocity.x*momentum.z;
-
-	fc_momentum_y.x = fc_momentum_x.y;
-	fc_momentum_y.y = velocity.y*momentum.y + pressure;
-	fc_momentum_y.z = velocity.y*momentum.z;
-
-	fc_momentum_z.x = fc_momentum_x.z;
-	fc_momentum_z.y = fc_momentum_y.z;
-	fc_momentum_z.z = velocity.z*momentum.z + pressure;
-
-	double de_p = density_energy+pressure;
-	fc_density_energy.x = velocity.x*de_p;
-	fc_density_energy.y = velocity.y*de_p;
-	fc_density_energy.z = velocity.z*de_p;
-}
-
-inline void compute_velocity(double& density, double3& momentum, double3& velocity)
-{
-	velocity.x = momentum.x / density;
-	velocity.y = momentum.y / density;
-	velocity.z = momentum.z / density;
-}
-
-inline double compute_speed_sqd(double3& velocity)
-{
-	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;
-}
-
-inline double compute_pressure(double& density, double& density_energy, double& speed_sqd)
-{
-	return (double(GAMMA)-double(1.0))*(density_energy - double(0.5)*density*speed_sqd);
-}
-
-inline double compute_speed_of_sound(double& density, double& pressure)
-{
-	return std::sqrt(double(GAMMA)*pressure/density);
-}
-
-
-
-void compute_step_factor(int nelr, double* variables, double* areas, double* step_factors)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		double density = variables[NVAR*i + VAR_DENSITY];
-
-		double3 momentum;
-		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-
-		double density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];
-		double3 velocity;	   compute_velocity(density, momentum, velocity);
-		double speed_sqd      = compute_speed_sqd(velocity);
-		double pressure       = compute_pressure(density, density_energy, speed_sqd);
-		double speed_of_sound = compute_speed_of_sound(density, pressure);
-
-		// dt = double(0.5) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once
-		step_factors[i] = double(0.5) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));
-	}
-}
-
-
-void compute_flux_contributions(int nelr, double* variables, double* fc_momentum_x, double* fc_momentum_y, double* fc_momentum_z, double* fc_density_energy)
-{
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		double density_i = variables[NVAR*i + VAR_DENSITY];
-		double3 momentum_i;
-		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];
-
-		double3 velocity_i;             				compute_velocity(density_i, momentum_i, velocity_i);
-		double speed_sqd_i                          = compute_speed_sqd(velocity_i);
-		double speed_i                              = sqrtf(speed_sqd_i);
-		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);
-		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);
-		double3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;
-		double3 fc_i_density_energy;	
-		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z, fc_i_density_energy);
-
-		fc_momentum_x[i*NDIM + 0] = fc_i_momentum_x.x;
-		fc_momentum_x[i*NDIM + 1] = fc_i_momentum_x.y;
-		fc_momentum_x[i*NDIM+  2] = fc_i_momentum_x.z;
-
-		fc_momentum_y[i*NDIM+ 0] = fc_i_momentum_y.x;
-		fc_momentum_y[i*NDIM+ 1] = fc_i_momentum_y.y;
-		fc_momentum_y[i*NDIM+ 2] = fc_i_momentum_y.z;
-
-
-		fc_momentum_z[i*NDIM+ 0] = fc_i_momentum_z.x;
-		fc_momentum_z[i*NDIM+ 1] = fc_i_momentum_z.y;
-		fc_momentum_z[i*NDIM+ 2] = fc_i_momentum_z.z;
-
-		fc_density_energy[i*NDIM+ 0] = fc_i_density_energy.x;
-		fc_density_energy[i*NDIM+ 1] = fc_i_density_energy.y;
-		fc_density_energy[i*NDIM+ 2] = fc_i_density_energy.z;
-	}
-
-}
-
-/*
- *
- *
-*/
-
-void compute_flux(int nelr, int* elements_surrounding_elements, double* normals, double* variables, double* fc_momentum_x, double* fc_momentum_y, double* fc_momentum_z, double* fc_density_energy, double* fluxes)
-{
-	const double smoothing_coefficient = double(0.2);
-
-	#pragma omp parallel for default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		int j, nb;
-		double3 normal; double normal_len;
-		double factor;
-
-		double density_i = variables[NVAR*i + VAR_DENSITY];
-		double3 momentum_i;
-		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];
-		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];
-		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];
-
-		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];
-
-		double3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);
-		double speed_sqd_i                          = compute_speed_sqd(velocity_i);
-		double speed_i                              = std::sqrt(speed_sqd_i);
-		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);
-		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);
-		double3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;
-		double3 fc_i_density_energy;
-
-		fc_i_momentum_x.x = fc_momentum_x[i*NDIM + 0];
-		fc_i_momentum_x.y = fc_momentum_x[i*NDIM + 1];
-		fc_i_momentum_x.z = fc_momentum_x[i*NDIM + 2];
-
-		fc_i_momentum_y.x = fc_momentum_y[i*NDIM + 0];
-		fc_i_momentum_y.y = fc_momentum_y[i*NDIM + 1];
-		fc_i_momentum_y.z = fc_momentum_y[i*NDIM + 2];
-
-		fc_i_momentum_z.x = fc_momentum_z[i*NDIM + 0];
-		fc_i_momentum_z.y = fc_momentum_z[i*NDIM + 1];
-		fc_i_momentum_z.z = fc_momentum_z[i*NDIM + 2];
-
-		fc_i_density_energy.x = fc_density_energy[i*NDIM + 0];
-		fc_i_density_energy.y = fc_density_energy[i*NDIM + 1];
-		fc_i_density_energy.z = fc_density_energy[i*NDIM + 2];
-
-		double flux_i_density = double(0.0);
-		double3 flux_i_momentum;
-		flux_i_momentum.x = double(0.0);
-		flux_i_momentum.y = double(0.0);
-		flux_i_momentum.z = double(0.0);
-		double flux_i_density_energy = double(0.0);
-
-		double3 velocity_nb;
-		double density_nb, density_energy_nb;
-		double3 momentum_nb;
-		double3 fc_nb_momentum_x, fc_nb_momentum_y, fc_nb_momentum_z;
-		double3 fc_nb_density_energy;
-		double speed_sqd_nb, speed_of_sound_nb, pressure_nb;
-
-		for(j = 0; j < NNB; j++)
-		{
-			nb = elements_surrounding_elements[i*NNB + j];
-			normal.x = normals[(i*NNB + j)*NDIM + 0];
-			normal.y = normals[(i*NNB + j)*NDIM + 1];
-			normal.z = normals[(i*NNB + j)*NDIM + 2];
-			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
-
-			if(nb >= 0) 	// a legitimate neighbor
-			{
-				density_nb =        variables[nb*NVAR + VAR_DENSITY];
-				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];
-				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];
-				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];
-				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];
-													compute_velocity(density_nb, momentum_nb, velocity_nb);
-				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);
-				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);
-				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);
-
-				fc_nb_momentum_x.x = fc_momentum_x[nb*NDIM + 0];
-				fc_nb_momentum_x.y = fc_momentum_x[nb*NDIM + 1];
-				fc_nb_momentum_x.z = fc_momentum_x[nb*NDIM + 2];
-
-				fc_nb_momentum_y.x = fc_momentum_y[nb*NDIM + 0];
-				fc_nb_momentum_y.y = fc_momentum_y[nb*NDIM + 1];
-				fc_nb_momentum_y.z = fc_momentum_y[nb*NDIM + 2];
-
-				fc_nb_momentum_z.x = fc_momentum_z[nb*NDIM + 0];
-				fc_nb_momentum_z.y = fc_momentum_z[nb*NDIM + 1];
-				fc_nb_momentum_z.z = fc_momentum_z[nb*NDIM + 2];
-
-				fc_nb_density_energy.x = fc_density_energy[nb*NDIM + 0];
-				fc_nb_density_energy.y = fc_density_energy[nb*NDIM + 1];
-
-				// artificial viscosity
-				factor = -normal_len*smoothing_coefficient*double(0.5)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);
-				flux_i_density += factor*(density_i-density_nb);
-				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);
-				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);
-				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);
-				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);
-
-				// accumulate cell-centered fluxes
-				factor = double(0.5)*normal.x;
-				flux_i_density += factor*(momentum_nb.x+momentum_i.x);
-				flux_i_density_energy += factor*(fc_nb_density_energy.x+fc_i_density_energy.x);
-				flux_i_momentum.x += factor*(fc_nb_momentum_x.x+fc_i_momentum_x.x);
-				flux_i_momentum.y += factor*(fc_nb_momentum_y.x+fc_i_momentum_y.x);
-				flux_i_momentum.z += factor*(fc_nb_momentum_z.x+fc_i_momentum_z.x);
-
-				factor = double(0.5)*normal.y;
-				flux_i_density += factor*(momentum_nb.y+momentum_i.y);
-				flux_i_density_energy += factor*(fc_nb_density_energy.y+fc_i_density_energy.y);
-				flux_i_momentum.x += factor*(fc_nb_momentum_x.y+fc_i_momentum_x.y);
-				flux_i_momentum.y += factor*(fc_nb_momentum_y.y+fc_i_momentum_y.y);
-				flux_i_momentum.z += factor*(fc_nb_momentum_z.y+fc_i_momentum_z.y);
-
-				factor = double(0.5)*normal.z;
-				flux_i_density += factor*(momentum_nb.z+momentum_i.z);
-				flux_i_density_energy += factor*(fc_nb_density_energy.z+fc_i_density_energy.z);
-				flux_i_momentum.x += factor*(fc_nb_momentum_x.z+fc_i_momentum_x.z);
-				flux_i_momentum.y += factor*(fc_nb_momentum_y.z+fc_i_momentum_y.z);
-				flux_i_momentum.z += factor*(fc_nb_momentum_z.z+fc_i_momentum_z.z);
-			}
-			else if(nb == -1)	// a wing boundary
-			{
-				flux_i_momentum.x += normal.x*pressure_i;
-				flux_i_momentum.y += normal.y*pressure_i;
-				flux_i_momentum.z += normal.z*pressure_i;
-			}
-			else if(nb == -2) // a far field boundary
-			{
-				factor = double(0.5)*normal.x;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);
-				flux_i_density_energy += factor*(ff_fc_density_energy.x+fc_i_density_energy.x);
-				flux_i_momentum.x += factor*(ff_fc_momentum_x.x + fc_i_momentum_x.x);
-				flux_i_momentum.y += factor*(ff_fc_momentum_y.x + fc_i_momentum_y.x);
-				flux_i_momentum.z += factor*(ff_fc_momentum_z.x + fc_i_momentum_z.x);
-
-				factor = double(0.5)*normal.y;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);
-				flux_i_density_energy += factor*(ff_fc_density_energy.y+fc_i_density_energy.y);
-				flux_i_momentum.x += factor*(ff_fc_momentum_x.y + fc_i_momentum_x.y);
-				flux_i_momentum.y += factor*(ff_fc_momentum_y.y + fc_i_momentum_y.y);
-				flux_i_momentum.z += factor*(ff_fc_momentum_z.y + fc_i_momentum_z.y);
-
-				factor = double(0.5)*normal.z;
-				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);
-				flux_i_density_energy += factor*(ff_fc_density_energy.z+fc_i_density_energy.z);
-				flux_i_momentum.x += factor*(ff_fc_momentum_x.z + fc_i_momentum_x.z);
-				flux_i_momentum.y += factor*(ff_fc_momentum_y.z + fc_i_momentum_y.z);
-				flux_i_momentum.z += factor*(ff_fc_momentum_z.z + fc_i_momentum_z.z);
-
-			}
-		}
-
-		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;
-		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;
-		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;
-		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;
-		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;
-	}
-}
-
-void time_step(int j, int nelr, double* old_variables, double* variables, double* step_factors, double* fluxes)
-{
-	#pragma omp parallel for  default(shared) schedule(static)
-	for(int i = 0; i < nelr; i++)
-	{
-		double factor = step_factors[i]/double(RK+1-j);
-
-		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];
-		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];
-		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];
-		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];
-		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];
-	}
-}
-/*
- * Main function
- */
-int main(int argc, char** argv)
-{
-	if (argc < 2)
-	{
-		std::cout << "specify data file name" << std::endl;
-		return 0;
-	}
-	const char* data_file_name = argv[1];
-
-	// set far field conditions
-	{
-		const double angle_of_attack = double(3.1415926535897931 / 180.0) * double(deg_angle_of_attack);
-
-		ff_variable[VAR_DENSITY] = double(1.4);
-
-		double ff_pressure = double(1.0);
-		double ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);
-		double ff_speed = double(ff_mach)*ff_speed_of_sound;
-
-		double3 ff_velocity;
-		ff_velocity.x = ff_speed*double(cos((double)angle_of_attack));
-		ff_velocity.y = ff_speed*double(sin((double)angle_of_attack));
-		ff_velocity.z = 0.0;
-
-		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;
-		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;
-		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;
-
-		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(double(0.5)*(ff_speed*ff_speed)) + (ff_pressure / double(GAMMA-1.0));
-
-		double3 ff_momentum;
-		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);
-		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);
-		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);
-		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_fc_momentum_x, ff_fc_momentum_y, ff_fc_momentum_z, ff_fc_density_energy);
-	}
-	int nel;
-	int nelr;
-
-	// read in domain geometry
-	double* areas;
-	int* elements_surrounding_elements;
-	double* normals;
-	{
-		std::ifstream file(data_file_name);
-
-		file >> nel;
-		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));
-
-		areas = new double[nelr];
-		elements_surrounding_elements = new int[nelr*NNB];
-		normals = new double[NDIM*NNB*nelr];
-
-		// read in data
-		for(int i = 0; i < nel; i++)
-		{
-			file >> areas[i];
-			for(int j = 0; j < NNB; j++)
-			{
-				file >> elements_surrounding_elements[i*NNB + j];
-				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;
-				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering
-
-				for(int k = 0; k < NDIM; k++)
-				{
-					file >>  normals[(i*NNB + j)*NDIM + k];
-					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];
-				}
-			}
-		}
-
-		// fill in remaining data
-		int last = nel-1;
-		for(int i = nel; i < nelr; i++)
-		{
-			areas[i] = areas[last];
-			for(int j = 0; j < NNB; j++)
-			{
-				// duplicate the last element
-				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];
-				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];
-			}
-		}
-	}
-
-	// Create arrays and set initial conditions
-	double* variables = alloc<double>(nelr*NVAR);
-	initialize_variables(nelr, variables);
-
-	double* old_variables = alloc<double>(nelr*NVAR);
-	double* fluxes = alloc<double>(nelr*NVAR);
-	double* step_factors = alloc<double>(nelr);
-	double* fc_momentum_x = alloc<double>(nelr*NDIM); 
-	double* fc_momentum_y = alloc<double>(nelr*NDIM);
-	double* fc_momentum_z = alloc<double>(nelr*NDIM);
-	double* fc_density_energy = alloc<double>(nelr*NDIM);
-
-	// these need to be computed the first time in order to compute time step
-	std::cout << "Starting..." << std::endl;
-	double start = omp_get_wtime();
-
-	// Begin iterations
-	for(int i = 0; i < iterations; i++)
-	{
-		copy<double>(old_variables, variables, nelr*NVAR);
-
-		// for the first iteration we compute the time step
-		compute_step_factor(nelr, variables, areas, step_factors);
-
-		for(int j = 0; j < RK; j++)
-		{
-			compute_flux_contributions(nelr, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy);
-			compute_flux(nelr, elements_surrounding_elements, normals, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy, fluxes);
-			time_step(j, nelr, old_variables, variables, step_factors, fluxes);
-		}
-	}
-
-	double end = omp_get_wtime();
-	std::cout  << (end-start)  / iterations << " seconds per iteration" << std::endl;
-
-	std::cout << "Saving solution..." << std::endl;
-	dump(variables, nel, nelr);
-	std::cout << "Saved solution..." << std::endl;
-
-
-	std::cout << "Cleaning up..." << std::endl;
-	dealloc<double>(areas);
-	dealloc<int>(elements_surrounding_elements);
-	dealloc<double>(normals);
-
-	dealloc<double>(variables);
-	dealloc<double>(old_variables);
-	dealloc<double>(fluxes);
-	dealloc<double>(step_factors);
-	dealloc<double>(fc_momentum_x); 
-	dealloc<double>(fc_momentum_y);
-	dealloc<double>(fc_momentum_z);
-	dealloc<double>(fc_density_energy);
-	std::cout << "Done..." << std::endl;
-
-	return 0;
-}
diff -ruN rodinia_3.1/openmp/cfd/run rodinia_3.1_new/openmp/cfd/run
--- rodinia_3.1/openmp/cfd/run	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/cfd/run	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-./euler3d_cpu ../../data/cfd/fvcorr.domn.193K
diff -ruN rodinia_3.1/openmp/cfd/run_offload rodinia_3.1_new/openmp/cfd/run_offload
--- rodinia_3.1/openmp/cfd/run_offload	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/cfd/run_offload	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-./euler3d_cpu_offload ../../data/cfd/fvcorr.domn.193K
diff -ruN rodinia_3.1/openmp/heartwall/define.c rodinia_3.1_new/openmp/heartwall/define.c
--- rodinia_3.1/openmp/heartwall/define.c	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/heartwall/define.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,325 +0,0 @@
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//	DEFINE / INCLUDE
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-
-#define fp float
-#define ENDO_POINTS 20
-#define EPI_POINTS 31
-#define ALL_POINTS 51
-
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//	PUBLIC_STRUCT
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-
-typedef struct public_struct{
-
-	//======================================================================================================================================================
-	//	WHAT USED TO BE INPUTS FROM MATLAB
-	//======================================================================================================================================================
-
-	int tSize;
-	int sSize;
-	int maxMove;
-	fp alpha;
-
-	int endoPoints;
-	int d_endo_mem;
-	int* d_endoRow;
-	int* d_endoCol;
-	int* d_tEndoRowLoc;
-	int* d_tEndoColLoc;
-	fp* d_endoT;
-
-	int epiPoints;
-	int d_epi_mem;
-	int* d_epiRow;
-	int* d_epiCol;
-	int* d_tEpiRowLoc;
-	int* d_tEpiColLoc;
-	fp* d_epiT;
-
-	int allPoints;
-
-	//======================================================================================================================================================
-	//	FRAME
-	//======================================================================================================================================================
-
-	avi_t* d_frames;
-	int frames;
-	int frame_no;
-	fp* d_frame;
-	int frame_rows;
-	int frame_cols;
-	int frame_elem;
-	int frame_mem;
-
-	//======================================================================================================================================================
-	// 	INPUT 2
-	//======================================================================================================================================================
-
-	int in2_rows;
-	int in2_cols;
-	int in2_elem;
-	int in2_mem;
-
-	//======================================================================================================================================================
-	//	INPUT
-	//======================================================================================================================================================
-
-	int in_mod_rows;
-	int in_mod_cols;
-	int in_mod_elem;
-	int in_mod_mem;
-
-	//======================================================================================================================================================
-	//	CONVOLUTION
-	//======================================================================================================================================================
-
-	int ioffset;
-	int joffset;
-
-	int conv_rows;
-	int conv_cols;
-	int conv_elem;
-	int conv_mem;
-
-	//======================================================================================================================================================
-	//	CUMULATIVE SUM 1
-	//======================================================================================================================================================
-
-	//====================================================================================================
-	//	PAD ARRAY
-	//====================================================================================================
-	//====================================================================================================
-	//	VERTICAL CUMULATIVE SUM
-	//====================================================================================================
-
-	int in2_pad_add_rows;
-	int in2_pad_add_cols;
-
-	int in2_pad_rows;
-	int in2_pad_cols;
-	int in2_pad_elem;
-	int in2_pad_mem;
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION, HORIZONTAL CUMULATIVE SUM
-	//====================================================================================================
-	//====================================================================================================
-	//	HORIZONTAL CUMULATIVE SUM
-	//====================================================================================================
-
-	int in2_pad_cumv_sel_rowlow;
-	int in2_pad_cumv_sel_rowhig;
-	int in2_pad_cumv_sel_collow;
-	int in2_pad_cumv_sel_colhig;
-
-	int in2_pad_cumv_sel2_rowlow;
-	int in2_pad_cumv_sel2_rowhig;
-	int in2_pad_cumv_sel2_collow;
-	int in2_pad_cumv_sel2_colhig;
-
-	int in2_sub_rows;
-	int in2_sub_cols;
-	int in2_sub_elem;
-	int in2_sub_mem;
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR
-	//====================================================================================================
-
-	int in2_sub_cumh_sel_rowlow;
-	int in2_sub_cumh_sel_rowhig;
-	int in2_sub_cumh_sel_collow;
-	int in2_sub_cumh_sel_colhig;
-
-	int in2_sub_cumh_sel2_rowlow;
-	int in2_sub_cumh_sel2_rowhig;
-	int in2_sub_cumh_sel2_collow;
-	int in2_sub_cumh_sel2_colhig;
-
-	int in2_sub2_sqr_rows;
-	int in2_sub2_sqr_cols;
-	int in2_sub2_sqr_elem;
-	int in2_sub2_sqr_mem;
-
-	//======================================================================================================================================================
-	//	CUMULATIVE SUM 2
-	//======================================================================================================================================================
-
-	//====================================================================================================
-	//	PAD ARRAY
-	//====================================================================================================
-	//====================================================================================================
-	//	VERTICAL CUMULATIVE SUM
-	//====================================================================================================
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION
-	//====================================================================================================
-	//====================================================================================================
-	//	HORIZONTAL CUMULATIVE SUM
-	//====================================================================================================
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION
-	//====================================================================================================
-
-	//======================================================================================================================================================
-	//	TEMPLATE MASK CREATE
-	//======================================================================================================================================================
-
-	int tMask_rows;
-	int tMask_cols;
-	int tMask_elem;
-	int tMask_mem;
-
-	//======================================================================================================================================================
-	//	POINT MASK INITIALIZE
-	//======================================================================================================================================================
-
-	int mask_rows;
-	int mask_cols;
-	int mask_elem;
-	int mask_mem;
-
-	//======================================================================================================================================================
-	//	MASK CONVOLUTION
-	//======================================================================================================================================================
-
-	int mask_conv_rows;
-	int mask_conv_cols;
-	int mask_conv_elem;
-	int mask_conv_mem;
-	int mask_conv_ioffset;
-	int mask_conv_joffset;
-
-}public_struct;
-
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//	PRIVATE_STRUCT
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-
-typedef struct private_struct{
-
-	//======================================================================================================================================================
-	//	POINT-SPECIFIC
-	//======================================================================================================================================================
-
-	int point_no;
-	int in_pointer;
-
-	int* d_Row;
-	int* d_Col;
-	int* d_tRowLoc;
-	int* d_tColLoc;
-	fp* d_T;
-
-	//======================================================================================================================================================
-	// 	INPUT 2
-	//======================================================================================================================================================
-
-	fp* d_in2;
-	fp* d_in2_sqr;
-
-	//======================================================================================================================================================
-	//	INPUT
-	//======================================================================================================================================================
-
-	fp* d_in_mod;
-	fp* d_in_sqr;
-
-	//======================================================================================================================================================
-	//	CONVOLUTION
-	//======================================================================================================================================================
-
-	fp* d_conv;
-
-	//======================================================================================================================================================
-	//	CUMULATIVE SUM 1
-	//======================================================================================================================================================
-
-	//====================================================================================================
-	//	PAD ARRAY
-	//====================================================================================================
-	//====================================================================================================
-	//	VERTICAL CUMULATIVE SUM
-	//====================================================================================================
-
-	fp* d_in2_pad;
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION, HORIZONTAL CUMULATIVE SUM
-	//====================================================================================================
-	//====================================================================================================
-	//	HORIZONTAL CUMULATIVE SUM
-	//====================================================================================================
-
-	fp* d_in2_sub;
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR
-	//====================================================================================================
-
-	fp* d_in2_sub2_sqr;
-
-	//======================================================================================================================================================
-	//	CUMULATIVE SUM 2
-	//======================================================================================================================================================
-
-	//====================================================================================================
-	//	PAD ARRAY
-	//====================================================================================================
-	//====================================================================================================
-	//	VERTICAL CUMULATIVE SUM
-	//====================================================================================================
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION
-	//====================================================================================================
-	//====================================================================================================
-	//	HORIZONTAL CUMULATIVE SUM
-	//====================================================================================================
-
-	//====================================================================================================
-	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION
-	//====================================================================================================
-
-	//======================================================================================================================================================
-	//	TEMPLATE MASK CREATE
-	//======================================================================================================================================================
-
-	fp* d_tMask;
-
-	//======================================================================================================================================================
-	//	POINT MASK INITIALIZE
-	//======================================================================================================================================================
-
-	//======================================================================================================================================================
-	//	MASK CONVOLUTION
-	//======================================================================================================================================================
-
-	fp* d_mask_conv;
-
-	//======================================================================================================================================================
-	//	SUM
-	//======================================================================================================================================================
-
-	fp* in_partial_sum;
-	fp* in_sqr_partial_sum;
-	fp* par_max_val;
-	int* par_max_coo;
-
-} private_struct;
-
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//	END OF STRUCTURE
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
diff -ruN rodinia_3.1/openmp/heartwall/kernel.c rodinia_3.1_new/openmp/heartwall/kernel.c
--- rodinia_3.1/openmp/heartwall/kernel.c	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/heartwall/kernel.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,657 +0,0 @@
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//	KERNEL FUNCTION
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-
-void kernel(public_struct public,
-				private_struct private){
-
-	//======================================================================================================================================================
-	//	COMMON VARIABLES
-	//======================================================================================================================================================
-
-	int ei_new;
-	fp* d_in;
-	int rot_row;
-	int rot_col;
-	int in2_rowlow;
-	int in2_collow;
-	int ic;
-	int jc;
-	int jp1;
-	int ja1, ja2;
-	int ip1;
-	int ia1, ia2;
-	int ja, jb;
-	int ia, ib;
-	fp s;
-	int i;
-	int j;
-	int row;
-	int col;
-	int ori_row;
-	int ori_col;
-	int position;
-	fp sum;
-	int pos_ori;
-	fp temp;
-	fp temp2;
-	int location;
-	int cent;
-	int tMask_row; 
-	int tMask_col;
-	fp largest_value_current = 0;
-	fp largest_value = 0;
-	int largest_coordinate_current = 0;
-	int largest_coordinate = 0;
-	fp fin_max_val = 0;
-	int fin_max_coo = 0;
-	int largest_row;
-	int largest_col;
-	int offset_row;
-	int offset_col;
-	fp in_final_sum;
-	fp in_sqr_final_sum;
-	fp mean;
-	fp mean_sqr;
-	fp variance;
-	fp deviation;
-	fp denomT;
-	int pointer;
-	int ori_pointer;
-	int loc_pointer;
-	int ei_mod;
-
-	//======================================================================================================================================================
-	//	GENERATE TEMPLATE
-	//======================================================================================================================================================
-
-	// generate templates based on the first frame only
-	if(public.frame_no == 0){
-
-		// update temporary row/col coordinates
-		pointer = private.point_no*public.frames+public.frame_no;
-		private.d_tRowLoc[pointer] = private.d_Row[private.point_no];
-		private.d_tColLoc[pointer] = private.d_Col[private.point_no];
-
-		// pointers to: current frame, template for current point
-		d_in = &private.d_T[private.in_pointer];
-
-		// update template, limit the number of working threads to the size of template
-		for(col=0; col<public.in_mod_cols; col++){
-			for(row=0; row<public.in_mod_rows; row++){
-
-				// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)
-				ori_row = private.d_Row[private.point_no] - 25 + row - 1;
-				ori_col = private.d_Col[private.point_no] - 25 + col - 1;
-				ori_pointer = ori_col*public.frame_rows+ori_row;
-
-				// update template
-				d_in[col*public.in_mod_rows+row] = public.d_frame[ori_pointer];
-
-			}
-		}
-
-	}
-
-	//======================================================================================================================================================
-	//	PROCESS POINTS
-	//======================================================================================================================================================
-
-	// process points in all frames except for the first one
-	if(public.frame_no != 0){
-
-		//====================================================================================================
-		//	INPUTS
-		//====================================================================================================
-
-		//==================================================
-		//	1) SETUP POINTER TO POINT TO CURRENT FRAME FROM BATCH
-		//	2) SELECT INPUT 2 (SAMPLE AROUND POINT) FROM FRAME			SAVE IN d_in2			(NOT LINEAR IN MEMORY, SO NEED TO SAVE OUTPUT FOR LATER EASY USE)
-		//	3) SQUARE INPUT 2									SAVE IN d_in2_sqr
-		//==================================================
-
-		// pointers and variables
-		in2_rowlow = private.d_Row[private.point_no] - public.sSize;							// (1 to n+1)
-		in2_collow = private.d_Col[private.point_no] - public.sSize;
-
-		// work
-		for(col=0; col<public.in2_cols; col++){
-			for(row=0; row<public.in2_rows; row++){
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + in2_rowlow - 1;
-			ori_col = col + in2_collow - 1;
-			temp = public.d_frame[ori_col*public.frame_rows+ori_row];
-			private.d_in2[col*public.in2_rows+row] = temp;
-			private.d_in2_sqr[col*public.in2_rows+row] = temp*temp;
-
-			}
-		}
-
-		//==================================================
-		//	1) GET POINTER TO INPUT 1 (TEMPLATE FOR THIS POINT) IN TEMPLATE ARRAY				(LINEAR IN MEMORY, SO DONT NEED TO SAVE, JUST GET POINTER)
-		//	2) ROTATE INPUT 1									SAVE IN d_in_mod
-		//	3) SQUARE INPUT 1									SAVE IN d_in_sqr
-		//==================================================
-
-		// variables
-		d_in = &private.d_T[private.in_pointer];
-
-		// work
-		for(col=0; col<public.in_mod_cols; col++){
-			for(row=0; row<public.in_mod_rows; row++){
-
-			// rotated coordinates
-			rot_row = (public.in_mod_rows-1) - row;
-			rot_col = (public.in_mod_rows-1) - col;
-			pointer = rot_col*public.in_mod_rows+rot_row;
-
-			// execution
-			temp = d_in[pointer];
-			private.d_in_mod[col*public.in_mod_rows+row] = temp;
-			private.d_in_sqr[pointer] = temp * temp;
-
-			}
-		}
-
-		//==================================================
-		//	1) GET SUM OF INPUT 1
-		//	2) GET SUM OF INPUT 1 SQUARED
-		//==================================================
-
-		in_final_sum = 0;
-		for(i = 0; i<public.in_mod_elem; i++){
-			in_final_sum = in_final_sum + d_in[i];
-		}
-
-		in_sqr_final_sum = 0;
-		for(i = 0; i<public.in_mod_elem; i++){
-			in_sqr_final_sum = in_sqr_final_sum + private.d_in_sqr[i];
-		}
-
-		//==================================================
-		//	3) DO STATISTICAL CALCULATIONS
-		//	4) GET DENOMINATOR T
-		//==================================================
-
-		mean = in_final_sum / public.in_mod_elem;													// gets mean (average) value of element in ROI
-		mean_sqr = mean * mean;
-		variance  = (in_sqr_final_sum / public.in_mod_elem) - mean_sqr;							// gets variance of ROI
-		deviation = sqrt(variance);																// gets standard deviation of ROI
-
-		denomT = sqrt((fp)(public.in_mod_elem-1))*deviation;
-
-		//====================================================================================================
-		//	1) CONVOLVE INPUT 2 WITH ROTATED INPUT 1					SAVE IN d_conv
-		//====================================================================================================
-
-		// work
-		for(col=1; col<=public.conv_cols; col++){
-
-			// column setup
-			j = col + public.joffset;
-			jp1 = j + 1;
-			if(public.in2_cols < jp1){
-				ja1 = jp1 - public.in2_cols;
-			}
-			else{
-				ja1 = 1;
-			}
-			if(public.in_mod_cols < j){
-				ja2 = public.in_mod_cols;
-			}
-			else{
-				ja2 = j;
-			}
-
-			for(row=1; row<=public.conv_rows; row++){
-
-				// row range setup
-				i = row + public.ioffset;
-				ip1 = i + 1;
-				
-				if(public.in2_rows < ip1){
-					ia1 = ip1 - public.in2_rows;
-				}
-				else{
-					ia1 = 1;
-				}
-				if(public.in_mod_rows < i){
-					ia2 = public.in_mod_rows;
-				}
-				else{
-					ia2 = i;
-				}
-
-				s = 0;
-
-				// getting data
-				for(ja=ja1; ja<=ja2; ja++){
-					jb = jp1 - ja;
-					for(ia=ia1; ia<=ia2; ia++){
-						ib = ip1 - ia;
-						s = s + private.d_in_mod[public.in_mod_rows*(ja-1)+ia-1] * private.d_in2[public.in2_rows*(jb-1)+ib-1];
-					}
-				}
-
-				private.d_conv[(col-1)*public.conv_rows+(row-1)] = s;
-
-		}
-	}
-		//====================================================================================================
-		//	LOCAL SUM 1
-		//====================================================================================================
-
-		//==================================================
-		//	1) PADD ARRAY										SAVE IN d_in2_pad
-		//==================================================
-
-		// work
-		for(col=0; col<public.in2_pad_cols; col++){
-			for(row=0; row<public.in2_pad_rows; row++){
-
-			// execution
-			if(	row > (public.in2_pad_add_rows-1) &&														// do if has numbers in original array
-				row < (public.in2_pad_add_rows+public.in2_rows) && 
-				col > (public.in2_pad_add_cols-1) && 
-				col < (public.in2_pad_add_cols+public.in2_cols)){
-				ori_row = row - public.in2_pad_add_rows;
-				ori_col = col - public.in2_pad_add_cols;
-				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2[ori_col*public.in2_rows+ori_row];
-			}
-			else{																			// do if otherwise
-				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;
-			}
-
-			}
-		}
-
-		//==================================================
-		//	1) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad
-		//==================================================
-
-		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){
-
-			// figure out column position
-			pos_ori = ei_new*public.in2_pad_rows;
-
-			// loop through all rows
-			sum = 0;
-			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){
-				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;
-				sum = private.d_in2_pad[position];
-			}
-
-		}
-
-		//==================================================
-		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM
-		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM
-		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub
-		//==================================================
-
-		// work
-		for(col=0; col<public.in2_sub_cols; col++){
-			for(row=0; row<public.in2_sub_rows; row++){
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;
-			ori_col = col + public.in2_pad_cumv_sel_collow - 1;
-			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;
-			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;
-			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
-
-			// subtraction
-			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;
-
-			}
-		}
-
-		//==================================================
-		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub
-		//==================================================
-
-		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){
-
-			// figure out row position
-			pos_ori = ei_new;
-
-			// loop through all rows
-			sum = 0;
-			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){
-				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;
-				sum = private.d_in2_sub[position];
-			}
-
-		}
-
-		//==================================================
-		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM
-		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM
-		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 1
-		//	4) GET CUMULATIVE SUM 1 SQUARED						SAVE IN d_in2_sub2_sqr
-		//	5) GET NUMERATOR									SAVE IN d_conv
-		//==================================================
-
-		// work
-		for(col=0; col<public.in2_sub2_sqr_cols; col++){
-			for(row=0; row<public.in2_sub2_sqr_rows; row++){
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;
-			ori_col = col + public.in2_sub_cumh_sel_collow - 1;
-			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;
-			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;
-			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
-			
-			// subtraction
-			temp2 = temp - temp2;
-
-			// squaring
-			private.d_in2_sub2_sqr[col*public.in2_sub2_sqr_rows+row] = temp2 * temp2; 
-
-			// numerator
-			private.d_conv[col*public.in2_sub2_sqr_rows+row] = private.d_conv[col*public.in2_sub2_sqr_rows+row] - temp2 * in_final_sum / public.in_mod_elem;
-
-			}
-		}
-
-		//====================================================================================================
-		//	LOCAL SUM 2
-		//====================================================================================================
-
-		//==================================================
-		//	1) PAD ARRAY										SAVE IN d_in2_pad
-		//==================================================
-
-		// work
-		for(col=0; col<public.in2_pad_cols; col++){
-			for(row=0; row<public.in2_pad_rows; row++){
-
-			// execution
-			if(	row > (public.in2_pad_add_rows-1) &&													// do if has numbers in original array
-				row < (public.in2_pad_add_rows+public.in2_rows) && 
-				col > (public.in2_pad_add_cols-1) && 
-				col < (public.in2_pad_add_cols+public.in2_cols)){
-				ori_row = row - public.in2_pad_add_rows;
-				ori_col = col - public.in2_pad_add_cols;
-				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2_sqr[ori_col*public.in2_rows+ori_row];
-			}
-			else{																							// do if otherwise
-				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;
-			}
-
-			}
-		}
-
-		//==================================================
-		//	2) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad
-		//==================================================
-
-		//work
-		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){
-
-			// figure out column position
-			pos_ori = ei_new*public.in2_pad_rows;
-
-			// loop through all rows
-			sum = 0;
-			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){
-				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;
-				sum = private.d_in2_pad[position];
-			}
-
-		}
-
-		//==================================================
-		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM
-		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM
-		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub
-		//==================================================
-
-		// work
-		for(col=0; col<public.in2_sub_cols; col++){
-			for(row=0; row<public.in2_sub_rows; row++){
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;
-			ori_col = col + public.in2_pad_cumv_sel_collow - 1;
-			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;
-			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;
-			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
-
-			// subtract
-			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;
-
-			}
-		}
-
-		//==================================================
-		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub
-		//==================================================
-
-		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){
-
-			// figure out row position
-			pos_ori = ei_new;
-
-			// loop through all rows
-			sum = 0;
-			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){
-				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;
-				sum = private.d_in2_sub[position];
-			}
-
-		}
-
-		//==================================================
-		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM
-		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM
-		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 2
-		//	4) GET DIFFERENTIAL LOCAL SUM
-		//	5) GET DENOMINATOR A
-		//	6) GET DENOMINATOR
-		//	7) DIVIDE NUMBERATOR BY DENOMINATOR TO GET CORRELATION	SAVE IN d_conv
-		//==================================================
-
-		// work
-		for(col=0; col<public.conv_cols; col++){
-			for(row=0; row<public.conv_rows; row++){
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;
-			ori_col = col + public.in2_sub_cumh_sel_collow - 1;
-			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
-
-			// figure out corresponding location in old matrix and copy values to new matrix
-			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;
-			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;
-			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
-
-			// subtract
-			temp2 = temp - temp2;
-
-			// diff_local_sums
-			temp2 = temp2 - (private.d_in2_sub2_sqr[col*public.conv_rows+row] / public.in_mod_elem);
-
-			// denominator A
-			if(temp2 < 0){
-				temp2 = 0;
-			}
-			temp2 = sqrt(temp2);
-
-			// denominator
-			temp2 = denomT * temp2;
-			
-			// correlation
-			private.d_conv[col*public.conv_rows+row] = private.d_conv[col*public.conv_rows+row] / temp2;
-
-			}
-		}
-
-		//====================================================================================================
-		//	TEMPLATE MASK CREATE
-		//====================================================================================================
-
-		// parameters
-		cent = public.sSize + public.tSize + 1;
-		pointer = public.frame_no-1+private.point_no*public.frames;
-		tMask_row = cent + private.d_tRowLoc[pointer] - private.d_Row[private.point_no] - 1;
-		tMask_col = cent + private.d_tColLoc[pointer] - private.d_Col[private.point_no] - 1;
-
-		//work
-		for(ei_new = 0; ei_new < public.tMask_elem; ei_new++){
-			private.d_tMask[ei_new] = 0;
-		}
-		private.d_tMask[tMask_col*public.tMask_rows + tMask_row] = 1;
-
-
-		//====================================================================================================
-		//	1) MASK CONVOLUTION
-		//	2) MULTIPLICATION
-		//====================================================================================================
-
-		// work
-		// for(col=1; col<=public.conv_cols; col++){
-		for(col=1; col<=public.mask_conv_cols; col++){
-
-			// col setup
-			j = col + public.mask_conv_joffset;
-			jp1 = j + 1;
-			if(public.mask_cols < jp1){
-				ja1 = jp1 - public.mask_cols;
-			}
-			else{
-				ja1 = 1;
-			}
-			if(public.tMask_cols < j){
-				ja2 = public.tMask_cols;
-			}
-			else{
-				ja2 = j;
-			}
-
-			// for(row=1; row<=public.conv_rows; row++){
-			for(row=1; row<=public.mask_conv_rows; row++){
-
-				// row setup
-				i = row + public.mask_conv_ioffset;
-				ip1 = i + 1;
-				
-				if(public.mask_rows < ip1){
-					ia1 = ip1 - public.mask_rows;
-				}
-				else{
-					ia1 = 1;
-				}
-				if(public.tMask_rows < i){
-					ia2 = public.tMask_rows;
-				}
-				else{
-					ia2 = i;
-				}
-
-				s = 0;
-
-				// get data
-				for(ja=ja1; ja<=ja2; ja++){
-					jb = jp1 - ja;
-					for(ia=ia1; ia<=ia2; ia++){
-						ib = ip1 - ia;
-						s = s + private.d_tMask[public.tMask_rows*(ja-1)+ia-1] * 1;
-					}
-				}
-
-				private.d_mask_conv[(col-1)*public.conv_rows+(row-1)] = private.d_conv[(col-1)*public.conv_rows+(row-1)] * s;
-
-			}
-
-		}
-
-		//====================================================================================================
-		//	MAXIMUM VALUE
-		//====================================================================================================
-
-		//==================================================
-		//	SEARCH
-		//==================================================
-
-		fin_max_val = 0;
-		fin_max_coo = 0;
-		for(i=0; i<public.mask_conv_elem; i++){
-			if(private.d_mask_conv[i]>fin_max_val){
-				fin_max_val = private.d_mask_conv[i];
-				fin_max_coo = i;
-			}
-		}
-
-		//==================================================
-		//	OFFSET
-		//==================================================
-
-		// convert coordinate to row/col form
-		largest_row = (fin_max_coo+1) % public.mask_conv_rows - 1;											// (0-n) row
-		largest_col = (fin_max_coo+1) / public.mask_conv_rows;												// (0-n) column
-		if((fin_max_coo+1) % public.mask_conv_rows == 0){
-			largest_row = public.mask_conv_rows - 1;
-			largest_col = largest_col - 1;
-		}
-
-		// calculate offset
-		largest_row = largest_row + 1;																	// compensate to match MATLAB format (1-n)
-		largest_col = largest_col + 1;																	// compensate to match MATLAB format (1-n)
-		offset_row = largest_row - public.in_mod_rows - (public.sSize - public.tSize);
-		offset_col = largest_col - public.in_mod_cols - (public.sSize - public.tSize);
-		pointer = private.point_no*public.frames+public.frame_no;
-		private.d_tRowLoc[pointer] = private.d_Row[private.point_no] + offset_row;
-		private.d_tColLoc[pointer] = private.d_Col[private.point_no] + offset_col;
-
-	}
-
-	//======================================================================================================================================================
-	//	COORDINATE AND TEMPLATE UPDATE
-	//======================================================================================================================================================
-
-	// if the last frame in the bath, update template
-	if(public.frame_no != 0 && (public.frame_no)%10 == 0){
-
-		// update coordinate
-		loc_pointer = private.point_no*public.frames+public.frame_no;
-		private.d_Row[private.point_no] = private.d_tRowLoc[loc_pointer];
-		private.d_Col[private.point_no] = private.d_tColLoc[loc_pointer];
-
-		// update template, limit the number of working threads to the size of template
-		for(col=0; col<public.in_mod_cols; col++){
-			for(row=0; row<public.in_mod_rows; row++){
-
-			// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)
-			ori_row = private.d_Row[private.point_no] - 25 + row - 1;
-			ori_col = private.d_Col[private.point_no] - 25 + col - 1;
-			ori_pointer = ori_col*public.frame_rows+ori_row;
-
-			// update template
-			d_in[col*public.in_mod_rows+row] = public.alpha*d_in[col*public.in_mod_rows+row] + (1.00-public.alpha)*public.d_frame[ori_pointer];
-
-			}
-		}
-
-	}
-
-}
-
-	//===============================================================================================================================================================================================================
-	//===============================================================================================================================================================================================================
-	//	END OF FUNCTION
-	//===============================================================================================================================================================================================================
-	//===============================================================================================================================================================================================================
diff -ruN rodinia_3.1/openmp/heartwall/main.c rodinia_3.1_new/openmp/heartwall/main.c
--- rodinia_3.1/openmp/heartwall/main.c	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/heartwall/main.c	2024-08-29 14:50:13.867123554 -0700
@@ -12,9 +12,990 @@
 #include <avilib.h>
 #include <avimod.h>
 #include <omp.h>
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//	DEFINE / INCLUDE
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+#define fp float
+#define ENDO_POINTS 20
+#define EPI_POINTS 31
+#define ALL_POINTS 51
+
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//	PUBLIC_STRUCT
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+typedef struct public_struct{
+
+	//======================================================================================================================================================
+	//	WHAT USED TO BE INPUTS FROM MATLAB
+	//======================================================================================================================================================
+
+	int tSize;
+	int sSize;
+	int maxMove;
+	fp alpha;
+
+	int endoPoints;
+	int d_endo_mem;
+	int* d_endoRow;
+	int* d_endoCol;
+	int* d_tEndoRowLoc;
+	int* d_tEndoColLoc;
+	fp* d_endoT;
+
+	int epiPoints;
+	int d_epi_mem;
+	int* d_epiRow;
+	int* d_epiCol;
+	int* d_tEpiRowLoc;
+	int* d_tEpiColLoc;
+	fp* d_epiT;
+
+	int allPoints;
+
+	//======================================================================================================================================================
+	//	FRAME
+	//======================================================================================================================================================
+
+	avi_t* d_frames;
+	int frames;
+	int frame_no;
+	fp* d_frame;
+	int frame_rows;
+	int frame_cols;
+	int frame_elem;
+	int frame_mem;
+
+	//======================================================================================================================================================
+	// 	INPUT 2
+	//======================================================================================================================================================
+
+	int in2_rows;
+	int in2_cols;
+	int in2_elem;
+	int in2_mem;
+
+	//======================================================================================================================================================
+	//	INPUT
+	//======================================================================================================================================================
+
+	int in_mod_rows;
+	int in_mod_cols;
+	int in_mod_elem;
+	int in_mod_mem;
+
+	//======================================================================================================================================================
+	//	CONVOLUTION
+	//======================================================================================================================================================
+
+	int ioffset;
+	int joffset;
+
+	int conv_rows;
+	int conv_cols;
+	int conv_elem;
+	int conv_mem;
+
+	//======================================================================================================================================================
+	//	CUMULATIVE SUM 1
+	//======================================================================================================================================================
+
+	//====================================================================================================
+	//	PAD ARRAY
+	//====================================================================================================
+	//====================================================================================================
+	//	VERTICAL CUMULATIVE SUM
+	//====================================================================================================
+
+	int in2_pad_add_rows;
+	int in2_pad_add_cols;
+
+	int in2_pad_rows;
+	int in2_pad_cols;
+	int in2_pad_elem;
+	int in2_pad_mem;
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION, HORIZONTAL CUMULATIVE SUM
+	//====================================================================================================
+	//====================================================================================================
+	//	HORIZONTAL CUMULATIVE SUM
+	//====================================================================================================
+
+	int in2_pad_cumv_sel_rowlow;
+	int in2_pad_cumv_sel_rowhig;
+	int in2_pad_cumv_sel_collow;
+	int in2_pad_cumv_sel_colhig;
+
+	int in2_pad_cumv_sel2_rowlow;
+	int in2_pad_cumv_sel2_rowhig;
+	int in2_pad_cumv_sel2_collow;
+	int in2_pad_cumv_sel2_colhig;
+
+	int in2_sub_rows;
+	int in2_sub_cols;
+	int in2_sub_elem;
+	int in2_sub_mem;
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR
+	//====================================================================================================
+
+	int in2_sub_cumh_sel_rowlow;
+	int in2_sub_cumh_sel_rowhig;
+	int in2_sub_cumh_sel_collow;
+	int in2_sub_cumh_sel_colhig;
+
+	int in2_sub_cumh_sel2_rowlow;
+	int in2_sub_cumh_sel2_rowhig;
+	int in2_sub_cumh_sel2_collow;
+	int in2_sub_cumh_sel2_colhig;
+
+	int in2_sub2_sqr_rows;
+	int in2_sub2_sqr_cols;
+	int in2_sub2_sqr_elem;
+	int in2_sub2_sqr_mem;
+
+	//======================================================================================================================================================
+	//	CUMULATIVE SUM 2
+	//======================================================================================================================================================
+
+	//====================================================================================================
+	//	PAD ARRAY
+	//====================================================================================================
+	//====================================================================================================
+	//	VERTICAL CUMULATIVE SUM
+	//====================================================================================================
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION
+	//====================================================================================================
+	//====================================================================================================
+	//	HORIZONTAL CUMULATIVE SUM
+	//====================================================================================================
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION
+	//====================================================================================================
+
+	//======================================================================================================================================================
+	//	TEMPLATE MASK CREATE
+	//======================================================================================================================================================
+
+	int tMask_rows;
+	int tMask_cols;
+	int tMask_elem;
+	int tMask_mem;
+
+	//======================================================================================================================================================
+	//	POINT MASK INITIALIZE
+	//======================================================================================================================================================
+
+	int mask_rows;
+	int mask_cols;
+	int mask_elem;
+	int mask_mem;
+
+	//======================================================================================================================================================
+	//	MASK CONVOLUTION
+	//======================================================================================================================================================
+
+	int mask_conv_rows;
+	int mask_conv_cols;
+	int mask_conv_elem;
+	int mask_conv_mem;
+	int mask_conv_ioffset;
+	int mask_conv_joffset;
+
+}public_struct;
+
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//	PRIVATE_STRUCT
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+typedef struct private_struct{
+
+	//======================================================================================================================================================
+	//	POINT-SPECIFIC
+	//======================================================================================================================================================
+
+	int point_no;
+	int in_pointer;
+
+	int* d_Row;
+	int* d_Col;
+	int* d_tRowLoc;
+	int* d_tColLoc;
+	fp* d_T;
+
+	//======================================================================================================================================================
+	// 	INPUT 2
+	//======================================================================================================================================================
+
+	fp* d_in2;
+	fp* d_in2_sqr;
+
+	//======================================================================================================================================================
+	//	INPUT
+	//======================================================================================================================================================
+
+	fp* d_in_mod;
+	fp* d_in_sqr;
+
+	//======================================================================================================================================================
+	//	CONVOLUTION
+	//======================================================================================================================================================
+
+	fp* d_conv;
+
+	//======================================================================================================================================================
+	//	CUMULATIVE SUM 1
+	//======================================================================================================================================================
+
+	//====================================================================================================
+	//	PAD ARRAY
+	//====================================================================================================
+	//====================================================================================================
+	//	VERTICAL CUMULATIVE SUM
+	//====================================================================================================
+
+	fp* d_in2_pad;
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION, HORIZONTAL CUMULATIVE SUM
+	//====================================================================================================
+	//====================================================================================================
+	//	HORIZONTAL CUMULATIVE SUM
+	//====================================================================================================
+
+	fp* d_in2_sub;
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR
+	//====================================================================================================
+
+	fp* d_in2_sub2_sqr;
+
+	//======================================================================================================================================================
+	//	CUMULATIVE SUM 2
+	//======================================================================================================================================================
+
+	//====================================================================================================
+	//	PAD ARRAY
+	//====================================================================================================
+	//====================================================================================================
+	//	VERTICAL CUMULATIVE SUM
+	//====================================================================================================
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION
+	//====================================================================================================
+	//====================================================================================================
+	//	HORIZONTAL CUMULATIVE SUM
+	//====================================================================================================
+
+	//====================================================================================================
+	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION
+	//====================================================================================================
+
+	//======================================================================================================================================================
+	//	TEMPLATE MASK CREATE
+	//======================================================================================================================================================
+
+	fp* d_tMask;
+
+	//======================================================================================================================================================
+	//	POINT MASK INITIALIZE
+	//======================================================================================================================================================
+
+	//======================================================================================================================================================
+	//	MASK CONVOLUTION
+	//======================================================================================================================================================
+
+	fp* d_mask_conv;
+
+	//======================================================================================================================================================
+	//	SUM
+	//======================================================================================================================================================
+
+	fp* in_partial_sum;
+	fp* in_sqr_partial_sum;
+	fp* par_max_val;
+	int* par_max_coo;
+
+} private_struct;
+
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//	END OF STRUCTURE
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//	KERNEL FUNCTION
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+void kernel(public_struct public,
+				private_struct private){
+
+	//======================================================================================================================================================
+	//	COMMON VARIABLES
+	//======================================================================================================================================================
+
+	int ei_new;
+	fp* d_in;
+	int rot_row;
+	int rot_col;
+	int in2_rowlow;
+	int in2_collow;
+	int ic;
+	int jc;
+	int jp1;
+	int ja1, ja2;
+	int ip1;
+	int ia1, ia2;
+	int ja, jb;
+	int ia, ib;
+	fp s;
+	int i;
+	int j;
+	int row;
+	int col;
+	int ori_row;
+	int ori_col;
+	int position;
+	fp sum;
+	int pos_ori;
+	fp temp;
+	fp temp2;
+	int location;
+	int cent;
+	int tMask_row; 
+	int tMask_col;
+	fp largest_value_current = 0;
+	fp largest_value = 0;
+	int largest_coordinate_current = 0;
+	int largest_coordinate = 0;
+	fp fin_max_val = 0;
+	int fin_max_coo = 0;
+	int largest_row;
+	int largest_col;
+	int offset_row;
+	int offset_col;
+	fp in_final_sum;
+	fp in_sqr_final_sum;
+	fp mean;
+	fp mean_sqr;
+	fp variance;
+	fp deviation;
+	fp denomT;
+	int pointer;
+	int ori_pointer;
+	int loc_pointer;
+	int ei_mod;
+
+	//======================================================================================================================================================
+	//	GENERATE TEMPLATE
+	//======================================================================================================================================================
+
+	// generate templates based on the first frame only
+	if(public.frame_no == 0){
+
+		// update temporary row/col coordinates
+		pointer = private.point_no*public.frames+public.frame_no;
+		private.d_tRowLoc[pointer] = private.d_Row[private.point_no];
+		private.d_tColLoc[pointer] = private.d_Col[private.point_no];
+
+		// pointers to: current frame, template for current point
+		d_in = &private.d_T[private.in_pointer];
+
+		// update template, limit the number of working threads to the size of template
+		for(col=0; col<public.in_mod_cols; col++){
+			for(row=0; row<public.in_mod_rows; row++){
+
+				// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)
+				ori_row = private.d_Row[private.point_no] - 25 + row - 1;
+				ori_col = private.d_Col[private.point_no] - 25 + col - 1;
+				ori_pointer = ori_col*public.frame_rows+ori_row;
+
+				// update template
+				d_in[col*public.in_mod_rows+row] = public.d_frame[ori_pointer];
+
+			}
+		}
+
+	}
+
+	//======================================================================================================================================================
+	//	PROCESS POINTS
+	//======================================================================================================================================================
+
+	// process points in all frames except for the first one
+	if(public.frame_no != 0){
+
+		//====================================================================================================
+		//	INPUTS
+		//====================================================================================================
+
+		//==================================================
+		//	1) SETUP POINTER TO POINT TO CURRENT FRAME FROM BATCH
+		//	2) SELECT INPUT 2 (SAMPLE AROUND POINT) FROM FRAME			SAVE IN d_in2			(NOT LINEAR IN MEMORY, SO NEED TO SAVE OUTPUT FOR LATER EASY USE)
+		//	3) SQUARE INPUT 2									SAVE IN d_in2_sqr
+		//==================================================
+
+		// pointers and variables
+		in2_rowlow = private.d_Row[private.point_no] - public.sSize;							// (1 to n+1)
+		in2_collow = private.d_Col[private.point_no] - public.sSize;
+
+		// work
+		for(col=0; col<public.in2_cols; col++){
+			for(row=0; row<public.in2_rows; row++){
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + in2_rowlow - 1;
+			ori_col = col + in2_collow - 1;
+			temp = public.d_frame[ori_col*public.frame_rows+ori_row];
+			private.d_in2[col*public.in2_rows+row] = temp;
+			private.d_in2_sqr[col*public.in2_rows+row] = temp*temp;
+
+			}
+		}
+
+		//==================================================
+		//	1) GET POINTER TO INPUT 1 (TEMPLATE FOR THIS POINT) IN TEMPLATE ARRAY				(LINEAR IN MEMORY, SO DONT NEED TO SAVE, JUST GET POINTER)
+		//	2) ROTATE INPUT 1									SAVE IN d_in_mod
+		//	3) SQUARE INPUT 1									SAVE IN d_in_sqr
+		//==================================================
+
+		// variables
+		d_in = &private.d_T[private.in_pointer];
+
+		// work
+		for(col=0; col<public.in_mod_cols; col++){
+			for(row=0; row<public.in_mod_rows; row++){
+
+			// rotated coordinates
+			rot_row = (public.in_mod_rows-1) - row;
+			rot_col = (public.in_mod_rows-1) - col;
+			pointer = rot_col*public.in_mod_rows+rot_row;
+
+			// execution
+			temp = d_in[pointer];
+			private.d_in_mod[col*public.in_mod_rows+row] = temp;
+			private.d_in_sqr[pointer] = temp * temp;
+
+			}
+		}
+
+		//==================================================
+		//	1) GET SUM OF INPUT 1
+		//	2) GET SUM OF INPUT 1 SQUARED
+		//==================================================
+
+		in_final_sum = 0;
+		for(i = 0; i<public.in_mod_elem; i++){
+			in_final_sum = in_final_sum + d_in[i];
+		}
+
+		in_sqr_final_sum = 0;
+		for(i = 0; i<public.in_mod_elem; i++){
+			in_sqr_final_sum = in_sqr_final_sum + private.d_in_sqr[i];
+		}
+
+		//==================================================
+		//	3) DO STATISTICAL CALCULATIONS
+		//	4) GET DENOMINATOR T
+		//==================================================
+
+		mean = in_final_sum / public.in_mod_elem;													// gets mean (average) value of element in ROI
+		mean_sqr = mean * mean;
+		variance  = (in_sqr_final_sum / public.in_mod_elem) - mean_sqr;							// gets variance of ROI
+		deviation = sqrt(variance);																// gets standard deviation of ROI
+
+		denomT = sqrt((fp)(public.in_mod_elem-1))*deviation;
+
+		//====================================================================================================
+		//	1) CONVOLVE INPUT 2 WITH ROTATED INPUT 1					SAVE IN d_conv
+		//====================================================================================================
+
+		// work
+		for(col=1; col<=public.conv_cols; col++){
+
+			// column setup
+			j = col + public.joffset;
+			jp1 = j + 1;
+			if(public.in2_cols < jp1){
+				ja1 = jp1 - public.in2_cols;
+			}
+			else{
+				ja1 = 1;
+			}
+			if(public.in_mod_cols < j){
+				ja2 = public.in_mod_cols;
+			}
+			else{
+				ja2 = j;
+			}
+
+			for(row=1; row<=public.conv_rows; row++){
+
+				// row range setup
+				i = row + public.ioffset;
+				ip1 = i + 1;
+				
+				if(public.in2_rows < ip1){
+					ia1 = ip1 - public.in2_rows;
+				}
+				else{
+					ia1 = 1;
+				}
+				if(public.in_mod_rows < i){
+					ia2 = public.in_mod_rows;
+				}
+				else{
+					ia2 = i;
+				}
+
+				s = 0;
+
+				// getting data
+				for(ja=ja1; ja<=ja2; ja++){
+					jb = jp1 - ja;
+					for(ia=ia1; ia<=ia2; ia++){
+						ib = ip1 - ia;
+						s = s + private.d_in_mod[public.in_mod_rows*(ja-1)+ia-1] * private.d_in2[public.in2_rows*(jb-1)+ib-1];
+					}
+				}
+
+				private.d_conv[(col-1)*public.conv_rows+(row-1)] = s;
+
+		}
+	}
+		//====================================================================================================
+		//	LOCAL SUM 1
+		//====================================================================================================
+
+		//==================================================
+		//	1) PADD ARRAY										SAVE IN d_in2_pad
+		//==================================================
+
+		// work
+		for(col=0; col<public.in2_pad_cols; col++){
+			for(row=0; row<public.in2_pad_rows; row++){
+
+			// execution
+			if(	row > (public.in2_pad_add_rows-1) &&														// do if has numbers in original array
+				row < (public.in2_pad_add_rows+public.in2_rows) && 
+				col > (public.in2_pad_add_cols-1) && 
+				col < (public.in2_pad_add_cols+public.in2_cols)){
+				ori_row = row - public.in2_pad_add_rows;
+				ori_col = col - public.in2_pad_add_cols;
+				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2[ori_col*public.in2_rows+ori_row];
+			}
+			else{																			// do if otherwise
+				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;
+			}
+
+			}
+		}
+
+		//==================================================
+		//	1) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad
+		//==================================================
+
+		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){
+
+			// figure out column position
+			pos_ori = ei_new*public.in2_pad_rows;
+
+			// loop through all rows
+			sum = 0;
+			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){
+				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;
+				sum = private.d_in2_pad[position];
+			}
+
+		}
+
+		//==================================================
+		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM
+		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM
+		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub
+		//==================================================
+
+		// work
+		for(col=0; col<public.in2_sub_cols; col++){
+			for(row=0; row<public.in2_sub_rows; row++){
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;
+			ori_col = col + public.in2_pad_cumv_sel_collow - 1;
+			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;
+			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;
+			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
+
+			// subtraction
+			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;
+
+			}
+		}
+
+		//==================================================
+		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub
+		//==================================================
+
+		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){
+
+			// figure out row position
+			pos_ori = ei_new;
+
+			// loop through all rows
+			sum = 0;
+			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){
+				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;
+				sum = private.d_in2_sub[position];
+			}
+
+		}
+
+		//==================================================
+		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM
+		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM
+		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 1
+		//	4) GET CUMULATIVE SUM 1 SQUARED						SAVE IN d_in2_sub2_sqr
+		//	5) GET NUMERATOR									SAVE IN d_conv
+		//==================================================
+
+		// work
+		for(col=0; col<public.in2_sub2_sqr_cols; col++){
+			for(row=0; row<public.in2_sub2_sqr_rows; row++){
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;
+			ori_col = col + public.in2_sub_cumh_sel_collow - 1;
+			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;
+			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;
+			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
+			
+			// subtraction
+			temp2 = temp - temp2;
+
+			// squaring
+			private.d_in2_sub2_sqr[col*public.in2_sub2_sqr_rows+row] = temp2 * temp2; 
+
+			// numerator
+			private.d_conv[col*public.in2_sub2_sqr_rows+row] = private.d_conv[col*public.in2_sub2_sqr_rows+row] - temp2 * in_final_sum / public.in_mod_elem;
+
+			}
+		}
+
+		//====================================================================================================
+		//	LOCAL SUM 2
+		//====================================================================================================
+
+		//==================================================
+		//	1) PAD ARRAY										SAVE IN d_in2_pad
+		//==================================================
+
+		// work
+		for(col=0; col<public.in2_pad_cols; col++){
+			for(row=0; row<public.in2_pad_rows; row++){
+
+			// execution
+			if(	row > (public.in2_pad_add_rows-1) &&													// do if has numbers in original array
+				row < (public.in2_pad_add_rows+public.in2_rows) && 
+				col > (public.in2_pad_add_cols-1) && 
+				col < (public.in2_pad_add_cols+public.in2_cols)){
+				ori_row = row - public.in2_pad_add_rows;
+				ori_col = col - public.in2_pad_add_cols;
+				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2_sqr[ori_col*public.in2_rows+ori_row];
+			}
+			else{																							// do if otherwise
+				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;
+			}
+
+			}
+		}
+
+		//==================================================
+		//	2) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad
+		//==================================================
+
+		//work
+		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){
+
+			// figure out column position
+			pos_ori = ei_new*public.in2_pad_rows;
+
+			// loop through all rows
+			sum = 0;
+			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){
+				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;
+				sum = private.d_in2_pad[position];
+			}
+
+		}
+
+		//==================================================
+		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM
+		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM
+		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub
+		//==================================================
+
+		// work
+		for(col=0; col<public.in2_sub_cols; col++){
+			for(row=0; row<public.in2_sub_rows; row++){
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;
+			ori_col = col + public.in2_pad_cumv_sel_collow - 1;
+			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;
+			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;
+			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];
+
+			// subtract
+			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;
+
+			}
+		}
+
+		//==================================================
+		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub
+		//==================================================
+
+		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){
+
+			// figure out row position
+			pos_ori = ei_new;
+
+			// loop through all rows
+			sum = 0;
+			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){
+				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;
+				sum = private.d_in2_sub[position];
+			}
+
+		}
+
+		//==================================================
+		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM
+		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM
+		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 2
+		//	4) GET DIFFERENTIAL LOCAL SUM
+		//	5) GET DENOMINATOR A
+		//	6) GET DENOMINATOR
+		//	7) DIVIDE NUMBERATOR BY DENOMINATOR TO GET CORRELATION	SAVE IN d_conv
+		//==================================================
+
+		// work
+		for(col=0; col<public.conv_cols; col++){
+			for(row=0; row<public.conv_rows; row++){
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;
+			ori_col = col + public.in2_sub_cumh_sel_collow - 1;
+			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
+
+			// figure out corresponding location in old matrix and copy values to new matrix
+			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;
+			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;
+			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];
+
+			// subtract
+			temp2 = temp - temp2;
+
+			// diff_local_sums
+			temp2 = temp2 - (private.d_in2_sub2_sqr[col*public.conv_rows+row] / public.in_mod_elem);
+
+			// denominator A
+			if(temp2 < 0){
+				temp2 = 0;
+			}
+			temp2 = sqrt(temp2);
+
+			// denominator
+			temp2 = denomT * temp2;
+			
+			// correlation
+			private.d_conv[col*public.conv_rows+row] = private.d_conv[col*public.conv_rows+row] / temp2;
+
+			}
+		}
+
+		//====================================================================================================
+		//	TEMPLATE MASK CREATE
+		//====================================================================================================
+
+		// parameters
+		cent = public.sSize + public.tSize + 1;
+		pointer = public.frame_no-1+private.point_no*public.frames;
+		tMask_row = cent + private.d_tRowLoc[pointer] - private.d_Row[private.point_no] - 1;
+		tMask_col = cent + private.d_tColLoc[pointer] - private.d_Col[private.point_no] - 1;
+
+		//work
+		for(ei_new = 0; ei_new < public.tMask_elem; ei_new++){
+			private.d_tMask[ei_new] = 0;
+		}
+		private.d_tMask[tMask_col*public.tMask_rows + tMask_row] = 1;
+
+
+		//====================================================================================================
+		//	1) MASK CONVOLUTION
+		//	2) MULTIPLICATION
+		//====================================================================================================
+
+		// work
+		// for(col=1; col<=public.conv_cols; col++){
+		for(col=1; col<=public.mask_conv_cols; col++){
+
+			// col setup
+			j = col + public.mask_conv_joffset;
+			jp1 = j + 1;
+			if(public.mask_cols < jp1){
+				ja1 = jp1 - public.mask_cols;
+			}
+			else{
+				ja1 = 1;
+			}
+			if(public.tMask_cols < j){
+				ja2 = public.tMask_cols;
+			}
+			else{
+				ja2 = j;
+			}
+
+			// for(row=1; row<=public.conv_rows; row++){
+			for(row=1; row<=public.mask_conv_rows; row++){
+
+				// row setup
+				i = row + public.mask_conv_ioffset;
+				ip1 = i + 1;
+				
+				if(public.mask_rows < ip1){
+					ia1 = ip1 - public.mask_rows;
+				}
+				else{
+					ia1 = 1;
+				}
+				if(public.tMask_rows < i){
+					ia2 = public.tMask_rows;
+				}
+				else{
+					ia2 = i;
+				}
+
+				s = 0;
+
+				// get data
+				for(ja=ja1; ja<=ja2; ja++){
+					jb = jp1 - ja;
+					for(ia=ia1; ia<=ia2; ia++){
+						ib = ip1 - ia;
+						s = s + private.d_tMask[public.tMask_rows*(ja-1)+ia-1] * 1;
+					}
+				}
+
+				private.d_mask_conv[(col-1)*public.conv_rows+(row-1)] = private.d_conv[(col-1)*public.conv_rows+(row-1)] * s;
+
+			}
+
+		}
+
+		//====================================================================================================
+		//	MAXIMUM VALUE
+		//====================================================================================================
+
+		//==================================================
+		//	SEARCH
+		//==================================================
+
+		fin_max_val = 0;
+		fin_max_coo = 0;
+		for(i=0; i<public.mask_conv_elem; i++){
+			if(private.d_mask_conv[i]>fin_max_val){
+				fin_max_val = private.d_mask_conv[i];
+				fin_max_coo = i;
+			}
+		}
+
+		//==================================================
+		//	OFFSET
+		//==================================================
+
+		// convert coordinate to row/col form
+		largest_row = (fin_max_coo+1) % public.mask_conv_rows - 1;											// (0-n) row
+		largest_col = (fin_max_coo+1) / public.mask_conv_rows;												// (0-n) column
+		if((fin_max_coo+1) % public.mask_conv_rows == 0){
+			largest_row = public.mask_conv_rows - 1;
+			largest_col = largest_col - 1;
+		}
+
+		// calculate offset
+		largest_row = largest_row + 1;																	// compensate to match MATLAB format (1-n)
+		largest_col = largest_col + 1;																	// compensate to match MATLAB format (1-n)
+		offset_row = largest_row - public.in_mod_rows - (public.sSize - public.tSize);
+		offset_col = largest_col - public.in_mod_cols - (public.sSize - public.tSize);
+		pointer = private.point_no*public.frames+public.frame_no;
+		private.d_tRowLoc[pointer] = private.d_Row[private.point_no] + offset_row;
+		private.d_tColLoc[pointer] = private.d_Col[private.point_no] + offset_col;
+
+	}
+
+	//======================================================================================================================================================
+	//	COORDINATE AND TEMPLATE UPDATE
+	//======================================================================================================================================================
+
+	// if the last frame in the bath, update template
+	if(public.frame_no != 0 && (public.frame_no)%10 == 0){
+
+		// update coordinate
+		loc_pointer = private.point_no*public.frames+public.frame_no;
+		private.d_Row[private.point_no] = private.d_tRowLoc[loc_pointer];
+		private.d_Col[private.point_no] = private.d_tColLoc[loc_pointer];
+
+		// update template, limit the number of working threads to the size of template
+		for(col=0; col<public.in_mod_cols; col++){
+			for(row=0; row<public.in_mod_rows; row++){
+
+			// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)
+			ori_row = private.d_Row[private.point_no] - 25 + row - 1;
+			ori_col = private.d_Col[private.point_no] - 25 + col - 1;
+			ori_pointer = ori_col*public.frame_rows+ori_row;
+
+			// update template
+			d_in[col*public.in_mod_rows+row] = public.alpha*d_in[col*public.in_mod_rows+row] + (1.00-public.alpha)*public.d_frame[ori_pointer];
+
+			}
+		}
+
+	}
+
+}
+
+	//===============================================================================================================================================================================================================
+	//===============================================================================================================================================================================================================
+	//	END OF FUNCTION
+	//===============================================================================================================================================================================================================
+	//===============================================================================================================================================================================================================
 
-#include "define.c"
-#include "kernel.c"
 
 
 //===============================================================================================================================================================================================================200
@@ -526,6 +1507,8 @@
 	//	KERNEL
 	//======================================================================================================================================================
 
+    double start_time = omp_get_wtime();
+
 	for(public.frame_no=0; public.frame_no<frames_processed; public.frame_no++){
 
 	//====================================================================================================
@@ -568,6 +1551,9 @@
 
 	}
 
+	double end_time = omp_get_wtime();
+	printf("\nCompute time: %lf\n", (end_time - start_time));
+
 	//======================================================================================================================================================
 	//	PRINT FRAME PROGRESS END
 	//======================================================================================================================================================
diff -ruN rodinia_3.1/openmp/heartwall/makefile rodinia_3.1_new/openmp/heartwall/makefile
--- rodinia_3.1/openmp/heartwall/makefile	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/heartwall/makefile	2024-08-29 14:50:13.867123554 -0700
@@ -3,13 +3,16 @@
 override OUTPUT = -DOUTPUT
 endif
 
+CC = clang
+CC_FLAGS = -O3 -fopenmp -fopenmp-version=51
+
 # link objects(binaries) together
 heartwall: main.o ./AVI/avilib.o ./AVI/avimod.o
-	gcc main.o ./AVI/avilib.o ./AVI/avimod.o -lm -fopenmp -o heartwall
+	$(CC) main.o ./AVI/avilib.o ./AVI/avimod.o -lm -fopenmp -o heartwall
 
 # compile main function file into object (binary)
-main.o: main.c define.c kernel.c
-	gcc $(OUTPUT) main.c -I./AVI -c -O3 -fopenmp
+main.o: main.c
+	$(CC) $(CC_FLAGS) $(OUTPUT) main.c -I./AVI -c
 
 ./AVI/avilib.o ./AVI/avimod.o:
 	cd AVI; make;
diff -ruN rodinia_3.1/openmp/heartwall/run rodinia_3.1_new/openmp/heartwall/run
--- rodinia_3.1/openmp/heartwall/run	2024-08-29 14:54:06.572368073 -0700
+++ rodinia_3.1_new/openmp/heartwall/run	2024-08-29 14:50:13.867123554 -0700
@@ -1 +1 @@
-./heartwall ../../data/heartwall/test.avi 20 4
+./heartwall ../../data/heartwall/test.avi 20 14
diff -ruN rodinia_3.1/openmp/hotspot/hotspot_openmp.cpp rodinia_3.1_new/openmp/hotspot/hotspot_openmp.cpp
--- rodinia_3.1/openmp/hotspot/hotspot_openmp.cpp	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/hotspot/hotspot_openmp.cpp	2024-08-29 14:50:13.919123599 -0700
@@ -39,7 +39,7 @@
 const FLOAT chip_width = 0.016;
 
 #ifdef OMP_OFFLOAD
-#pragma offload_attribute(push, target(mic))
+#pragma offload_attribute(push, target(mic))
 #endif
 
 /* ambient temperature, assuming no package at all	*/
@@ -312,7 +312,7 @@
     long long end_time = get_time();
 
     printf("Ending simulation\n");
-    printf("Total time: %.3f seconds\n", ((float) (end_time - start_time)) / (1000*1000));
+    printf("Total time: %.7f seconds\n", ((float) (end_time - start_time)) / (1000*1000));
 
     writeoutput((1&sim_time) ? result : temp, grid_rows, grid_cols, ofile);
 
diff -ruN rodinia_3.1/openmp/hotspot/Makefile rodinia_3.1_new/openmp/hotspot/Makefile
--- rodinia_3.1/openmp/hotspot/Makefile	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/hotspot/Makefile	2024-08-29 14:50:13.919123599 -0700
@@ -1,7 +1,7 @@
 # C compiler
 CC = g++
-ICC = icc
-CC_FLAGS = -g -fopenmp -O2
+ICC = icpx
+CC_FLAGS = -g -fopenmp -O2 -fopenmp-version=51
 OFFLOAD_CC_FLAGS = -offload-option,mic,compiler,"-no-opt-prefetch"
 
 all: hotspot hotspot_offload 
diff -ruN rodinia_3.1/openmp/hotspot/run rodinia_3.1_new/openmp/hotspot/run
--- rodinia_3.1/openmp/hotspot/run	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/hotspot/run	2024-08-29 14:50:13.919123599 -0700
@@ -1 +1 @@
-./hotspot 1024 1024 2 4 ../../data/hotspot/temp_1024 ../../data/hotspot/power_1024 output.out
+./hotspot 1024 1024 16384 14 ../../data/hotspot/temp_1024 ../../data/hotspot/power_1024 output.out
Binary files rodinia_3.1/openmp/hotspot3D/3D and rodinia_3.1_new/openmp/hotspot3D/3D differ
diff -ruN rodinia_3.1/openmp/hotspot3D/3D.c rodinia_3.1_new/openmp/hotspot3D/3D.c
--- rodinia_3.1/openmp/hotspot3D/3D.c	2024-08-29 14:54:06.615368125 -0700
+++ rodinia_3.1_new/openmp/hotspot3D/3D.c	2024-08-29 14:50:13.760123463 -0700
@@ -261,9 +261,9 @@
     computeTempCPU(powerIn, tempCopy, answer, numCols, numRows, layers, Cap, Rx, Ry, Rz, dt,iterations);
 
     float acc = accuracy(tempOut,answer,numRows*numCols*layers);
-    printf("Time: %.3f (s)\n",time);
+    printf("Time: %.7f (s)\n",time);
     printf("Accuracy: %e\n",acc);
-    writeoutput(tempOut,numRows, numCols, layers, ofile);
+    //writeoutput(tempOut,numRows, numCols, layers, ofile);
     free(tempIn);
     free(tempOut); free(powerIn);
     return 0;
diff -ruN rodinia_3.1/openmp/hotspot3D/Makefile rodinia_3.1_new/openmp/hotspot3D/Makefile
--- rodinia_3.1/openmp/hotspot3D/Makefile	2024-08-29 14:54:06.589368094 -0700
+++ rodinia_3.1_new/openmp/hotspot3D/Makefile	2024-08-29 14:50:13.819123513 -0700
@@ -1,5 +1,5 @@
 CC = gcc
-CCFLAGS = -g -fopenmp -O3
+CCFLAGS = -g -fopenmp -O3 -fopenmp-version=51
 OUTPUT = *.out
 
 3D:
diff -ruN rodinia_3.1/openmp/hotspot3D/run rodinia_3.1_new/openmp/hotspot3D/run
--- rodinia_3.1/openmp/hotspot3D/run	2024-08-29 14:54:06.616368126 -0700
+++ rodinia_3.1_new/openmp/hotspot3D/run	2024-08-29 14:50:13.819123513 -0700
@@ -1 +1 @@
-./3D 512 8 100 ../../data/hotspot3D/power_512x8 ../../data/hotspot3D/temp_512x8 output.out
+./3D 512 8 1000 ../../data/hotspot3D/power_512x8 ../../data/hotspot3D/temp_512x8 output.out
diff -ruN rodinia_3.1/openmp/kmeans/kmeans_clustering.c rodinia_3.1_new/openmp/kmeans/kmeans_clustering.c
--- rodinia_3.1/openmp/kmeans/kmeans_clustering.c	1969-12-31 16:00:00.000000000 -0800
+++ rodinia_3.1_new/openmp/kmeans/kmeans_clustering.c	2024-08-29 14:50:13.939123616 -0700
@@ -0,0 +1,243 @@
+/*****************************************************************************/
+/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */
+/*By downloading, copying, installing or using the software you agree        */
+/*to this license.  If you do not agree to this license, do not download,    */
+/*install, copy or use the software.                                         */
+/*                                                                           */
+/*                                                                           */
+/*Copyright (c) 2005 Northwestern University                                 */
+/*All rights reserved.                                                       */
+
+/*Redistribution of the software in source and binary forms,                 */
+/*with or without modification, is permitted provided that the               */
+/*following conditions are met:                                              */
+/*                                                                           */
+/*1       Redistributions of source code must retain the above copyright     */
+/*        notice, this list of conditions and the following disclaimer.      */
+/*                                                                           */
+/*2       Redistributions in binary form must reproduce the above copyright   */
+/*        notice, this list of conditions and the following disclaimer in the */
+/*        documentation and/or other materials provided with the distribution.*/ 
+/*                                                                            */
+/*3       Neither the name of Northwestern University nor the names of its    */
+/*        contributors may be used to endorse or promote products derived     */
+/*        from this software without specific prior written permission.       */
+/*                                                                            */
+/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */
+/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */
+/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */
+/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */
+/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */
+/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */
+/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */
+/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */
+/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */
+/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */
+/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */
+/*POSSIBILITY OF SUCH DAMAGE.                                                 */
+/******************************************************************************/
+/*************************************************************************/
+/**   File:         kmeans_clustering.c                                 **/
+/**   Description:  Implementation of regular k-means clustering        **/
+/**                 algorithm                                           **/
+/**   Author:  Wei-keng Liao                                            **/
+/**            ECE Department, Northwestern University                  **/
+/**            email: wkliao@ece.northwestern.edu                       **/
+/**                                                                     **/
+/**   Edited by: Jay Pisharath                                          **/
+/**              Northwestern University.                               **/
+/**                                                                     **/
+/**   ================================================================  **/
+/**																		**/
+/**   Edited by: Sang-Ha  Lee											**/
+/**				 University of Virginia									**/
+/**																		**/
+/**   Description:	No longer supports fuzzy c-means clustering;	 	**/
+/**					only regular k-means clustering.					**/
+/**					Simplified for main functionality: regular k-means	**/
+/**					clustering.											**/
+/**                                                                     **/
+/*************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+#include "kmeans.h"
+#include <omp.h>
+
+#define RANDOM_MAX 2147483647
+
+#ifndef FLT_MAX
+#define FLT_MAX 3.40282347e+38
+#endif
+
+extern double wtime(void);
+extern int num_omp_threads;
+
+int find_nearest_point(float  *pt,          /* [nfeatures] */
+                       int     nfeatures,
+                       float **pts,         /* [npts][nfeatures] */
+                       int     npts)
+{
+    int index, i;
+    float min_dist=FLT_MAX;
+
+    /* find the cluster center id with min distance to pt */
+    for (i=0; i<npts; i++) {
+        float dist;
+        dist = euclid_dist_2(pt, pts[i], nfeatures);  /* no need square root */
+        if (dist < min_dist) {
+            min_dist = dist;
+            index    = i;
+        }
+    }
+    return(index);
+}
+
+/*----< euclid_dist_2() >----------------------------------------------------*/
+/* multi-dimensional spatial Euclid distance square */
+__inline
+float euclid_dist_2(float *pt1,
+                    float *pt2,
+                    int    numdims)
+{
+    int i;
+    float ans=0.0;
+
+    for (i=0; i<numdims; i++)
+        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);
+
+    return(ans);
+}
+
+
+/*----< kmeans_clustering() >---------------------------------------------*/
+float** kmeans_clustering(float **feature,    /* in: [npoints][nfeatures] */
+                          int     nfeatures,
+                          int     npoints,
+                          int     nclusters,
+                          float   threshold,
+                          int    *membership) /* out: [npoints] */
+{
+
+    int      i, j, k, n=0, index, loop=0;
+    int     *new_centers_len;			/* [nclusters]: no. of points in each cluster */
+	float  **new_centers;				/* [nclusters][nfeatures] */
+	float  **clusters;					/* out: [nclusters][nfeatures] */
+    float    delta;
+        
+    double   timing;
+
+	int      nthreads;
+    int    **partial_new_centers_len;
+    float ***partial_new_centers;
+
+    nthreads = num_omp_threads; 
+
+    /* allocate space for returning variable clusters[] */
+    clusters    = (float**) malloc(nclusters *             sizeof(float*));
+    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));
+    for (i=1; i<nclusters; i++)
+        clusters[i] = clusters[i-1] + nfeatures;
+
+    /* randomly pick cluster centers */
+    for (i=0; i<nclusters; i++) {
+        //n = (int)rand() % npoints;
+        for (j=0; j<nfeatures; j++)
+            clusters[i][j] = feature[n][j];
+		n++;
+    }
+
+    for (i=0; i<npoints; i++)
+		membership[i] = -1;
+
+    /* need to initialize new_centers_len and new_centers[0] to all 0 */
+    new_centers_len = (int*) calloc(nclusters, sizeof(int));
+
+    new_centers    = (float**) malloc(nclusters *            sizeof(float*));
+    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));
+    for (i=1; i<nclusters; i++)
+        new_centers[i] = new_centers[i-1] + nfeatures;
+
+
+    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));
+    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));
+    for (i=1; i<nthreads; i++)
+		partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;
+
+	partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));
+    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));
+    for (i=1; i<nthreads; i++)
+        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;
+
+	for (i=0; i<nthreads; i++)
+	{
+        for (j=0; j<nclusters; j++)
+            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));
+	}
+	printf("num of threads = %d\n", num_omp_threads);
+    do {
+        delta = 0.0;
+		omp_set_num_threads(num_omp_threads);
+		#pragma omp parallel \
+                shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)
+        {
+            int tid = omp_get_thread_num();				
+            #pragma omp for \
+                        private(i,j,index) \
+                        firstprivate(npoints,nclusters,nfeatures) \
+                        schedule(static) \
+                        reduction(+:delta)
+            for (i=0; i<npoints; i++) {
+	        /* find the index of nestest cluster centers */					
+	        index = find_nearest_point(feature[i],
+		             nfeatures,
+		             clusters,
+		             nclusters);				
+	        /* if membership changes, increase delta by 1 */
+	        if (membership[i] != index) delta += 1.0;
+
+	        /* assign the membership to object i */
+	        membership[i] = index;
+				
+	        /* update new cluster centers : sum of all objects located
+		       within */
+	        partial_new_centers_len[tid][index]++;				
+	        for (j=0; j<nfeatures; j++)
+		       partial_new_centers[tid][index][j] += feature[i][j];
+            }
+        } /* end of #pragma omp parallel */
+
+        /* let the main thread perform the array reduction */
+        for (i=0; i<nclusters; i++) {
+            for (j=0; j<nthreads; j++) {
+                new_centers_len[i] += partial_new_centers_len[j][i];
+                partial_new_centers_len[j][i] = 0.0;
+                for (k=0; k<nfeatures; k++) {
+                    new_centers[i][k] += partial_new_centers[j][i][k];
+                    partial_new_centers[j][i][k] = 0.0;
+                }
+            }
+        }    
+
+		/* replace old cluster centers with new_centers */
+		for (i=0; i<nclusters; i++) {
+            for (j=0; j<nfeatures; j++) {
+                if (new_centers_len[i] > 0)
+					clusters[i][j] = new_centers[i][j] / new_centers_len[i];
+				new_centers[i][j] = 0.0;   /* set back to 0 */
+			}
+			new_centers_len[i] = 0;   /* set back to 0 */
+		}
+        
+    } while (delta > threshold && loop++ < 500);
+
+    
+    free(new_centers[0]);
+    free(new_centers);
+    free(new_centers_len);
+
+    return clusters;
+}
+
diff -ruN rodinia_3.1/openmp/kmeans/Makefile rodinia_3.1_new/openmp/kmeans/Makefile
--- rodinia_3.1/openmp/kmeans/Makefile	2024-08-29 14:54:54.507427810 -0700
+++ rodinia_3.1_new/openmp/kmeans/Makefile	2024-08-29 14:50:13.939123616 -0700
@@ -1,6 +1,6 @@
 # C compiler
 CC = gcc
-CC_FLAGS = -g -fopenmp -O2 
+CC_FLAGS = -g -fopenmp -O2
 
 kmeans: cluster.o getopt.o kmeans.o kmeans_clustering.o 
 	$(CC) $(CC_FLAGS) cluster.o getopt.o kmeans.o kmeans_clustering.o  -o kmeans
diff -ruN rodinia_3.1/openmp/lavaMD/kernel/kernel_cpu.c rodinia_3.1_new/openmp/lavaMD/kernel/kernel_cpu.c
--- rodinia_3.1/openmp/lavaMD/kernel/kernel_cpu.c	2024-08-29 14:54:06.575368076 -0700
+++ rodinia_3.1_new/openmp/lavaMD/kernel/kernel_cpu.c	2024-08-29 14:50:14.130123779 -0700
@@ -208,7 +208,7 @@
 	printf("%15.12f s, %15.12f % : CPU/MCPU: INPUTS\n", 				(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time4-time0) * 100);
 	printf("%15.12f s, %15.12f % : CPU/MCPU: KERNEL\n",					(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time4-time0) * 100);
 
-	printf("Total time:\n");
+	printf("Total time: ");
 	printf("%.12f s\n", 												(float) (time4-time0) / 1000000);
 
 } // main
diff -ruN rodinia_3.1/openmp/lavaMD/run rodinia_3.1_new/openmp/lavaMD/run
--- rodinia_3.1/openmp/lavaMD/run	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/lavaMD/run	2024-08-29 14:50:14.130123779 -0700
@@ -1 +1 @@
-./lavaMD -cores 4 -boxes1d 10
\ No newline at end of file
+./lavaMD -cores 14 -boxes1d 20
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/leukocyte/Makefile rodinia_3.1_new/openmp/leukocyte/Makefile
--- rodinia_3.1/openmp/leukocyte/Makefile	2024-08-29 14:54:06.579368081 -0700
+++ rodinia_3.1_new/openmp/leukocyte/Makefile	2024-08-29 14:50:13.986123656 -0700
@@ -5,4 +5,4 @@
 
 clean:
 	cd OpenMP; make clean
-	rm -f meschach_lib/meschach.a
+	#rm -f meschach_lib/meschach.a
Binary files rodinia_3.1/openmp/leukocyte/meschach_lib/meschach.a and rodinia_3.1_new/openmp/leukocyte/meschach_lib/meschach.a differ
Binary files rodinia_3.1/openmp/leukocyte/OpenMP/avilib.o and rodinia_3.1_new/openmp/leukocyte/OpenMP/avilib.o differ
Binary files rodinia_3.1/openmp/leukocyte/OpenMP/detect_main.o and rodinia_3.1_new/openmp/leukocyte/OpenMP/detect_main.o differ
Binary files rodinia_3.1/openmp/leukocyte/OpenMP/find_ellipse.o and rodinia_3.1_new/openmp/leukocyte/OpenMP/find_ellipse.o differ
Binary files rodinia_3.1/openmp/leukocyte/OpenMP/leukocyte and rodinia_3.1_new/openmp/leukocyte/OpenMP/leukocyte differ
diff -ruN rodinia_3.1/openmp/leukocyte/OpenMP/Makefile rodinia_3.1_new/openmp/leukocyte/OpenMP/Makefile
--- rodinia_3.1/openmp/leukocyte/OpenMP/Makefile	2024-08-29 14:54:06.587368091 -0700
+++ rodinia_3.1_new/openmp/leukocyte/OpenMP/Makefile	2024-08-29 14:50:13.986123656 -0700
@@ -11,7 +11,7 @@
 MATRIX_DIR = ../meschach_lib
 
 
-leukocyte: detect_main.o avilib.o find_ellipse.o track_ellipse.o misc_math.o $(MATRIX_DIR)/meschach.a
+leukocyte: detect_main.o avilib.o find_ellipse.o track_ellipse.o misc_math.o #$(MATRIX_DIR)/meschach.a
 	$(CC) $(CC_FLAGS) -lm avilib.o find_ellipse.o track_ellipse.o misc_math.o detect_main.o -o leukocyte -lm $(MATRIX_DIR)/meschach.a -lpthread
 
 %.o: %.[ch]
@@ -21,8 +21,8 @@
 find_ellipse.o: avilib.h
 track_ellipse.o: find_ellipse.h track_ellipse.h avilib.h
 
-$(MATRIX_DIR)/meschach.a:
-	cd $(MATRIX_DIR); ./configure --with-all; make all; make clean
+#$(MATRIX_DIR)/meschach.a:
+#	cd $(MATRIX_DIR); ./configure --with-all; make all; make clean
 
 clean:
 	rm -f *.o leukocyte
Binary files rodinia_3.1/openmp/leukocyte/OpenMP/misc_math.o and rodinia_3.1_new/openmp/leukocyte/OpenMP/misc_math.o differ
Binary files rodinia_3.1/openmp/leukocyte/OpenMP/track_ellipse.o and rodinia_3.1_new/openmp/leukocyte/OpenMP/track_ellipse.o differ
diff -ruN rodinia_3.1/openmp/lud/Makefile rodinia_3.1_new/openmp/lud/Makefile
--- rodinia_3.1/openmp/lud/Makefile	2024-08-29 14:54:06.575368076 -0700
+++ rodinia_3.1_new/openmp/lud/Makefile	2024-08-29 14:50:13.819123513 -0700
@@ -1,4 +1,4 @@
-all: lud_omp lud_omp_offload
+all: lud_omp_offload
 
 lud_omp:
 	cd omp; make
diff -ruN rodinia_3.1/openmp/lud/omp/lud.c rodinia_3.1_new/openmp/lud/omp/lud.c
--- rodinia_3.1/openmp/lud/omp/lud.c	2024-08-29 14:54:06.575368076 -0700
+++ rodinia_3.1_new/openmp/lud/omp/lud.c	2024-08-29 14:50:13.820123514 -0700
@@ -120,7 +120,7 @@
   stopwatch_start(&sw);
   lud_omp(m, matrix_dim);
   stopwatch_stop(&sw);
-  printf("Time consumed(ms): %lf\n", 1000*get_interval_by_sec(&sw));
+  printf("Time consumed(s): %lf\n", get_interval_by_sec(&sw));
 
   if (do_verify){
     printf("After LUD\n");
diff -ruN rodinia_3.1/openmp/lud/omp/Makefile.offload rodinia_3.1_new/openmp/lud/omp/Makefile.offload
--- rodinia_3.1/openmp/lud/omp/Makefile.offload	2024-08-29 14:54:06.575368076 -0700
+++ rodinia_3.1_new/openmp/lud/omp/Makefile.offload	2024-08-29 14:50:13.819123513 -0700
@@ -20,7 +20,7 @@
 
 # ------------  compiler flags  ------------------------------------------------  -qopt-gather-scatter-unroll=7
 DEBUG_CFLAGS    := -Wall -O0 -g
-RELEASE_CFLAGS  := -Wall -O3 -g -fp-model fast=2 -fma -offload-option,mic,compiler,"-no-opt-prefetch"
+RELEASE_CFLAGS  := -Wall -O3 -g -offload-option,mic,compiler,"-no-opt-prefetch"
 COMMON_CFLAGS   := -fopenmp
 
 # ------------  compiler defs  ------------------------------------------------
diff -ruN rodinia_3.1/openmp/myocyte/cam.c rodinia_3.1_new/openmp/myocyte/cam.c
--- rodinia_3.1/openmp/myocyte/cam.c	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/myocyte/cam.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,372 +0,0 @@
-//=====================================================================
-//	MAIN FUNCTION
-//=====================================================================
-fp cam(fp timeinst,
-			fp *initvalu,
-			int initvalu_offset,
-			fp *parameter,
-			int parameter_offset,
-			fp *finavalu,
-			fp Ca){
-
-	//=====================================================================
-	//	VARIABLES
-	//=====================================================================
-
-	// output
-	fp JCa;
-
-	// input data and output data variable references
-	int offset_1;
-	int offset_2;
-	int offset_3;
-	int offset_4;
-	int offset_5;
-	int offset_6;
-	int offset_7;
-	int offset_8;
-	int offset_9;
-	int offset_10;
-	int offset_11;
-	int offset_12;
-	int offset_13;
-	int offset_14;
-	int offset_15;
-
-	// parameter variable references
-	int parameter_offset_1;
-	int parameter_offset_2;
-	int parameter_offset_3;
-	int parameter_offset_4;
-	int parameter_offset_5;
-
-	// decoding input initial values
-	fp CaM;
-	fp Ca2CaM;
-	fp Ca4CaM;
-	fp CaMB;
-	fp Ca2CaMB;
-	fp Ca4CaMB;           
-	fp Pb2;
-	fp Pb;
-	fp Pt;
-	fp Pt2;
-	fp Pa;                            
-	fp Ca4CaN;
-	fp CaMCa4CaN;
-	fp Ca2CaMCa4CaN;
-	fp Ca4CaMCa4CaN;
-
-	// decoding input parameters
-	fp CaMtot;
-	fp Btot;
-	fp CaMKIItot;
-	fp CaNtot;
-	fp PP1tot;
-
-	// constants
-	fp K;																			//
-	fp Mg;																			//
-
-	// Ca/CaM parameters
-	fp Kd02;																		// [uM^2]
-	fp Kd24;																		// [uM^2]
-	fp k20;																			// [s^-1]      
-	fp k02;																			// [uM^-2 s^-1]
-	fp k42;																			// [s^-1]      
-	fp k24;																			// [uM^-2 s^-1]
-
-	// CaM buffering (B) parameters
-	fp k0Boff;																		// [s^-1] 
-	fp k0Bon;																		// [uM^-1 s^-1] kon = koff/Kd
-	fp k2Boff;																		// [s^-1] 
-	fp k2Bon;																		// [uM^-1 s^-1]
-	fp k4Boff;																		// [s^-1]
-	fp k4Bon;																		// [uM^-1 s^-1]
-
-	// using thermodynamic constraints
-	fp k20B;																		// [s^-1] thermo constraint on loop 1
-	fp k02B;																		// [uM^-2 s^-1] 
-	fp k42B;																		// [s^-1] thermo constraint on loop 2
-	fp k24B;																		// [uM^-2 s^-1]
-
-	// Wi Wa Wt Wp
-	fp kbi;																			// [s^-1] (Ca4CaM dissocation from Wb)
-	fp kib;																			// [uM^-1 s^-1]
-	fp kpp1;																		// [s^-1] (PP1-dep dephosphorylation rates)
-	fp Kmpp1;																		// [uM]
-	fp kib2;
-	fp kb2i;
-	fp kb24;
-	fp kb42;
-	fp kta;																			// [s^-1] (Ca4CaM dissociation from Wt)
-	fp kat;																			// [uM^-1 s^-1] (Ca4CaM reassociation with Wa)
-	fp kt42;
-	fp kt24;
-	fp kat2;
-	fp kt2a;
-
-	// CaN parameters
-	fp kcanCaoff;																	// [s^-1] 
-	fp kcanCaon;																	// [uM^-1 s^-1] 
-	fp kcanCaM4on;																	// [uM^-1 s^-1]
-	fp kcanCaM4off;																	// [s^-1]
-	fp kcanCaM2on;
-	fp kcanCaM2off;
-	fp kcanCaM0on;
-	fp kcanCaM0off;
-	fp k02can;
-	fp k20can;
-	fp k24can;
-	fp k42can;
-
-	// CaM Reaction fluxes
-	fp rcn02;
-	fp rcn24;
-
-	// CaM buffer fluxes
-	fp B;
-	fp rcn02B;
-	fp rcn24B;
-	fp rcn0B;
-	fp rcn2B;
-	fp rcn4B;
-
-	// CaN reaction fluxes 
-	fp Ca2CaN;
-	fp rcnCa4CaN;
-	fp rcn02CaN; 
-	fp rcn24CaN;
-	fp rcn0CaN;
-	fp rcn2CaN;
-	fp rcn4CaN;
-
-	// CaMKII reaction fluxes
-	fp Pix;
-	fp rcnCKib2;
-	fp rcnCKb2b;
-	fp rcnCKib;
-	fp T;
-	fp kbt;
-	fp rcnCKbt;
-	fp rcnCKtt2;
-	fp rcnCKta;
-	fp rcnCKt2a;
-	fp rcnCKt2b2;
-	fp rcnCKai;
-
-	// CaM equations
-	fp dCaM;
-	fp dCa2CaM;
-	fp dCa4CaM;
-	fp dCaMB;
-	fp dCa2CaMB;
-	fp dCa4CaMB;
-
-	// CaMKII equations
-	fp dPb2;																		// Pb2
-	fp dPb;																			// Pb
-	fp dPt;																			// Pt
-	fp dPt2;																		// Pt2
-	fp dPa;																			// Pa
-
-	// CaN equations
-	fp dCa4CaN;																		// Ca4CaN
-	fp dCaMCa4CaN;																	// CaMCa4CaN
-	fp dCa2CaMCa4CaN;																// Ca2CaMCa4CaN
-	fp dCa4CaMCa4CaN;																// Ca4CaMCa4CaN
-
-	//=====================================================================
-	//	COMPUTATION
-	//=====================================================================
-
-	// input data and output data variable references
-	offset_1  = initvalu_offset;
-	offset_2  = initvalu_offset+1;
-	offset_3  = initvalu_offset+2;
-	offset_4  = initvalu_offset+3;
-	offset_5  = initvalu_offset+4;
-	offset_6  = initvalu_offset+5;
-	offset_7  = initvalu_offset+6;
-	offset_8  = initvalu_offset+7;
-	offset_9  = initvalu_offset+8;
-	offset_10 = initvalu_offset+9;
-	offset_11 = initvalu_offset+10;
-	offset_12 = initvalu_offset+11;
-	offset_13 = initvalu_offset+12;
-	offset_14 = initvalu_offset+13;
-	offset_15 = initvalu_offset+14;
-	
-	// input parameters variable references
-	parameter_offset_1  = parameter_offset;
-	parameter_offset_2  = parameter_offset+1;
-	parameter_offset_3  = parameter_offset+2;
-	parameter_offset_4  = parameter_offset+3;
-	parameter_offset_5  = parameter_offset+4;
-
-	// decoding input array
-	CaM				= initvalu[offset_1];
-	Ca2CaM			= initvalu[offset_2];
-	Ca4CaM			= initvalu[offset_3];
-	CaMB			= initvalu[offset_4];
-	Ca2CaMB			= initvalu[offset_5];
-	Ca4CaMB			= initvalu[offset_6];           
-	Pb2				= initvalu[offset_7];
-	Pb				= initvalu[offset_8];
-	Pt				= initvalu[offset_9];
-	Pt2				= initvalu[offset_10];
-	Pa				= initvalu[offset_11];                            
-	Ca4CaN			= initvalu[offset_12];
-	CaMCa4CaN		= initvalu[offset_13];
-	Ca2CaMCa4CaN	= initvalu[offset_14];
-	Ca4CaMCa4CaN	= initvalu[offset_15];
-
-	// decoding input parameters
-	CaMtot			= parameter[parameter_offset_1];
-	Btot			= parameter[parameter_offset_2];
-	CaMKIItot		= parameter[parameter_offset_3];
-	CaNtot			= parameter[parameter_offset_4];
-	PP1tot			= parameter[parameter_offset_5];
-
-	// values [CONSTANTS FOR ALL THREADS]
-	K = 135;																			//
-	Mg = 1;																				//
-
-	// Ca/CaM parameters
-	if (Mg <= 1){
-		Kd02 = 0.0025*(1+K/0.94-Mg/0.012)*(1+K/8.1+Mg/0.022);							// [uM^2]
-		Kd24 = 0.128*(1+K/0.64+Mg/0.0014)*(1+K/13.0-Mg/0.153);							// [uM^2]
-	}
-	else{
-		Kd02 = 0.0025*(1+K/0.94-1/0.012+(Mg-1)/0.060)*(1+K/8.1+1/0.022+(Mg-1)/0.068);   // [uM^2]
-		Kd24 = 0.128*(1+K/0.64+1/0.0014+(Mg-1)/0.005)*(1+K/13.0-1/0.153+(Mg-1)/0.150);  // [uM^2]
-	}
-	k20 = 10;																			// [s^-1]      
-	k02 = k20/Kd02;																		// [uM^-2 s^-1]
-	k42 = 500;																			// [s^-1]      
-	k24 = k42/Kd24;																		// [uM^-2 s^-1]
-
-	// CaM buffering (B) parameters
-	k0Boff = 0.0014;																	// [s^-1] 
-	k0Bon = k0Boff/0.2;																	// [uM^-1 s^-1] kon = koff/Kd
-	k2Boff = k0Boff/100;																// [s^-1] 
-	k2Bon = k0Bon;																		// [uM^-1 s^-1]
-	k4Boff = k2Boff;																	// [s^-1]
-	k4Bon = k0Bon;																		// [uM^-1 s^-1]
-
-	// using thermodynamic constraints
-	k20B = k20/100;																		// [s^-1] thermo constraint on loop 1
-	k02B = k02;																			// [uM^-2 s^-1] 
-	k42B = k42;																			// [s^-1] thermo constraint on loop 2
-	k24B = k24;																			// [uM^-2 s^-1]
-
-	// Wi Wa Wt Wp
-	kbi = 2.2;																			// [s^-1] (Ca4CaM dissocation from Wb)
-	kib = kbi/33.5e-3;																	// [uM^-1 s^-1]
-	kpp1 = 1.72;																		// [s^-1] (PP1-dep dephosphorylation rates)
-	Kmpp1 = 11.5;																		// [uM]
-	kib2 = kib;
-	kb2i = kib2*5;
-	kb24 = k24;
-	kb42 = k42*33.5e-3/5;
-	kta = kbi/1000;																		// [s^-1] (Ca4CaM dissociation from Wt)
-	kat = kib;																			// [uM^-1 s^-1] (Ca4CaM reassociation with Wa)
-	kt42 = k42*33.5e-6/5;
-	kt24 = k24;
-	kat2 = kib;
-	kt2a = kib*5;
-
-	// CaN parameters
-	kcanCaoff = 1;																		// [s^-1] 
-	kcanCaon = kcanCaoff/0.5;															// [uM^-1 s^-1] 
-	kcanCaM4on = 46;																	// [uM^-1 s^-1]
-	kcanCaM4off = 0.0013;																// [s^-1]
-	kcanCaM2on = kcanCaM4on;
-	kcanCaM2off = 2508*kcanCaM4off;
-	kcanCaM0on = kcanCaM4on;
-	kcanCaM0off = 165*kcanCaM2off;
-	k02can = k02;
-	k20can = k20/165;
-	k24can = k24;
-	k42can = k20/2508;
-
-	// CaM Reaction fluxes
-	rcn02 = k02*pow(Ca,2)*CaM - k20*Ca2CaM;
-	rcn24 = k24*pow(Ca,2)*Ca2CaM - k42*Ca4CaM;
-	
-	// CaM buffer fluxes
-	B = Btot - CaMB - Ca2CaMB - Ca4CaMB;
-	rcn02B = k02B*pow(Ca,2)*CaMB - k20B*Ca2CaMB;
-	rcn24B = k24B*pow(Ca,2)*Ca2CaMB - k42B*Ca4CaMB;
-	rcn0B = k0Bon*CaM*B - k0Boff*CaMB;
-	rcn2B = k2Bon*Ca2CaM*B - k2Boff*Ca2CaMB;
-	rcn4B = k4Bon*Ca4CaM*B - k4Boff*Ca4CaMB;
-	
-	// CaN reaction fluxes 
-	Ca2CaN = CaNtot - Ca4CaN - CaMCa4CaN - Ca2CaMCa4CaN - Ca4CaMCa4CaN;
-	rcnCa4CaN = kcanCaon*pow(Ca,2)*Ca2CaN - kcanCaoff*Ca4CaN;
-	rcn02CaN = k02can*pow(Ca,2)*CaMCa4CaN - k20can*Ca2CaMCa4CaN; 
-	rcn24CaN = k24can*pow(Ca,2)*Ca2CaMCa4CaN - k42can*Ca4CaMCa4CaN;
-	rcn0CaN = kcanCaM0on*CaM*Ca4CaN - kcanCaM0off*CaMCa4CaN;
-	rcn2CaN = kcanCaM2on*Ca2CaM*Ca4CaN - kcanCaM2off*Ca2CaMCa4CaN;
-	rcn4CaN = kcanCaM4on*Ca4CaM*Ca4CaN - kcanCaM4off*Ca4CaMCa4CaN;
-
-	// CaMKII reaction fluxes
-	Pix = 1 - Pb2 - Pb - Pt - Pt2 - Pa;
-	rcnCKib2 = kib2*Ca2CaM*Pix - kb2i*Pb2;
-	rcnCKb2b = kb24*pow(Ca,2)*Pb2 - kb42*Pb;
-	rcnCKib = kib*Ca4CaM*Pix - kbi*Pb;
-	T = Pb + Pt + Pt2 + Pa;
-	kbt = 0.055*T + 0.0074*pow(T,2) + 0.015*pow(T,3);
-	rcnCKbt = kbt*Pb - kpp1*PP1tot*Pt/(Kmpp1+CaMKIItot*Pt);
-	rcnCKtt2 = kt42*Pt - kt24*pow(Ca,2)*Pt2;
-	rcnCKta = kta*Pt - kat*Ca4CaM*Pa;
-	rcnCKt2a = kt2a*Pt2 - kat2*Ca2CaM*Pa;
-	rcnCKt2b2 = kpp1*PP1tot*Pt2/(Kmpp1+CaMKIItot*Pt2);
-	rcnCKai = kpp1*PP1tot*Pa/(Kmpp1+CaMKIItot*Pa);
-
-	// CaM equations
-	dCaM = 1e-3*(-rcn02 - rcn0B - rcn0CaN);
-	dCa2CaM = 1e-3*(rcn02 - rcn24 - rcn2B - rcn2CaN + CaMKIItot*(-rcnCKib2 + rcnCKt2a) );
-	dCa4CaM = 1e-3*(rcn24 - rcn4B - rcn4CaN + CaMKIItot*(-rcnCKib+rcnCKta) );
-	dCaMB = 1e-3*(rcn0B-rcn02B);
-	dCa2CaMB = 1e-3*(rcn02B + rcn2B - rcn24B);
-	dCa4CaMB = 1e-3*(rcn24B + rcn4B);
-
-	// CaMKII equations
-	dPb2 = 1e-3*(rcnCKib2 - rcnCKb2b + rcnCKt2b2);										// Pb2
-	dPb = 1e-3*(rcnCKib + rcnCKb2b - rcnCKbt);											// Pb
-	dPt = 1e-3*(rcnCKbt-rcnCKta-rcnCKtt2);												// Pt
-	dPt2 = 1e-3*(rcnCKtt2-rcnCKt2a-rcnCKt2b2);											// Pt2
-	dPa = 1e-3*(rcnCKta+rcnCKt2a-rcnCKai);												// Pa
-
-	// CaN equations
-	dCa4CaN = 1e-3*(rcnCa4CaN - rcn0CaN - rcn2CaN - rcn4CaN);							// Ca4CaN
-	dCaMCa4CaN = 1e-3*(rcn0CaN - rcn02CaN);												// CaMCa4CaN
-	dCa2CaMCa4CaN = 1e-3*(rcn2CaN+rcn02CaN-rcn24CaN);									// Ca2CaMCa4CaN
-	dCa4CaMCa4CaN = 1e-3*(rcn4CaN+rcn24CaN);											// Ca4CaMCa4CaN
-
-	// encode output array
-	finavalu[offset_1] = dCaM;
-	finavalu[offset_2] = dCa2CaM;
-	finavalu[offset_3] = dCa4CaM;
-	finavalu[offset_4] = dCaMB;
-	finavalu[offset_5] = dCa2CaMB;
-	finavalu[offset_6] = dCa4CaMB;
-	finavalu[offset_7] = dPb2;
-	finavalu[offset_8] = dPb;
-	finavalu[offset_9] = dPt;
-	finavalu[offset_10] = dPt2;
-	finavalu[offset_11] = dPa;
-	finavalu[offset_12] = dCa4CaN;
-	finavalu[offset_13] = dCaMCa4CaN;
-	finavalu[offset_14] = dCa2CaMCa4CaN;
-	finavalu[offset_15] = dCa4CaMCa4CaN;
-
-	// write to global variables for adjusting Ca buffering in EC coupling model
-	JCa = 1e-3*(2*CaMKIItot*(rcnCKtt2-rcnCKb2b) - 2*(rcn02+rcn24+rcn02B+rcn24B+rcnCa4CaN+rcn02CaN+rcn24CaN)); // [uM/msec]
-
-	// return
-	return JCa;
-
-}
diff -ruN rodinia_3.1/openmp/myocyte/define.c rodinia_3.1_new/openmp/myocyte/define.c
--- rodinia_3.1/openmp/myocyte/define.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/define.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,10 +0,0 @@
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//	DEFINE / INCLUDE
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-
-#define fp float
-
-#define EQUATIONS 91
-#define PARAMETERS 16
diff -ruN rodinia_3.1/openmp/myocyte/ecc.c rodinia_3.1_new/openmp/myocyte/ecc.c
--- rodinia_3.1/openmp/myocyte/ecc.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/ecc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,945 +0,0 @@
-//=====================================================================
-//	MAIN FUNCTION
-//=====================================================================
-void ecc(	fp timeinst,
-				fp *initvalu,
-				int initvalu_offset,
-				fp *parameter,
-				int parameter_offset,
-				fp *finavalu){
-
-	//=====================================================================
-	//	VARIABLES
-	//=====================================================================
-
-	// initial data and output data variable references
-	int offset_1;
-	int offset_2;
-	int offset_3;
-	int offset_4;
-	int offset_5;
-	int offset_6;
-	int offset_7;
-	int offset_8;
-	int offset_9;
-	int offset_10;
-	int offset_11;
-	int offset_12;
-	int offset_13;
-	int offset_14;
-	int offset_15;
-	int offset_16;
-	int offset_17;
-	int offset_18;
-	int offset_19;
-	int offset_20;
-	int offset_21;
-	int offset_22;
-	int offset_23;
-	int offset_24;
-	int offset_25;
-	int offset_26;
-	int offset_27;
-	int offset_28;
-	int offset_29;
-	int offset_30;
-	int offset_31;
-	int offset_32;
-	int offset_33;
-	int offset_34;
-	int offset_35;
-	int offset_36;
-	int offset_37;
-	int offset_38;
-	int offset_39;
-	int offset_40;
-	int offset_41;
-	int offset_42;
-	int offset_43;
-	int offset_44;
-	int offset_45;
-	int offset_46;
-
-	// initial data variable references
-	int parameter_offset_1;
-
-	// decoded input initial data			// GET VARIABLES FROM MEMORY AND SAVE LOCALLY !!!!!!!!!!!!!!!!!!
-	fp initvalu_1;
-	fp initvalu_2;
-	fp initvalu_3;
-	fp initvalu_4;
-	fp initvalu_5;
-	fp initvalu_6;
-	fp initvalu_7;
-	fp initvalu_8;
-	fp initvalu_9;
-	fp initvalu_10;
-	fp initvalu_11;
-	fp initvalu_12;
-	fp initvalu_13;
-	fp initvalu_14;
-	fp initvalu_15;
-	fp initvalu_16;
-	fp initvalu_17;
-	fp initvalu_18;
-	fp initvalu_19;
-	fp initvalu_20;
-	fp initvalu_21;
-	fp initvalu_22;
-	fp initvalu_23;
-	fp initvalu_24;
-	fp initvalu_25;
-	fp initvalu_26;
-	fp initvalu_27;
-	fp initvalu_28;
-	fp initvalu_29;
-	fp initvalu_30;
-	fp initvalu_31;
-	fp initvalu_32;
-	fp initvalu_33;
-	fp initvalu_34;
-	fp initvalu_35;
-	fp initvalu_36;
-	fp initvalu_37;
-	fp initvalu_38;
-	fp initvalu_39;
-	fp initvalu_40;
-	fp initvalu_41;
-	fp initvalu_42;
-	fp initvalu_43;
-	fp initvalu_44;
-	fp initvalu_45;
-	fp initvalu_46;
-
-	// decoded input parameters
-	fp parameter_1;
-
-	// matlab constants undefined in c
-	fp pi;
-
-	// Constants
-	fp R;																			// [J/kmol*K]  
-	fp Frdy;																		// [C/mol]  
-	fp Temp;																		// [K] 310
-	fp FoRT;																		//
-	fp Cmem;																		// [F] membrane capacitance
-	fp Qpow;
-
-	// Cell geometry
-	fp cellLength;																	// cell length [um]
-	fp cellRadius;																	// cell radius [um]
-	fp junctionLength;																// junc length [um]
-	fp junctionRadius;																// junc radius [um]
-	fp distSLcyto;																	// dist. SL to cytosol [um]
-	fp distJuncSL;																	// dist. junc to SL [um]
-	fp DcaJuncSL;																	// Dca junc to SL [cm^2/sec]
-	fp DcaSLcyto;																	// Dca SL to cyto [cm^2/sec]
-	fp DnaJuncSL;																	// Dna junc to SL [cm^2/sec]
-	fp DnaSLcyto;																	// Dna SL to cyto [cm^2/sec] 
-	fp Vcell;																		// [L]
-	fp Vmyo; 
-	fp Vsr; 
-	fp Vsl; 
-	fp Vjunc; 
-	fp SAjunc;																		// [um^2]
-	fp SAsl;																		// [um^2]
-	fp J_ca_juncsl;																	// [L/msec]
-	fp J_ca_slmyo;																	// [L/msec]
-	fp J_na_juncsl;																	// [L/msec] 
-	fp J_na_slmyo;																	// [L/msec] 
-
-	// Fractional currents in compartments
-	fp Fjunc;   
-	fp Fsl;
-	fp Fjunc_CaL; 
-	fp Fsl_CaL;
-
-	// Fixed ion concentrations     
-	fp Cli;																			// Intracellular Cl  [mM]
-	fp Clo;																			// Extracellular Cl  [mM]
-	fp Ko;																			// Extracellular K   [mM]
-	fp Nao;																			// Extracellular Na  [mM]
-	fp Cao;																			// Extracellular Ca  [mM]
-	fp Mgi;																			// Intracellular Mg  [mM]
-
-	// Nernst Potentials
-	fp ena_junc;																	// [mV]
-	fp ena_sl;																		// [mV]
-	fp ek;																			// [mV]
-	fp eca_junc;																	// [mV]
-	fp eca_sl;																		// [mV]
-	fp ecl;																			// [mV]
-
-	// Na transport parameters
-	fp GNa;																			// [mS/uF]
-	fp GNaB;																		// [mS/uF] 
-	fp IbarNaK;																		// [uA/uF]
-	fp KmNaip;																		// [mM]
-	fp KmKo;																		// [mM]
-	fp Q10NaK;  
-	fp Q10KmNai;
-
-	// K current parameters
-	fp pNaK;      
-	fp GtoSlow;																		// [mS/uF] 
-	fp GtoFast;																		// [mS/uF] 
-	fp gkp;
-
-	// Cl current parameters
-	fp GClCa;																		// [mS/uF]
-	fp GClB;																		// [mS/uF]
-	fp KdClCa;																		// [mM]																// [mM]
-
-	// I_Ca parameters
-	fp pNa;																			// [cm/sec]
-	fp pCa;																			// [cm/sec]
-	fp pK;																			// [cm/sec]
-	fp KmCa;																		// [mM]
-	fp Q10CaL;       
-
-	// Ca transport parameters
-	fp IbarNCX;																		// [uA/uF]
-	fp KmCai;																		// [mM]
-	fp KmCao;																		// [mM]
-	fp KmNai;																		// [mM]
-	fp KmNao;																		// [mM]
-	fp ksat;																			// [none]  
-	fp nu;																			// [none]
-	fp Kdact;																		// [mM] 
-	fp Q10NCX;																		// [none]
-	fp IbarSLCaP;																	// [uA/uF]
-	fp KmPCa;																		// [mM] 
-	fp GCaB;																		// [uA/uF] 
-	fp Q10SLCaP;																	// [none]																	// [none]
-
-	// SR flux parameters
-	fp Q10SRCaP;																	// [none]
-	fp Vmax_SRCaP;																	// [mM/msec] (mmol/L cytosol/msec)
-	fp Kmf;																			// [mM]
-	fp Kmr;																			// [mM]L cytosol
-	fp hillSRCaP;																	// [mM]
-	fp ks;																			// [1/ms]      
-	fp koCa;																		// [mM^-2 1/ms]      
-	fp kom;																			// [1/ms]     
-	fp kiCa;																		// [1/mM/ms]
-	fp kim;																			// [1/ms]
-	fp ec50SR;																		// [mM]
-
-	// Buffering parameters
-	fp Bmax_Naj;																	// [mM] 
-	fp Bmax_Nasl;																	// [mM]
-	fp koff_na;																		// [1/ms]
-	fp kon_na;																		// [1/mM/ms]
-	fp Bmax_TnClow;																	// [mM], TnC low affinity
-	fp koff_tncl;																	// [1/ms] 
-	fp kon_tncl;																	// [1/mM/ms]
-	fp Bmax_TnChigh;																// [mM], TnC high affinity 
-	fp koff_tnchca;																	// [1/ms] 
-	fp kon_tnchca;																	// [1/mM/ms]
-	fp koff_tnchmg;																	// [1/ms] 
-	fp kon_tnchmg;																	// [1/mM/ms]
-	fp Bmax_CaM;																	// [mM], CaM buffering
-	fp koff_cam;																	// [1/ms] 
-	fp kon_cam;																		// [1/mM/ms]
-	fp Bmax_myosin;																	// [mM], Myosin buffering
-	fp koff_myoca;																	// [1/ms]
-	fp kon_myoca;																	// [1/mM/ms]
-	fp koff_myomg;																	// [1/ms]
-	fp kon_myomg;																	// [1/mM/ms]
-	fp Bmax_SR;																		// [mM] 
-	fp koff_sr;																		// [1/ms]
-	fp kon_sr;																		// [1/mM/ms]
-	fp Bmax_SLlowsl;																// [mM], SL buffering
-	fp Bmax_SLlowj;																	// [mM]    
-	fp koff_sll;																	// [1/ms]
-	fp kon_sll;																		// [1/mM/ms]
-	fp Bmax_SLhighsl;																// [mM] 
-	fp Bmax_SLhighj;																// [mM] 
-	fp koff_slh;																	// [1/ms]
-	fp kon_slh;																		// [1/mM/ms]
-	fp Bmax_Csqn;																	// 140e-3*Vmyo/Vsr; [mM] 
-	fp koff_csqn;																	// [1/ms] 
-	fp kon_csqn;																	// [1/mM/ms] 
-
-	// I_Na: Fast Na Current
-	fp am;
-	fp bm;
-	fp ah;
-	fp bh;
-	fp aj;
-	fp bj;
-	fp I_Na_junc;
-	fp I_Na_sl;
-	fp I_Na;
-
-	// I_nabk: Na Background Current
-	fp I_nabk_junc;
-	fp I_nabk_sl;
-	fp I_nabk;
-
-	// I_nak: Na/K Pump Current
-	fp sigma;
-	fp fnak;
-	fp I_nak_junc;
-	fp I_nak_sl;
-	fp I_nak;
-
-	// I_kr: Rapidly Activating K Current
-	fp gkr;
-	fp xrss;
-	fp tauxr;
-	fp rkr;
-	fp I_kr;
-
-	// I_ks: Slowly Activating K Current
-	fp pcaks_junc; 
-	fp pcaks_sl;  
-	fp gks_junc;
-	fp gks_sl; 
-	fp eks;	
-	fp xsss;
-	fp tauxs; 
-	fp I_ks_junc;
-	fp I_ks_sl;
-	fp I_ks;
-
-	// I_kp: Plateau K current
-	fp kp_kp;
-	fp I_kp_junc;
-	fp I_kp_sl;
-	fp I_kp;
-
-	// I_to: Transient Outward K Current (slow and fast components)
-	fp xtoss;
-	fp ytoss;
-	fp rtoss;
-	fp tauxtos;
-	fp tauytos;
-	fp taurtos; 
-	fp I_tos;	
-
-	//
-	fp tauxtof;
-	fp tauytof;
-	fp I_tof;
-	fp I_to;
-
-	// I_ki: Time-Independent K Current
-	fp aki;
-	fp bki;
-	fp kiss;
-	fp I_ki;
-
-	// I_ClCa: Ca-activated Cl Current, I_Clbk: background Cl Current
-	fp I_ClCa_junc;
-	fp I_ClCa_sl;
-	fp I_ClCa;
-	fp I_Clbk;
-
-	// I_Ca: L-type Calcium Current
-	fp dss;
-	fp taud;
-	fp fss;
-	fp tauf;
-
-	//
-	fp ibarca_j;
-	fp ibarca_sl;
-	fp ibark;
-	fp ibarna_j;
-	fp ibarna_sl;
-	fp I_Ca_junc;
-	fp I_Ca_sl;
-	fp I_Ca;
-	fp I_CaK;
-	fp I_CaNa_junc;
-	fp I_CaNa_sl;
-	fp I_CaNa;
-	fp I_Catot;
-
-	// I_ncx: Na/Ca Exchanger flux
-	fp Ka_junc;
-	fp Ka_sl;
-	fp s1_junc;
-	fp s1_sl;
-	fp s2_junc;
-	fp s3_junc;
-	fp s2_sl;
-	fp s3_sl;
-	fp I_ncx_junc;
-	fp I_ncx_sl;
-	fp I_ncx;
-
-	// I_pca: Sarcolemmal Ca Pump Current
-	fp I_pca_junc;
-	fp I_pca_sl;
-	fp I_pca;
-
-	// I_cabk: Ca Background Current
-	fp I_cabk_junc;
-	fp I_cabk_sl;
-	fp I_cabk;
-	
-	// SR fluxes: Calcium Release, SR Ca pump, SR Ca leak														
-	fp MaxSR;
-	fp MinSR;
-	fp kCaSR;
-	fp koSRCa;
-	fp kiSRCa;
-	fp RI;
-	fp J_SRCarel;																	// [mM/ms]
-	fp J_serca;
-	fp J_SRleak;																		//   [mM/ms]
-
-	// Cytosolic Ca Buffers
-	fp J_CaB_cytosol;
-
-	// Junctional and SL Ca Buffers
-	fp J_CaB_junction;
-	fp J_CaB_sl;
-
-	// SR Ca Concentrations
-	fp oneovervsr;
-
-	// Sodium Concentrations
-	fp I_Na_tot_junc;																// [uA/uF]
-	fp I_Na_tot_sl;																	// [uA/uF]
-	fp oneovervsl;
-
-	// Potassium Concentration
-	fp I_K_tot;
-
-	// Calcium Concentrations
-	fp I_Ca_tot_junc;																// [uA/uF]
-	fp I_Ca_tot_sl;																	// [uA/uF]
-	fp junc_sl;
-	fp sl_junc;
-	fp sl_myo;
-	fp myo_sl;
-
-	//	Simulation type													
-	int state;																			// 0-none; 1-pace; 2-vclamp
-	fp I_app;
-	fp V_hold;
-	fp V_test;
-	fp V_clamp;
-	fp R_clamp;
-	
-	//	Membrane Potential
-	fp I_Na_tot;																		// [uA/uF]
-	fp I_Cl_tot;																		// [uA/uF]
-	fp I_Ca_tot;
-	fp I_tot;
-
-	//=====================================================================
-	//	EXECUTION
-	//=====================================================================
-
-	// variable references
-	offset_1  = initvalu_offset;
-	offset_2  = initvalu_offset+1;
-	offset_3  = initvalu_offset+2;
-	offset_4  = initvalu_offset+3;
-	offset_5  = initvalu_offset+4;
-	offset_6  = initvalu_offset+5;
-	offset_7  = initvalu_offset+6;
-	offset_8  = initvalu_offset+7;
-	offset_9  = initvalu_offset+8;
-	offset_10 = initvalu_offset+9;
-	offset_11 = initvalu_offset+10;
-	offset_12 = initvalu_offset+11;
-	offset_13 = initvalu_offset+12;
-	offset_14 = initvalu_offset+13;
-	offset_15 = initvalu_offset+14;
-	offset_16 = initvalu_offset+15;
-	offset_17 = initvalu_offset+16;
-	offset_18 = initvalu_offset+17;
-	offset_19 = initvalu_offset+18;
-	offset_20 = initvalu_offset+19;
-	offset_21 = initvalu_offset+20;
-	offset_22 = initvalu_offset+21;
-	offset_23 = initvalu_offset+22;
-	offset_24 = initvalu_offset+23;
-	offset_25 = initvalu_offset+24;
-	offset_26 = initvalu_offset+25;
-	offset_27 = initvalu_offset+26;
-	offset_28 = initvalu_offset+27;
-	offset_29 = initvalu_offset+28;
-	offset_30 = initvalu_offset+29;
-	offset_31 = initvalu_offset+30;
-	offset_32 = initvalu_offset+31;
-	offset_33 = initvalu_offset+32;
-	offset_34 = initvalu_offset+33;
-	offset_35 = initvalu_offset+34;
-	offset_36 = initvalu_offset+35;
-	offset_37 = initvalu_offset+36;
-	offset_38 = initvalu_offset+37;
-	offset_39 = initvalu_offset+38;
-	offset_40 = initvalu_offset+39;
-	offset_41 = initvalu_offset+40;
-	offset_42 = initvalu_offset+41;
-	offset_43 = initvalu_offset+42;
-	offset_44 = initvalu_offset+43;
-	offset_45 = initvalu_offset+44;
-	offset_46 = initvalu_offset+45;
-	
-	// variable references
-	parameter_offset_1  = parameter_offset;
-
-	// decoded input initial data
-	initvalu_1  = initvalu[offset_1 ];
-	initvalu_2  = initvalu[offset_2 ];
-	initvalu_3  = initvalu[offset_3 ];
-	initvalu_4  = initvalu[offset_4 ];
-	initvalu_5  = initvalu[offset_5 ];
-	initvalu_6  = initvalu[offset_6 ];
-	initvalu_7  = initvalu[offset_7 ];
-	initvalu_8  = initvalu[offset_8 ];
-	initvalu_9  = initvalu[offset_9 ];
-	initvalu_10 = initvalu[offset_10];
-	initvalu_11 = initvalu[offset_11];
-	initvalu_12 = initvalu[offset_12];
-	initvalu_13 = initvalu[offset_13];
-	initvalu_14 = initvalu[offset_14];
-	initvalu_15 = initvalu[offset_15];
-	initvalu_16 = initvalu[offset_16];
-	initvalu_17 = initvalu[offset_17];
-	initvalu_18 = initvalu[offset_18];
-	initvalu_19 = initvalu[offset_19];
-	initvalu_20 = initvalu[offset_20];
-	initvalu_21 = initvalu[offset_21];
-	initvalu_22 = initvalu[offset_22];
-	initvalu_23 = initvalu[offset_23];
-	initvalu_24 = initvalu[offset_24];
-	initvalu_25 = initvalu[offset_25];
-	initvalu_26 = initvalu[offset_26];
-	initvalu_27 = initvalu[offset_27];
-	initvalu_28 = initvalu[offset_28];
-	initvalu_29 = initvalu[offset_29];
-	initvalu_30 = initvalu[offset_30];
-	initvalu_31 = initvalu[offset_31];
-	initvalu_32 = initvalu[offset_32];
-	initvalu_33 = initvalu[offset_33];
-	initvalu_34 = initvalu[offset_34];
-	initvalu_35 = initvalu[offset_35];
-	initvalu_36 = initvalu[offset_36];
-	initvalu_37 = initvalu[offset_37];
-	initvalu_38 = initvalu[offset_38];
-	initvalu_39 = initvalu[offset_39];
-	initvalu_40 = initvalu[offset_40];
-	initvalu_41 = initvalu[offset_41];
-	initvalu_42 = initvalu[offset_42];
-	initvalu_43 = initvalu[offset_43];
-	initvalu_44 = initvalu[offset_44];
-	initvalu_45 = initvalu[offset_45];
-	initvalu_46 = initvalu[offset_46];
-
-	// decoded input parameters
-	parameter_1 = parameter[parameter_offset_1];
-
-	// matlab constants undefined in c
-	pi = 3.1416;
-
-	// Constants
-	R = 8314;																			// [J/kmol*K]  
-	Frdy = 96485;																		// [C/mol]  
-	Temp = 310;																			// [K] 310
-	FoRT = Frdy/R/Temp;																	//
-	Cmem = 1.3810e-10;																	// [F] membrane capacitance
-	Qpow = (Temp-310)/10;
-
-	// Cell geometry
-	cellLength = 100;																	// cell length [um]
-	cellRadius = 10.25;																	// cell radius [um]
-	junctionLength = 160e-3;															// junc length [um]
-	junctionRadius = 15e-3;																// junc radius [um]
-	distSLcyto = 0.45;																	// dist. SL to cytosol [um]
-	distJuncSL = 0.5;																	// dist. junc to SL [um]
-	DcaJuncSL = 1.64e-6;																// Dca junc to SL [cm^2/sec]
-	DcaSLcyto = 1.22e-6;																// Dca SL to cyto [cm^2/sec]
-	DnaJuncSL = 1.09e-5;																// Dna junc to SL [cm^2/sec]
-	DnaSLcyto = 1.79e-5;																// Dna SL to cyto [cm^2/sec] 
-	Vcell = pi*pow(cellRadius,2)*cellLength*1e-15;											// [L]
-	Vmyo = 0.65*Vcell; 
-	Vsr = 0.035*Vcell; 
-	Vsl = 0.02*Vcell; 
-	Vjunc = 0.0539*0.01*Vcell; 
-	SAjunc = 20150*pi*2*junctionLength*junctionRadius;									// [um^2]
-	SAsl = pi*2*cellRadius*cellLength;													// [um^2]
-	J_ca_juncsl = 1/1.2134e12;															// [L/msec]
-	J_ca_slmyo = 1/2.68510e11;															// [L/msec]
-	J_na_juncsl = 1/(1.6382e12/3*100);													// [L/msec] 
-	J_na_slmyo = 1/(1.8308e10/3*100);													// [L/msec] 
-
-	// Fractional currents in compartments
-	Fjunc = 0.11;   
-	Fsl = 1-Fjunc;
-	Fjunc_CaL = 0.9; 
-	Fsl_CaL = 1-Fjunc_CaL;
-
-	// Fixed ion concentrations     
-	Cli = 15;																			// Intracellular Cl  [mM]
-	Clo = 150;																			// Extracellular Cl  [mM]
-	Ko = 5.4;																			// Extracellular K   [mM]
-	Nao = 140;																			// Extracellular Na  [mM]
-	Cao = 1.8;																			// Extracellular Ca  [mM]
-	Mgi = 1;																			// Intracellular Mg  [mM]
-
-	// Nernst Potentials
-	ena_junc = (1/FoRT)*log(Nao/initvalu_32);													// [mV]
-	ena_sl = (1/FoRT)*log(Nao/initvalu_33);													// [mV]
-	ek = (1/FoRT)*log(Ko/initvalu_35);														// [mV]
-	eca_junc = (1/FoRT/2)*log(Cao/initvalu_36);												// [mV]
-	eca_sl = (1/FoRT/2)*log(Cao/initvalu_37);													// [mV]
-	ecl = (1/FoRT)*log(Cli/Clo);														// [mV]
-
-	// Na transport parameters
-	GNa =  16.0;																		// [mS/uF]
-	GNaB = 0.297e-3;																	// [mS/uF] 
-	IbarNaK = 1.90719;																	// [uA/uF]
-	KmNaip = 11;																		// [mM]
-	KmKo = 1.5;																			// [mM]
-	Q10NaK = 1.63;  
-	Q10KmNai = 1.39;
-
-	// K current parameters
-	pNaK = 0.01833;      
-	GtoSlow = 0.06;																		// [mS/uF] 
-	GtoFast = 0.02;																		// [mS/uF] 
-	gkp = 0.001;
-
-	// Cl current parameters
-	GClCa = 0.109625;																	// [mS/uF]
-	GClB = 9e-3;																		// [mS/uF]
-	KdClCa = 100e-3;																	// [mM]
-
-	// I_Ca parameters
-	pNa = 1.5e-8;																		// [cm/sec]
-	pCa = 5.4e-4;																		// [cm/sec]
-	pK = 2.7e-7;																		// [cm/sec]
-	KmCa = 0.6e-3;																		// [mM]
-	Q10CaL = 1.8;       
-
-	// Ca transport parameters
-	IbarNCX = 9.0;																		// [uA/uF]
-	KmCai = 3.59e-3;																	// [mM]
-	KmCao = 1.3;																		// [mM]
-	KmNai = 12.29;																		// [mM]
-	KmNao = 87.5;																		// [mM]
-	ksat = 0.27;																		// [none]  
-	nu = 0.35;																			// [none]
-	Kdact = 0.256e-3;																	// [mM] 
-	Q10NCX = 1.57;																		// [none]
-	IbarSLCaP = 0.0673;																	// [uA/uF]
-	KmPCa = 0.5e-3;																		// [mM] 
-	GCaB = 2.513e-4;																	// [uA/uF] 
-	Q10SLCaP = 2.35;																	// [none]
-
-	// SR flux parameters
-	Q10SRCaP = 2.6;																		// [none]
-	Vmax_SRCaP = 2.86e-4;																// [mM/msec] (mmol/L cytosol/msec)
-	Kmf = 0.246e-3;																		// [mM]
-	Kmr = 1.7;																			// [mM]L cytosol
-	hillSRCaP = 1.787;																	// [mM]
-	ks = 25;																			// [1/ms]      
-	koCa = 10;																			// [mM^-2 1/ms]      
-	kom = 0.06;																			// [1/ms]     
-	kiCa = 0.5;																			// [1/mM/ms]
-	kim = 0.005;																		// [1/ms]
-	ec50SR = 0.45;																		// [mM]
-
-	// Buffering parameters
-	Bmax_Naj = 7.561;																	// [mM] 
-	Bmax_Nasl = 1.65;																	// [mM]
-	koff_na = 1e-3;																		// [1/ms]
-	kon_na = 0.1e-3;																	// [1/mM/ms]
-	Bmax_TnClow = 70e-3;																// [mM], TnC low affinity
-	koff_tncl = 19.6e-3;																// [1/ms] 
-	kon_tncl = 32.7;																	// [1/mM/ms]
-	Bmax_TnChigh = 140e-3;																// [mM], TnC high affinity 
-	koff_tnchca = 0.032e-3;																// [1/ms] 
-	kon_tnchca = 2.37;																	// [1/mM/ms]
-	koff_tnchmg = 3.33e-3;																// [1/ms] 
-	kon_tnchmg = 3e-3;																	// [1/mM/ms]
-	Bmax_CaM = 24e-3;																	// [mM], CaM buffering
-	koff_cam = 238e-3;																	// [1/ms] 
-	kon_cam = 34;																		// [1/mM/ms]
-	Bmax_myosin = 140e-3;																// [mM], Myosin buffering
-	koff_myoca = 0.46e-3;																// [1/ms]
-	kon_myoca = 13.8;																	// [1/mM/ms]
-	koff_myomg = 0.057e-3;																// [1/ms]
-	kon_myomg = 0.0157;																	// [1/mM/ms]
-	Bmax_SR = 19*0.9e-3;																	// [mM] 
-	koff_sr = 60e-3;																	// [1/ms]
-	kon_sr = 100;																		// [1/mM/ms]
-	Bmax_SLlowsl = 37.38e-3*Vmyo/Vsl;													// [mM], SL buffering
-	Bmax_SLlowj = 4.62e-3*Vmyo/Vjunc*0.1;												// [mM]    
-	koff_sll = 1300e-3;																	// [1/ms]
-	kon_sll = 100;																		// [1/mM/ms]
-	Bmax_SLhighsl = 13.35e-3*Vmyo/Vsl;													// [mM] 
-	Bmax_SLhighj = 1.65e-3*Vmyo/Vjunc*0.1;												// [mM] 
-	koff_slh = 30e-3;																	// [1/ms]
-	kon_slh = 100;																		// [1/mM/ms]
-	Bmax_Csqn = 2.7;																	// 140e-3*Vmyo/Vsr; [mM] 
-	koff_csqn = 65;																		// [1/ms] 
-	kon_csqn = 100;																		// [1/mM/ms] 
-
-	// I_Na: Fast Na Current
-	am = 0.32*(initvalu_39+47.13)/(1-exp(-0.1*(initvalu_39+47.13)));
-	bm = 0.08*exp(-initvalu_39/11);
-	if(initvalu_39 >= -40){
-		ah = 0; aj = 0;
-		bh = 1/(0.13*(1+exp(-(initvalu_39+10.66)/11.1)));
-		bj = 0.3*exp(-2.535e-7*initvalu_39)/(1+exp(-0.1*(initvalu_39+32)));
-	}
-	else{
-		ah = 0.135*exp((80+initvalu_39)/-6.8);
-		bh = 3.56*exp(0.079*initvalu_39)+3.1e5*exp(0.35*initvalu_39);
-		aj = (-127140*exp(0.2444*initvalu_39)-3.474e-5*exp(-0.04391*initvalu_39))*(initvalu_39+37.78)/(1+exp(0.311*(initvalu_39+79.23)));
-		bj = 0.1212*exp(-0.01052*initvalu_39)/(1+exp(-0.1378*(initvalu_39+40.14)));
-	}
-	finavalu[offset_1] = am*(1-initvalu_1)-bm*initvalu_1;
-	finavalu[offset_2] = ah*(1-initvalu_2)-bh*initvalu_2;
-	finavalu[offset_3] = aj*(1-initvalu_3)-bj*initvalu_3;
-	I_Na_junc = Fjunc*GNa*pow(initvalu_1,3)*initvalu_2*initvalu_3*(initvalu_39-ena_junc);
-	I_Na_sl = Fsl*GNa*pow(initvalu_1,3)*initvalu_2*initvalu_3*(initvalu_39-ena_sl);
-	I_Na = I_Na_junc+I_Na_sl;
-
-	// I_nabk: Na Background Current
-	I_nabk_junc = Fjunc*GNaB*(initvalu_39-ena_junc);
-	I_nabk_sl = Fsl*GNaB*(initvalu_39-ena_sl);
-	I_nabk = I_nabk_junc+I_nabk_sl;
-
-	// I_nak: Na/K Pump Current
-	sigma = (exp(Nao/67.3)-1)/7;
-	fnak = 1/(1+0.1245*exp(-0.1*initvalu_39*FoRT)+0.0365*sigma*exp(-initvalu_39*FoRT));
-	I_nak_junc = Fjunc*IbarNaK*fnak*Ko /(1+pow((KmNaip/initvalu_32),4)) /(Ko+KmKo);
-	I_nak_sl = Fsl*IbarNaK*fnak*Ko /(1+pow((KmNaip/initvalu_33),4)) /(Ko+KmKo);
-	I_nak = I_nak_junc+I_nak_sl;
-
-	// I_kr: Rapidly Activating K Current
-	gkr = 0.03*sqrt(Ko/5.4);
-	xrss = 1/(1+exp(-(initvalu_39+50)/7.5));
-	tauxr = 1/(0.00138*(initvalu_39+7)/(1-exp(-0.123*(initvalu_39+7)))+6.1e-4*(initvalu_39+10)/(exp(0.145*(initvalu_39+10))-1));
-	finavalu[offset_12] = (xrss-initvalu_12)/tauxr;
-	rkr = 1/(1+exp((initvalu_39+33)/22.4));
-	I_kr = gkr*initvalu_12*rkr*(initvalu_39-ek);
-
-	// I_ks: Slowly Activating K Current
-	pcaks_junc = -log10(initvalu_36)+3.0; 
-	pcaks_sl = -log10(initvalu_37)+3.0;  
-	gks_junc = 0.07*(0.057 +0.19/(1+ exp((-7.2+pcaks_junc)/0.6)));
-	gks_sl = 0.07*(0.057 +0.19/(1+ exp((-7.2+pcaks_sl)/0.6))); 
-	eks = (1/FoRT)*log((Ko+pNaK*Nao)/(initvalu_35+pNaK*initvalu_34));	
-	xsss = 1/(1+exp(-(initvalu_39-1.5)/16.7));
-	tauxs = 1/(7.19e-5*(initvalu_39+30)/(1-exp(-0.148*(initvalu_39+30)))+1.31e-4*(initvalu_39+30)/(exp(0.0687*(initvalu_39+30))-1)); 
-	finavalu[offset_13] = (xsss-initvalu_13)/tauxs;
-	I_ks_junc = Fjunc*gks_junc*pow(initvalu_12,2)*(initvalu_39-eks);
-	I_ks_sl = Fsl*gks_sl*pow(initvalu_13,2)*(initvalu_39-eks);
-	I_ks = I_ks_junc+I_ks_sl;
-
-	// I_kp: Plateau K current
-	kp_kp = 1/(1+exp(7.488-initvalu_39/5.98));
-	I_kp_junc = Fjunc*gkp*kp_kp*(initvalu_39-ek);
-	I_kp_sl = Fsl*gkp*kp_kp*(initvalu_39-ek);
-	I_kp = I_kp_junc+I_kp_sl;
-
-	// I_to: Transient Outward K Current (slow and fast components)
-	xtoss = 1/(1+exp(-(initvalu_39+3.0)/15));
-	ytoss = 1/(1+exp((initvalu_39+33.5)/10));
-	rtoss = 1/(1+exp((initvalu_39+33.5)/10));
-	tauxtos = 9/(1+exp((initvalu_39+3.0)/15))+0.5;
-	tauytos = 3e3/(1+exp((initvalu_39+60.0)/10))+30;
-	taurtos = 2800/(1+exp((initvalu_39+60.0)/10))+220; 
-	finavalu[offset_8] = (xtoss-initvalu_8)/tauxtos;
-	finavalu[offset_9] = (ytoss-initvalu_9)/tauytos;
-	finavalu[offset_40]= (rtoss-initvalu_40)/taurtos; 
-	I_tos = GtoSlow*initvalu_8*(initvalu_9+0.5*initvalu_40)*(initvalu_39-ek);									// [uA/uF]
-
-	//
-	tauxtof = 3.5*exp(-initvalu_39*initvalu_39/30/30)+1.5;
-	tauytof = 20.0/(1+exp((initvalu_39+33.5)/10))+20.0;
-	finavalu[offset_10] = (xtoss-initvalu_10)/tauxtof;
-	finavalu[offset_11] = (ytoss-initvalu_11)/tauytof;
-	I_tof = GtoFast*initvalu_10*initvalu_11*(initvalu_39-ek);
-	I_to = I_tos + I_tof;
-
-	// I_ki: Time-Independent K Current
-	aki = 1.02/(1+exp(0.2385*(initvalu_39-ek-59.215)));
-	bki =(0.49124*exp(0.08032*(initvalu_39+5.476-ek)) + exp(0.06175*(initvalu_39-ek-594.31))) /(1 + exp(-0.5143*(initvalu_39-ek+4.753)));
-	kiss = aki/(aki+bki);
-	I_ki = 0.9*sqrt(Ko/5.4)*kiss*(initvalu_39-ek);
-
-	// I_ClCa: Ca-activated Cl Current, I_Clbk: background Cl Current
-	I_ClCa_junc = Fjunc*GClCa/(1+KdClCa/initvalu_36)*(initvalu_39-ecl);
-	I_ClCa_sl = Fsl*GClCa/(1+KdClCa/initvalu_37)*(initvalu_39-ecl);
-	I_ClCa = I_ClCa_junc+I_ClCa_sl;
-	I_Clbk = GClB*(initvalu_39-ecl);
-
-	// I_Ca: L-type Calcium Current
-	dss = 1/(1+exp(-(initvalu_39+14.5)/6.0));
-	taud = dss*(1-exp(-(initvalu_39+14.5)/6.0))/(0.035*(initvalu_39+14.5));
-	fss = 1/(1+exp((initvalu_39+35.06)/3.6))+0.6/(1+exp((50-initvalu_39)/20));
-	tauf = 1/(0.0197*exp(-pow(0.0337*(initvalu_39+14.5),2))+0.02);
-	finavalu[offset_4] = (dss-initvalu_4)/taud;
-	finavalu[offset_5] = (fss-initvalu_5)/tauf;
-	finavalu[offset_6] = 1.7*initvalu_36*(1-initvalu_6)-11.9e-3*initvalu_6;											// fCa_junc  
-	finavalu[offset_7] = 1.7*initvalu_37*(1-initvalu_7)-11.9e-3*initvalu_7;											// fCa_sl
-
-	//
-	ibarca_j = pCa*4*(initvalu_39*Frdy*FoRT) * (0.341*initvalu_36*exp(2*initvalu_39*FoRT)-0.341*Cao) /(exp(2*initvalu_39*FoRT)-1);
-	ibarca_sl = pCa*4*(initvalu_39*Frdy*FoRT) * (0.341*initvalu_37*exp(2*initvalu_39*FoRT)-0.341*Cao) /(exp(2*initvalu_39*FoRT)-1);
-	ibark = pK*(initvalu_39*Frdy*FoRT)*(0.75*initvalu_35*exp(initvalu_39*FoRT)-0.75*Ko) /(exp(initvalu_39*FoRT)-1);
-	ibarna_j = pNa*(initvalu_39*Frdy*FoRT) *(0.75*initvalu_32*exp(initvalu_39*FoRT)-0.75*Nao)  /(exp(initvalu_39*FoRT)-1);
-	ibarna_sl = pNa*(initvalu_39*Frdy*FoRT) *(0.75*initvalu_33*exp(initvalu_39*FoRT)-0.75*Nao)  /(exp(initvalu_39*FoRT)-1);
-	I_Ca_junc = (Fjunc_CaL*ibarca_j*initvalu_4*initvalu_5*(1-initvalu_6)*pow(Q10CaL,Qpow))*0.45;
-	I_Ca_sl = (Fsl_CaL*ibarca_sl*initvalu_4*initvalu_5*(1-initvalu_7)*pow(Q10CaL,Qpow))*0.45;
-	I_Ca = I_Ca_junc+I_Ca_sl;
-	finavalu[offset_43]=-I_Ca*Cmem/(Vmyo*2*Frdy)*1e3;
-	I_CaK = (ibark*initvalu_4*initvalu_5*(Fjunc_CaL*(1-initvalu_6)+Fsl_CaL*(1-initvalu_7))*pow(Q10CaL,Qpow))*0.45;
-	I_CaNa_junc = (Fjunc_CaL*ibarna_j*initvalu_4*initvalu_5*(1-initvalu_6)*pow(Q10CaL,Qpow))*0.45;
-	I_CaNa_sl = (Fsl_CaL*ibarna_sl*initvalu_4*initvalu_5*(1-initvalu_7)*pow(Q10CaL,Qpow))*0.45;
-	I_CaNa = I_CaNa_junc+I_CaNa_sl;
-	I_Catot = I_Ca+I_CaK+I_CaNa;
-
-	// I_ncx: Na/Ca Exchanger flux
-	Ka_junc = 1/(1+pow((Kdact/initvalu_36),3));
-	Ka_sl = 1/(1+pow((Kdact/initvalu_37),3));
-	s1_junc = exp(nu*initvalu_39*FoRT)*pow(initvalu_32,3)*Cao;
-	s1_sl = exp(nu*initvalu_39*FoRT)*pow(initvalu_33,3)*Cao;
-	s2_junc = exp((nu-1)*initvalu_39*FoRT)*pow(Nao,3)*initvalu_36;
-	s3_junc = (KmCai*pow(Nao,3)*(1+pow((initvalu_32/KmNai),3))+pow(KmNao,3)*initvalu_36+ pow(KmNai,3)*Cao*(1+initvalu_36/KmCai)+KmCao*pow(initvalu_32,3)+pow(initvalu_32,3)*Cao+pow(Nao,3)*initvalu_36)*(1+ksat*exp((nu-1)*initvalu_39*FoRT));
-	s2_sl = exp((nu-1)*initvalu_39*FoRT)*pow(Nao,3)*initvalu_37;
-	s3_sl = (KmCai*pow(Nao,3)*(1+pow((initvalu_33/KmNai),3)) + pow(KmNao,3)*initvalu_37+pow(KmNai,3)*Cao*(1+initvalu_37/KmCai)+KmCao*pow(initvalu_33,3)+pow(initvalu_33,3)*Cao+pow(Nao,3)*initvalu_37)*(1+ksat*exp((nu-1)*initvalu_39*FoRT));
-	I_ncx_junc = Fjunc*IbarNCX*pow(Q10NCX,Qpow)*Ka_junc*(s1_junc-s2_junc)/s3_junc;
-	I_ncx_sl = Fsl*IbarNCX*pow(Q10NCX,Qpow)*Ka_sl*(s1_sl-s2_sl)/s3_sl;
-	I_ncx = I_ncx_junc+I_ncx_sl;
-	finavalu[offset_45]=2*I_ncx*Cmem/(Vmyo*2*Frdy)*1e3;
-
-	// I_pca: Sarcolemmal Ca Pump Current
-	I_pca_junc = 	Fjunc * 
-					pow(Q10SLCaP,Qpow) * 
-					IbarSLCaP * 
-					pow(initvalu_36,1.6) /
-					(pow(KmPCa,1.6) + pow(initvalu_36,1.6));
-	I_pca_sl = 	Fsl * 
-				pow(Q10SLCaP,Qpow) * 
-				IbarSLCaP * 
-				pow(initvalu_37,1.6) / 
-				(pow(KmPCa,1.6) + pow(initvalu_37,1.6));
-	I_pca = I_pca_junc+I_pca_sl;
-	finavalu[offset_44]=-I_pca*Cmem/(Vmyo*2*Frdy)*1e3;
-
-	// I_cabk: Ca Background Current
-	I_cabk_junc = Fjunc*GCaB*(initvalu_39-eca_junc);
-	I_cabk_sl = Fsl*GCaB*(initvalu_39-eca_sl);
-	I_cabk = I_cabk_junc+I_cabk_sl;
-	finavalu[offset_46]=-I_cabk*Cmem/(Vmyo*2*Frdy)*1e3;
-	
-	// SR fluxes: Calcium Release, SR Ca pump, SR Ca leak														
-	MaxSR = 15; 
-	MinSR = 1;
-	kCaSR = MaxSR - (MaxSR-MinSR)/(1+pow(ec50SR/initvalu_31,2.5));
-	koSRCa = koCa/kCaSR;
-	kiSRCa = kiCa*kCaSR;
-	RI = 1-initvalu_14-initvalu_15-initvalu_16;
-	finavalu[offset_14] = (kim*RI-kiSRCa*initvalu_36*initvalu_14)-(koSRCa*pow(initvalu_36,2)*initvalu_14-kom*initvalu_15);			// R
-	finavalu[offset_15] = (koSRCa*pow(initvalu_36,2)*initvalu_14-kom*initvalu_15)-(kiSRCa*initvalu_36*initvalu_15-kim*initvalu_16);			// O
-	finavalu[offset_16] = (kiSRCa*initvalu_36*initvalu_15-kim*initvalu_16)-(kom*initvalu_16-koSRCa*pow(initvalu_36,2)*RI);			// I
-	J_SRCarel = ks*initvalu_15*(initvalu_31-initvalu_36);													// [mM/ms]
-	J_serca = pow(Q10SRCaP,Qpow)*Vmax_SRCaP*(pow((initvalu_38/Kmf),hillSRCaP)-pow((initvalu_31/Kmr),hillSRCaP))
-										 /(1+pow((initvalu_38/Kmf),hillSRCaP)+pow((initvalu_31/Kmr),hillSRCaP));
-	J_SRleak = 5.348e-6*(initvalu_31-initvalu_36);													//   [mM/ms]
-
-	// Sodium and Calcium Buffering														
-	finavalu[offset_17] = kon_na*initvalu_32*(Bmax_Naj-initvalu_17)-koff_na*initvalu_17;								// NaBj      [mM/ms]
-	finavalu[offset_18] = kon_na*initvalu_33*(Bmax_Nasl-initvalu_18)-koff_na*initvalu_18;							// NaBsl     [mM/ms]
-
-	// Cytosolic Ca Buffers
-	finavalu[offset_19] = kon_tncl*initvalu_38*(Bmax_TnClow-initvalu_19)-koff_tncl*initvalu_19;						// TnCL      [mM/ms]
-	finavalu[offset_20] = kon_tnchca*initvalu_38*(Bmax_TnChigh-initvalu_20-initvalu_21)-koff_tnchca*initvalu_20;			// TnCHc     [mM/ms]
-	finavalu[offset_21] = kon_tnchmg*Mgi*(Bmax_TnChigh-initvalu_20-initvalu_21)-koff_tnchmg*initvalu_21;				// TnCHm     [mM/ms]
-	finavalu[offset_22] = 0;																		// CaM       [mM/ms]
-	finavalu[offset_23] = kon_myoca*initvalu_38*(Bmax_myosin-initvalu_23-initvalu_24)-koff_myoca*initvalu_23;				// Myosin_ca [mM/ms]
-	finavalu[offset_24] = kon_myomg*Mgi*(Bmax_myosin-initvalu_23-initvalu_24)-koff_myomg*initvalu_24;				// Myosin_mg [mM/ms]
-	finavalu[offset_25] = kon_sr*initvalu_38*(Bmax_SR-initvalu_25)-koff_sr*initvalu_25;								// SRB       [mM/ms]
-	J_CaB_cytosol = finavalu[offset_19] + finavalu[offset_20] + finavalu[offset_21] + finavalu[offset_22] + finavalu[offset_23] + finavalu[offset_24] + finavalu[offset_25];
-
-	// Junctional and SL Ca Buffers
-	finavalu[offset_26] = kon_sll*initvalu_36*(Bmax_SLlowj-initvalu_26)-koff_sll*initvalu_26;						// SLLj      [mM/ms]
-	finavalu[offset_27] = kon_sll*initvalu_37*(Bmax_SLlowsl-initvalu_27)-koff_sll*initvalu_27;						// SLLsl     [mM/ms]
-	finavalu[offset_28] = kon_slh*initvalu_36*(Bmax_SLhighj-initvalu_28)-koff_slh*initvalu_28;						// SLHj      [mM/ms]
-	finavalu[offset_29] = kon_slh*initvalu_37*(Bmax_SLhighsl-initvalu_29)-koff_slh*initvalu_29;						// SLHsl     [mM/ms]
-	J_CaB_junction = finavalu[offset_26]+finavalu[offset_28];
-	J_CaB_sl = finavalu[offset_27]+finavalu[offset_29];
-
-	// SR Ca Concentrations
-	finavalu[offset_30] = kon_csqn*initvalu_31*(Bmax_Csqn-initvalu_30)-koff_csqn*initvalu_30;						// Csqn      [mM/ms]
-	oneovervsr = 1/Vsr;
-	finavalu[offset_31] = J_serca*Vmyo*oneovervsr-(J_SRleak*Vmyo*oneovervsr+J_SRCarel)-finavalu[offset_30];   // Ca_sr     [mM/ms] %Ratio 3 leak current
-
-	// Sodium Concentrations
-	I_Na_tot_junc = I_Na_junc+I_nabk_junc+3*I_ncx_junc+3*I_nak_junc+I_CaNa_junc;		// [uA/uF]
-	I_Na_tot_sl = I_Na_sl+I_nabk_sl+3*I_ncx_sl+3*I_nak_sl+I_CaNa_sl;					// [uA/uF]
-	finavalu[offset_32] = -I_Na_tot_junc*Cmem/(Vjunc*Frdy)+J_na_juncsl/Vjunc*(initvalu_33-initvalu_32)-finavalu[offset_17];
-	oneovervsl = 1/Vsl;
-	finavalu[offset_33] = -I_Na_tot_sl*Cmem*oneovervsl/Frdy+J_na_juncsl*oneovervsl*(initvalu_32-initvalu_33)+J_na_slmyo*oneovervsl*(initvalu_34-initvalu_33)-finavalu[offset_18];
-	finavalu[offset_34] = J_na_slmyo/Vmyo*(initvalu_33-initvalu_34);											// [mM/msec] 
-
-	// Potassium Concentration
-	I_K_tot = I_to+I_kr+I_ks+I_ki-2*I_nak+I_CaK+I_kp;									// [uA/uF]
-	finavalu[offset_35] = 0;															// [mM/msec]
-
-	// Calcium Concentrations
-	I_Ca_tot_junc = I_Ca_junc+I_cabk_junc+I_pca_junc-2*I_ncx_junc;						// [uA/uF]
-	I_Ca_tot_sl = I_Ca_sl+I_cabk_sl+I_pca_sl-2*I_ncx_sl;								// [uA/uF]
-	finavalu[offset_36] = -I_Ca_tot_junc*Cmem/(Vjunc*2*Frdy)+J_ca_juncsl/Vjunc*(initvalu_37-initvalu_36)
-	         - J_CaB_junction+(J_SRCarel)*Vsr/Vjunc+J_SRleak*Vmyo/Vjunc;				// Ca_j
-	finavalu[offset_37] = -I_Ca_tot_sl*Cmem/(Vsl*2*Frdy)+J_ca_juncsl/Vsl*(initvalu_36-initvalu_37)
-	         + J_ca_slmyo/Vsl*(initvalu_38-initvalu_37)-J_CaB_sl;									// Ca_sl
-	finavalu[offset_38] = -J_serca-J_CaB_cytosol +J_ca_slmyo/Vmyo*(initvalu_37-initvalu_38);
-	junc_sl=J_ca_juncsl/Vsl*(initvalu_36-initvalu_37);
-	sl_junc=J_ca_juncsl/Vjunc*(initvalu_37-initvalu_36);
-	sl_myo=J_ca_slmyo/Vsl*(initvalu_38-initvalu_37);
-	myo_sl=J_ca_slmyo/Vmyo*(initvalu_37-initvalu_38);
-
-	// Simulation type													
-	state = 1;																			
-	switch(state){
-		case 0:
-			I_app = 0;
-			break;
-		case 1:																			// pace w/ current injection at cycleLength 'cycleLength'
-			if(fmod(timeinst,parameter_1) <= 5){
-				I_app = 9.5;
-			}
-			else{
-				I_app = 0.0;
-			}
-			break;
-		case 2:     
-			V_hold = -55;
-			V_test = 0;
-			if(timeinst>0.5 & timeinst<200.5){
-				V_clamp = V_test;
-			}
-			else{
-				V_clamp = V_hold;
-			}
-			R_clamp = 0.04;
-			I_app = (V_clamp-initvalu_39)/R_clamp;
-			break;
-	} 
-
-	// Membrane Potential												
-	I_Na_tot = I_Na_tot_junc + I_Na_tot_sl;												// [uA/uF]
-	I_Cl_tot = I_ClCa+I_Clbk;															// [uA/uF]
-	I_Ca_tot = I_Ca_tot_junc+I_Ca_tot_sl;
-	I_tot = I_Na_tot+I_Cl_tot+I_Ca_tot+I_K_tot;
-	finavalu[offset_39] = -(I_tot-I_app);
-
-	// Set unused output values to 0 (MATLAB does it by default)
-	finavalu[offset_41] = 0;
-	finavalu[offset_42] = 0;
-
-}
diff -ruN rodinia_3.1/openmp/myocyte/embedded_fehlberg_7_8.c rodinia_3.1_new/openmp/myocyte/embedded_fehlberg_7_8.c
--- rodinia_3.1/openmp/myocyte/embedded_fehlberg_7_8.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/embedded_fehlberg_7_8.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,480 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-// File: embedded_fehlberg_7_8.c                                              //
-// Routines:                                                                  //
-//    Embedded_Fehlberg_7_8                                                   //
-////////////////////////////////////////////////////////////////////////////////
-
-////////////////////////////////////////////////////////////////////////////////
-//                                                                            //
-//  Description:                                                              //
-//     The Runge-Kutta-Fehlberg method is an adaptive procedure for approxi-  //
-//     mating the solution of the differential equation y'(x) = f(x,y) with   //
-//     initial condition y(x0) = c.  This implementation evaluates f(x,y)     //
-//     thirteen times per step using embedded seventh order and eight order   //
-//     Runge-Kutta estimates to estimate the not only the solution but also   //
-//     the error.                                                             //
-//     The next step size is then calculated using the preassigned tolerance  //
-//     and error estimate.                                                    //
-//     For step i+1,                                                          //
-//        y[i+1] = y[i] +  h * (41/840 * k1 + 34/105 * finavalu_temp[5] + 9/35 * finavalu_temp[6]         //
-//                        + 9/35 * finavalu_temp[7] + 9/280 * finavalu_temp[8] + 9/280 finavalu_temp[9] + 41/840 finavalu_temp[10] ) //
-//     where                                                                  //
-//     k1 = f( x[i],y[i] ),                                                   //
-//     finavalu_temp[1] = f( x[i]+2h/27, y[i] + 2h*k1/27),                                  //
-//     finavalu_temp[2] = f( x[i]+h/9, y[i]+h/36*( k1 + 3 finavalu_temp[1]) ),                            //
-//     finavalu_temp[3] = f( x[i]+h/6, y[i]+h/24*( k1 + 3 finavalu_temp[2]) ),                            //
-//     finavalu_temp[4] = f( x[i]+5h/12, y[i]+h/48*(20 k1 - 75 finavalu_temp[2] + 75 finavalu_temp[3])),                //
-//     finavalu_temp[5] = f( x[i]+h/2, y[i]+h/20*( k1 + 5 finavalu_temp[3] + 4 finavalu_temp[4] ) ),                    //
-//     finavalu_temp[6] = f( x[i]+5h/6, y[i]+h/108*( -25 k1 + 125 finavalu_temp[3] - 260 finavalu_temp[4] + 250 finavalu_temp[5] ) ), //
-//     finavalu_temp[7] = f( x[i]+h/6, y[i]+h*( 31/300 k1 + 61/225 finavalu_temp[4] - 2/9 finavalu_temp[5]              //
-//                                                            + 13/900 finavalu_temp[6]) )  //
-//     finavalu_temp[8] = f( x[i]+2h/3, y[i]+h*( 2 k1 - 53/6 finavalu_temp[3] + 704/45 finavalu_temp[4] - 107/9 finavalu_temp[5]      //
-//                                                      + 67/90 finavalu_temp[6] + 3 finavalu_temp[7]) ), //
-//     finavalu_temp[9] = f( x[i]+h/3, y[i]+h*( -91/108 k1 + 23/108 finavalu_temp[3] - 976/135 finavalu_temp[4]        //
-//                             + 311/54 finavalu_temp[5] - 19/60 finavalu_temp[6] + 17/6 finavalu_temp[7] - 1/12 finavalu_temp[8]) ), //
-//     finavalu_temp[10] = f( x[i]+h, y[i]+h*( 2383/4100 k1 - 341/164 finavalu_temp[3] + 4496/1025 finavalu_temp[4]     //
-//          - 301/82 finavalu_temp[5] + 2133/4100 finavalu_temp[6] + 45/82 finavalu_temp[7] + 45/164 finavalu_temp[8] + 18/41 finavalu_temp[9]) )  //
-//     finavalu_temp[11] = f( x[i], y[i]+h*( 3/205 k1 - 6/41 finavalu_temp[5] - 3/205 finavalu_temp[6] - 3/41 finavalu_temp[7]        //
-//                                                   + 3/41 finavalu_temp[8] + 6/41 finavalu_temp[9]) )  //
-//     finavalu_temp[12] = f( x[i]+h, y[i]+h*( -1777/4100 k1 - 341/164 finavalu_temp[3] + 4496/1025 finavalu_temp[4]    //
-//                      - 289/82 finavalu_temp[5] + 2193/4100 finavalu_temp[6] + 51/82 finavalu_temp[7] + 33/164 finavalu_temp[8] +   //
-//                                                        12/41 finavalu_temp[9] + finavalu_temp[11]) )  //
-//     x[i+1] = x[i] + h.                                                     //
-//                                                                            //
-//     The error is estimated to be                                           //
-//        err = -41/840 * h * ( k1 + finavalu_temp[10] - finavalu_temp[11] - finavalu_temp[12])                         //
-//     The step size h is then scaled by the scale factor                     //
-//         scale = 0.8 * | epsilon * y[i] / [err * (xmax - x[0])] | ^ 1/7     //
-//     The scale factor is further constrained 0.125 < scale < 4.0.           //
-//     The new step size is h := scale * h.                                   //
-////////////////////////////////////////////////////////////////////////////////
-
-////////////////////////////////////////////////////////////////////////////////
-//  static fp Runge_Kutta(fp (*f)(fp,fp), fp *y,          //
-//                                                       fp x0, fp h) //
-//                                                                            //
-//  Description:                                                              //
-//     This routine uses Fehlberg's embedded 7th and 8th order methods to     //
-//     approximate the solution of the differential equation y'=f(x,y) with   //
-//     the initial condition y = y[0] at x = x0.  The value at x + h is       //
-//     returned in y[1].  The function returns err / h ( the absolute error   //
-//     per step size ).                                                       //
-//                                                                            //
-//  Arguments:                                                                //
-//     fp *f  Pointer to the function which returns the slope at (x,y) of //
-//                integral curve of the differential equation y' = f(x,y)     //
-//                which passes through the point (x0,y[0]).                   //
-//     fp y[] On input y[0] is the initial value of y at x, on output     //
-//                y[1] is the solution at x + h.                              //
-//     fp x   Initial value of x.                                         //
-//     fp h   Step size                                                   //
-//                                                                            //
-//  Return Values:                                                            //
-//     This routine returns the err / h.  The solution of y(x) at x + h is    //
-//     returned in y[1].                                                      //
-//                                                                            //
-////////////////////////////////////////////////////////////////////////////////
-
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-//		PARTICULAR SOLVER FUNCTION
-//===============================================================================================================================================================================================================
-//===============================================================================================================================================================================================================
-
-static fp embedded_fehlberg_7_8(	fp timeinst,
-															fp h,
-															fp* initvalu,
-															fp* finavalu,
-															fp* error,
-															fp* parameter,
-															int mode) {
-
-	// printf("initvalu[0] = %f\n", initvalu[0]);
-	// printf("initvalu[10] = %f\n", initvalu[10]);
-	// printf("initvalu[50] = %f\n", initvalu[50]);
-	// printf("initvalu[90] = %f\n", initvalu[90]);
-
-	// printf("finavalu[0] = %f\n", finavalu[0]);
-	// printf("finavalu[10] = %f\n", finavalu[10]);
-	// printf("finavalu[50] = %f\n", finavalu[50]);
-	// printf("finavalu[90] = %f\n", finavalu[90]);
-
-	//======================================================================================================================================================
-	//	VARIABLES
-	//======================================================================================================================================================
-
-	static const fp c_1_11 = 41.0 / 840.0;
-	static const fp c6 = 34.0 / 105.0;
-	static const fp c_7_8= 9.0 / 35.0;
-	static const fp c_9_10 = 9.0 / 280.0;
-
-	static const fp a2 = 2.0 / 27.0;
-	static const fp a3 = 1.0 / 9.0;
-	static const fp a4 = 1.0 / 6.0;
-	static const fp a5 = 5.0 / 12.0;
-	static const fp a6 = 1.0 / 2.0;
-	static const fp a7 = 5.0 / 6.0;
-	static const fp a8 = 1.0 / 6.0;
-	static const fp a9 = 2.0 / 3.0;
-	static const fp a10 = 1.0 / 3.0;
-
-	static const fp b31 = 1.0 / 36.0;
-	static const fp b32 = 3.0 / 36.0;
-	static const fp b41 = 1.0 / 24.0;
-	static const fp b43 = 3.0 / 24.0;
-	static const fp b51 = 20.0 / 48.0;
-	static const fp b53 = -75.0 / 48.0;
-	static const fp b54 = 75.0 / 48.0;
-	static const fp b61 = 1.0 / 20.0;
-	static const fp b64 = 5.0 / 20.0;
-	static const fp b65 = 4.0 / 20.0;
-	static const fp b71 = -25.0 / 108.0;
-	static const fp b74 =  125.0 / 108.0;
-	static const fp b75 = -260.0 / 108.0;
-	static const fp b76 =  250.0 / 108.0;
-	static const fp b81 = 31.0/300.0;
-	static const fp b85 = 61.0/225.0;
-	static const fp b86 = -2.0/9.0;
-	static const fp b87 = 13.0/900.0;
-	static const fp b91 = 2.0;
-	static const fp b94 = -53.0/6.0;
-	static const fp b95 = 704.0 / 45.0;
-	static const fp b96 = -107.0 / 9.0;
-	static const fp b97 = 67.0 / 90.0;
-	static const fp b98 = 3.0;
-	static const fp b10_1 = -91.0 / 108.0;
-	static const fp b10_4 = 23.0 / 108.0;
-	static const fp b10_5 = -976.0 / 135.0;
-	static const fp b10_6 = 311.0 / 54.0;
-	static const fp b10_7 = -19.0 / 60.0;
-	static const fp b10_8 = 17.0 / 6.0;
-	static const fp b10_9 = -1.0 / 12.0;
-	static const fp b11_1 = 2383.0 / 4100.0;
-	static const fp b11_4 = -341.0 / 164.0;
-	static const fp b11_5 = 4496.0 / 1025.0;
-	static const fp b11_6 = -301.0 / 82.0;
-	static const fp b11_7 = 2133.0 / 4100.0;
-	static const fp b11_8 = 45.0 / 82.0;
-	static const fp b11_9 = 45.0 / 164.0;
-	static const fp b11_10 = 18.0 / 41.0;
-	static const fp b12_1 = 3.0 / 205.0;
-	static const fp b12_6 = - 6.0 / 41.0;
-	static const fp b12_7 = - 3.0 / 205.0;
-	static const fp b12_8 = - 3.0 / 41.0;
-	static const fp b12_9 = 3.0 / 41.0;
-	static const fp b12_10 = 6.0 / 41.0;
-	static const fp b13_1 = -1777.0 / 4100.0;
-	static const fp b13_4 = -341.0 / 164.0;
-	static const fp b13_5 = 4496.0 / 1025.0;
-	static const fp b13_6 = -289.0 / 82.0;
-	static const fp b13_7 = 2193.0 / 4100.0;
-	static const fp b13_8 = 51.0 / 82.0;
-	static const fp b13_9 = 33.0 / 164.0;
-	static const fp b13_10 = 12.0 / 41.0;
-
-	static const fp err_factor  = -41.0 / 840.0;
-
-	fp h2_7 = a2 * h;
-
-	fp timeinst_temp;
-	fp* initvalu_temp;
-	fp** finavalu_temp;
-
-	int i;
-
-	//======================================================================================================================================================
-	//		TEMPORARY STORAGE ALLOCATION
-	//======================================================================================================================================================
-
-	initvalu_temp= (fp *) malloc(EQUATIONS* sizeof(fp));
-
-	finavalu_temp= (fp **) malloc(13* sizeof(fp *));
-	for (i= 0; i<13; i++){
-		finavalu_temp[i]= (fp *) malloc(EQUATIONS* sizeof(fp));
-	}
-
-	//======================================================================================================================================================
-	//		EVALUATIONS
-	//======================================================================================================================================================
-
-	//===================================================================================================
-	//		1
-	//===================================================================================================
-
-	timeinst_temp = timeinst;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] ;
-		// printf("initvalu[%d] = %f\n", i, initvalu[i]);
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[0],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[0][%d] = %f\n", i, finavalu_temp[0][i]);
-	// }
-
-	//===================================================================================================
-	//		2
-	//===================================================================================================
-
-	timeinst_temp = timeinst+h2_7;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h2_7 * (finavalu_temp[0][i]);
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[1],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[1][%d] = %f\n", i, finavalu_temp[1][i]);
-	// }
-
-	//===================================================================================================
-	//		3
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a3*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b31*finavalu_temp[0][i] + b32*finavalu_temp[1][i]);
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[2],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[2][%d] = %f\n", i, finavalu_temp[2][i]);
-	// }
-
-	//===================================================================================================
-	//		4
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a4*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b41*finavalu_temp[0][i] + b43*finavalu_temp[2][i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[3],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[3][%d] = %f\n", i, finavalu_temp[3][i]);
-	// }
-
-	//===================================================================================================
-	//		5
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a5*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b51*finavalu_temp[0][i] + b53*finavalu_temp[2][i] + b54*finavalu_temp[3][i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[4],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[4][%d] = %f\n", i, finavalu_temp[4][i]);
-	// }
-
-	//===================================================================================================
-	//		6
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a6*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b61*finavalu_temp[0][i] + b64*finavalu_temp[3][i] + b65*finavalu_temp[4][i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[5],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[5][%d] = %f\n", i, finavalu_temp[5][i]);
-	// }
-
-	//===================================================================================================
-	//		7
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a7*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b71*finavalu_temp[0][i] + b74*finavalu_temp[3][i] + b75*finavalu_temp[4][i] + b76*finavalu_temp[5][i]);
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[6],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[6][%d] = %f\n", i, finavalu_temp[6][i]);
-	// }
-
-	//===================================================================================================
-	//		8
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a8*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b81*finavalu_temp[0][i] + b85*finavalu_temp[4][i] + b86*finavalu_temp[5][i] + b87*finavalu_temp[6][i]);
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[7],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[7][%d] = %f\n", i, finavalu_temp[7][i]);
-	// }
-
-	//===================================================================================================
-	//		9
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a9*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b91*finavalu_temp[0][i] + b94*finavalu_temp[3][i] + b95*finavalu_temp[4][i] + b96*finavalu_temp[5][i] + b97*finavalu_temp[6][i]+ b98*finavalu_temp[7][i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[8],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[8][%d] = %f\n", i, finavalu_temp[8][i]);
-	// }
-
-	//===================================================================================================
-	//		10
-	//===================================================================================================
-
-	timeinst_temp = timeinst+a10*h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b10_1*finavalu_temp[0][i] + b10_4*finavalu_temp[3][i] + b10_5*finavalu_temp[4][i] + b10_6*finavalu_temp[5][i] + b10_7*finavalu_temp[6][i] + b10_8*finavalu_temp[7][i] + b10_9*finavalu_temp[8] [i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[9],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[9][%d] = %f\n", i, finavalu_temp[9][i]);
-	// }
-
-	//===================================================================================================
-	//		11
-	//===================================================================================================
-
-	timeinst_temp = timeinst+h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b11_1*finavalu_temp[0][i] + b11_4*finavalu_temp[3][i] + b11_5*finavalu_temp[4][i] + b11_6*finavalu_temp[5][i] + b11_7*finavalu_temp[6][i] + b11_8*finavalu_temp[7][i] + b11_9*finavalu_temp[8][i]+ b11_10 * finavalu_temp[9][i]);
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[10],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[10][%d] = %f\n", i, finavalu_temp[10][i]);
-	// }
-
-	//===================================================================================================
-	//		12
-	//===================================================================================================
-
-	timeinst_temp = timeinst;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b12_1*finavalu_temp[0][i] + b12_6*finavalu_temp[5][i] + b12_7*finavalu_temp[6][i] + b12_8*finavalu_temp[7][i] + b12_9*finavalu_temp[8][i] + b12_10 * finavalu_temp[9][i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[11],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[11][%d] = %f\n", i, finavalu_temp[11][i]);
-	// }
-
-	//===================================================================================================
-	//		13
-	//===================================================================================================
-
-	timeinst_temp = timeinst+h;
-	for(i=0; i<EQUATIONS; i++){
-		initvalu_temp[i] = initvalu[i] + h * ( b13_1*finavalu_temp[0][i] + b13_4*finavalu_temp[3][i] + b13_5*finavalu_temp[4][i] + b13_6*finavalu_temp[5][i] + b13_7*finavalu_temp[6][i] + b13_8*finavalu_temp[7][i] + b13_9*finavalu_temp[8][i] + b13_10*finavalu_temp[9][i] + finavalu_temp[11][i]) ;
-	}
-
-	master(	timeinst_temp,
-					initvalu_temp,
-					parameter,
-					finavalu_temp[12],
-					mode);
-
-	// for(i=0; i<EQUATIONS; i++){
-		// printf("finavalu_temp[12][%d] = %f\n", i, finavalu_temp[12][i]);
-	// }
-
-	//======================================================================================================================================================
-	//		FINAL VALUE
-	//======================================================================================================================================================
-
-	for(i=0; i<EQUATIONS; i++){
-		finavalu[i]= initvalu[i] +  h * (c_1_11 * (finavalu_temp[0][i] + finavalu_temp[10][i])  + c6 * finavalu_temp[5][i] + c_7_8 * (finavalu_temp[6][i] + finavalu_temp[7][i]) + c_9_10 * (finavalu_temp[8][i] + finavalu_temp[9][i]) );
-		// printf("finavalu_temp[0][%d] = %f\n", i, finavalu_temp[0][i]);
-		// printf("finavalu_temp[10][%d] = %f\n", i, finavalu_temp[10][i]);
-		// printf("finavalu_temp[5][%d] = %f\n", i, finavalu_temp[5][i]);
-		// printf("finavalu_temp[6][%d] = %f\n", i, finavalu_temp[6][i]);
-		// printf("finavalu_temp[7][%d] = %f\n", i, finavalu_temp[7][i]);
-		// printf("finavalu_temp[8][%d] = %f\n", i, finavalu_temp[8][i]);
-		// printf("finavalu_temp[9][%d] = %f\n", i, finavalu_temp[9][i]);
-		// printf("finavalu[%d] = %f\n", i, finavalu[i]);
-	}
-
-	//======================================================================================================================================================
-	//		RETURN
-	//======================================================================================================================================================
-
-	for(i=0; i<EQUATIONS; i++){
-		error[i] = fabs(err_factor * (finavalu_temp[0][i] + finavalu_temp[10][i] - finavalu_temp[11][i] - finavalu_temp[12][i]));
-		// printf("Error[%d] = %f\n", i, error[i]);
-	}
-
-	//======================================================================================================================================================
-	//		DEALLOCATION
-	//======================================================================================================================================================
-
-	free(initvalu_temp);
-	free(finavalu_temp);
-
-}
diff -ruN rodinia_3.1/openmp/myocyte/file.c rodinia_3.1_new/openmp/myocyte/file.c
--- rodinia_3.1/openmp/myocyte/file.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/file.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,129 +0,0 @@
-//========================================================================================================================
-//	INCLUDE/DEFINE
-//========================================================================================================================
-
-// #include <stdlib.h>
-// #include <string.h>
-#include <stdio.h>
-// #include <math.h>
-// #include <time.h>
-// #include <sys/types.h>
-// #include <dirent.h>
-// #include <errno.h>
-
-//========================================================================================================================
-//	WRITE FUNCTION
-//========================================================================================================================
-
-void write(	char* filename,
-					fp* input, 
-					int data_rows, 
-					int data_cols, 
-					int major,
-					int data_range){
-
-	//=====================================================================
-	//	VARIABLES
-	//=====================================================================
-
-	FILE* fid;
-	int i, j;
-
-	//=====================================================================
-	//	CREATE/OPEN FILE FOR WRITING
-	//=====================================================================
-
-	fid = fopen(filename, "w");
-	if( fid == NULL ){
-		printf( "The file was not created/opened for writing\n" );
-		return;
-	}
-
-	//=====================================================================
-	//	WRITE VALUES TO THE FILE
-	//=====================================================================
-
-	// if matrix is saved row major in memory (C)
-	if(major==0){
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fprintf(fid, "%f ", (fp)input[i*data_cols+j]);
-			}
-			fprintf(fid, "\n");
-		}
-	}
-	// if matrix is saved column major in memory (MATLAB)
-	else{
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fprintf(fid, "%f ", (fp)input[j*data_rows+i]);
-			}
-			fprintf(fid, "\n");
-		}
-	}
-
-	//=====================================================================
-	//	CLOSE FILE
-	//=====================================================================
-
-	fclose(fid);
-
-}
-
-//========================================================================================================================
-//	READ FUNCTION
-//========================================================================================================================
-
-void read(	char* filename,
-					fp* input,
-					int data_rows, 
-					int data_cols,
-					int major){
-
-	//=====================================================================
-	//	VARIABLES
-	//=====================================================================
-
-	FILE* fid;
-	int i, j;
-	char c;
-	fp temp;
-
-	//=====================================================================
-	//	OPEN FILE FOR READING
-	//=====================================================================
-
-	fid = fopen(filename, "r");
-	if( fid == NULL ){
-		printf( "The file was not opened for reading\n" );
-		return;
-	}
-
-	//=====================================================================
-	//	READ VALUES FROM THE FILE
-	//=====================================================================
-
-	if(major==0){																// if matrix is saved row major in memory (C)
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fscanf(fid, "%f", &temp);
-				input[i*data_cols+j] = (fp)temp;
-			}
-		}
-	}
-	else{																				// if matrix is saved column major in memory (MATLAB)
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fscanf(fid, "%f", &temp);
-				input[j*data_rows+i] = (fp)temp;
-			}
-		}
-	}
-
-	//=====================================================================
-	//	CLOSE FILE
-	//=====================================================================
-
-	fclose(fid);
-
-}
diff -ruN rodinia_3.1/openmp/myocyte/fin.c rodinia_3.1_new/openmp/myocyte/fin.c
--- rodinia_3.1/openmp/myocyte/fin.c	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/myocyte/fin.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,108 +0,0 @@
-//=====================================================================
-//	MAIN FUNCTION
-//=====================================================================
-void fin(	fp *initvalu,
-				int initvalu_offset_ecc,
-				int initvalu_offset_Dyad,
-				int initvalu_offset_SL,
-				int initvalu_offset_Cyt,
-				fp *parameter,
-				fp *finavalu,
-				fp JCaDyad,
-				fp JCaSL,
-				fp JCaCyt){
-
-//=====================================================================
-//	VARIABLES
-//=====================================================================
-
-	// decoded input parameters
-	fp BtotDyad;																		//
-	fp CaMKIItotDyad;																	//
-
-	// compute variables
-	fp Vmyo;																			// [L]
-	fp Vdyad;																			// [L]
-	fp VSL;																				// [L]
-	fp kDyadSL;																			// [L/msec]
-	fp kSLmyo;																			// [L/msec]
-	fp k0Boff;																			// [s^-1] 
-	fp k0Bon;																			// [uM^-1 s^-1] kon = koff/Kd
-	fp k2Boff;																			// [s^-1] 
-	fp k2Bon;																			// [uM^-1 s^-1]
-	fp k4Boff;																			// [s^-1]
-	fp k4Bon;																			// [uM^-1 s^-1]
-	fp CaMtotDyad;
-	fp Bdyad;																			// [uM dyad]
-	fp J_cam_dyadSL;																	// [uM/msec dyad]
-	fp J_ca2cam_dyadSL;																	// [uM/msec dyad]
-	fp J_ca4cam_dyadSL;																	// [uM/msec dyad]
-	fp J_cam_SLmyo;																		// [umol/msec]
-	fp J_ca2cam_SLmyo;																	// [umol/msec]
-	fp J_ca4cam_SLmyo;																	// [umol/msec]
-
-//=====================================================================
-//	COMPUTATION
-//=====================================================================
-
-	// decoded input parameters
-	BtotDyad      = parameter[2];														//
-	CaMKIItotDyad = parameter[3];														//
-
-	// set variables
-	Vmyo = 2.1454e-11;																	// [L]
-	Vdyad = 1.7790e-14;																	// [L]
-	VSL = 6.6013e-13;																	// [L]
-	kDyadSL = 3.6363e-16;																// [L/msec]
-	kSLmyo = 8.587e-15;																	// [L/msec]
-	k0Boff = 0.0014;																	// [s^-1] 
-	k0Bon = k0Boff/0.2;																	// [uM^-1 s^-1] kon = koff/Kd
-	k2Boff = k0Boff/100;																// [s^-1] 
-	k2Bon = k0Bon;																		// [uM^-1 s^-1]
-	k4Boff = k2Boff;																	// [s^-1]
-	k4Bon = k0Bon;																		// [uM^-1 s^-1]
-
-	// ADJUST ECC incorporate Ca buffering from CaM, convert JCaCyt from uM/msec to mM/msec
-	finavalu[initvalu_offset_ecc+35] = finavalu[initvalu_offset_ecc+35] + 1e-3*JCaDyad;
-	finavalu[initvalu_offset_ecc+36] = finavalu[initvalu_offset_ecc+36] + 1e-3*JCaSL;
-	finavalu[initvalu_offset_ecc+37] = finavalu[initvalu_offset_ecc+37] + 1e-3*JCaCyt; 
-
-	// incorporate CaM diffusion between compartments
-	CaMtotDyad = initvalu[initvalu_offset_Dyad+0]
-			   + initvalu[initvalu_offset_Dyad+1]
-			   + initvalu[initvalu_offset_Dyad+2]
-			   + initvalu[initvalu_offset_Dyad+3]
-			   + initvalu[initvalu_offset_Dyad+4]
-			   + initvalu[initvalu_offset_Dyad+5]
-			   + CaMKIItotDyad * (  initvalu[initvalu_offset_Dyad+6]
-								  + initvalu[initvalu_offset_Dyad+7]
-								  + initvalu[initvalu_offset_Dyad+8]
-								  + initvalu[initvalu_offset_Dyad+9])
-			   + initvalu[initvalu_offset_Dyad+12]
-			   + initvalu[initvalu_offset_Dyad+13]
-			   + initvalu[initvalu_offset_Dyad+14];
-	Bdyad = BtotDyad - CaMtotDyad;																				// [uM dyad]
-	J_cam_dyadSL = 1e-3 * (  k0Boff*initvalu[initvalu_offset_Dyad+0] - k0Bon*Bdyad*initvalu[initvalu_offset_SL+0]);			// [uM/msec dyad]
-	J_ca2cam_dyadSL = 1e-3 * (  k2Boff*initvalu[initvalu_offset_Dyad+1] - k2Bon*Bdyad*initvalu[initvalu_offset_SL+1]);		// [uM/msec dyad]
-	J_ca4cam_dyadSL = 1e-3 * (  k2Boff*initvalu[initvalu_offset_Dyad+2] - k4Bon*Bdyad*initvalu[initvalu_offset_SL+2]);		// [uM/msec dyad]
-	
-	J_cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+0] - initvalu[initvalu_offset_Cyt+0]);								// [umol/msec]
-	J_ca2cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+1] - initvalu[initvalu_offset_Cyt+1]);							// [umol/msec]
-	J_ca4cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+2] - initvalu[initvalu_offset_Cyt+2]);							// [umol/msec]
-	
-	// ADJUST CAM Dyad 
-	finavalu[initvalu_offset_Dyad+0] = finavalu[initvalu_offset_Dyad+0] - J_cam_dyadSL;
-	finavalu[initvalu_offset_Dyad+1] = finavalu[initvalu_offset_Dyad+1] - J_ca2cam_dyadSL;
-	finavalu[initvalu_offset_Dyad+2] = finavalu[initvalu_offset_Dyad+2] - J_ca4cam_dyadSL;
-	
-	// ADJUST CAM Sl
-	finavalu[initvalu_offset_SL+0] = finavalu[initvalu_offset_SL+0] + J_cam_dyadSL*Vdyad/VSL - J_cam_SLmyo/VSL;
-	finavalu[initvalu_offset_SL+1] = finavalu[initvalu_offset_SL+1] + J_ca2cam_dyadSL*Vdyad/VSL - J_ca2cam_SLmyo/VSL;
-	finavalu[initvalu_offset_SL+2] = finavalu[initvalu_offset_SL+2] + J_ca4cam_dyadSL*Vdyad/VSL - J_ca4cam_SLmyo/VSL;
-
-	// ADJUST CAM Cyt 
-	finavalu[initvalu_offset_Cyt+0] = finavalu[initvalu_offset_Cyt+0] + J_cam_SLmyo/Vmyo;
-	finavalu[initvalu_offset_Cyt+1] = finavalu[initvalu_offset_Cyt+1] + J_ca2cam_SLmyo/Vmyo;
-	finavalu[initvalu_offset_Cyt+2] = finavalu[initvalu_offset_Cyt+2] + J_ca4cam_SLmyo/Vmyo;
-
-}
diff -ruN rodinia_3.1/openmp/myocyte/main.c rodinia_3.1_new/openmp/myocyte/main.c
--- rodinia_3.1/openmp/myocyte/main.c	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/myocyte/main.c	2024-08-29 14:50:13.820123514 -0700
@@ -11,7 +11,7 @@
 // Myocyte application models cardiac myocyte (heart muscle cell) and simulates its behavior according to the work by Saucerman and Bers [8]. The model integrates 
 // cardiac myocyte electrical activity with the calcineurin pathway, which is a key aspect of the development of heart failure. The model spans large number of temporal 
 // scales to reflect how changes in heart rate as observed during exercise or stress contribute to calcineurin pathway activation, which ultimately leads to the expression 
-// of numerous genes that remodel the hearts structure. It can be used to identify potential therapeutic targets that may be useful for the treatment of heart failure. 
+// of numerous genes that remodel the hearts structure. It can be used to identify potential therapeutic targets that may be useful for the treatment of heart failure. 
 // Biochemical reactions, ion transport and electrical activity in the cell are modeled with 91 ordinary differential equations (ODEs) that are determined by more than 200 
 // experimentally validated parameters. The model is simulated by solving this group of ODEs for a specified time interval. The process of ODE solving is based on the 
 // causal relationship between values of ODEs at different time steps, thus it is mostly sequential. At every dynamically determined time step, the solver evaluates the 
@@ -80,16 +80,2569 @@
 
 #include <omp.h>
 
-#include "define.c"
-#include "ecc.c"
-#include "cam.c"
-#include "fin.c"
-#include "master.c"
-#include "embedded_fehlberg_7_8.c"
-#include "solver.c"
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//	DEFINE / INCLUDE
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+#define fp float
+
+#define EQUATIONS 91
+#define PARAMETERS 16
+
+//=====================================================================
+//	MAIN FUNCTION
+//=====================================================================
+void ecc(	fp timeinst,
+				fp *initvalu,
+				int initvalu_offset,
+				fp *parameter,
+				int parameter_offset,
+				fp *finavalu){
+
+	//=====================================================================
+	//	VARIABLES
+	//=====================================================================
+
+	// initial data and output data variable references
+	int offset_1;
+	int offset_2;
+	int offset_3;
+	int offset_4;
+	int offset_5;
+	int offset_6;
+	int offset_7;
+	int offset_8;
+	int offset_9;
+	int offset_10;
+	int offset_11;
+	int offset_12;
+	int offset_13;
+	int offset_14;
+	int offset_15;
+	int offset_16;
+	int offset_17;
+	int offset_18;
+	int offset_19;
+	int offset_20;
+	int offset_21;
+	int offset_22;
+	int offset_23;
+	int offset_24;
+	int offset_25;
+	int offset_26;
+	int offset_27;
+	int offset_28;
+	int offset_29;
+	int offset_30;
+	int offset_31;
+	int offset_32;
+	int offset_33;
+	int offset_34;
+	int offset_35;
+	int offset_36;
+	int offset_37;
+	int offset_38;
+	int offset_39;
+	int offset_40;
+	int offset_41;
+	int offset_42;
+	int offset_43;
+	int offset_44;
+	int offset_45;
+	int offset_46;
+
+	// initial data variable references
+	int parameter_offset_1;
+
+	// decoded input initial data			// GET VARIABLES FROM MEMORY AND SAVE LOCALLY !!!!!!!!!!!!!!!!!!
+	fp initvalu_1;
+	fp initvalu_2;
+	fp initvalu_3;
+	fp initvalu_4;
+	fp initvalu_5;
+	fp initvalu_6;
+	fp initvalu_7;
+	fp initvalu_8;
+	fp initvalu_9;
+	fp initvalu_10;
+	fp initvalu_11;
+	fp initvalu_12;
+	fp initvalu_13;
+	fp initvalu_14;
+	fp initvalu_15;
+	fp initvalu_16;
+	fp initvalu_17;
+	fp initvalu_18;
+	fp initvalu_19;
+	fp initvalu_20;
+	fp initvalu_21;
+	fp initvalu_22;
+	fp initvalu_23;
+	fp initvalu_24;
+	fp initvalu_25;
+	fp initvalu_26;
+	fp initvalu_27;
+	fp initvalu_28;
+	fp initvalu_29;
+	fp initvalu_30;
+	fp initvalu_31;
+	fp initvalu_32;
+	fp initvalu_33;
+	fp initvalu_34;
+	fp initvalu_35;
+	fp initvalu_36;
+	fp initvalu_37;
+	fp initvalu_38;
+	fp initvalu_39;
+	fp initvalu_40;
+	fp initvalu_41;
+	fp initvalu_42;
+	fp initvalu_43;
+	fp initvalu_44;
+	fp initvalu_45;
+	fp initvalu_46;
+
+	// decoded input parameters
+	fp parameter_1;
+
+	// matlab constants undefined in c
+	fp pi;
+
+	// Constants
+	fp R;																			// [J/kmol*K]  
+	fp Frdy;																		// [C/mol]  
+	fp Temp;																		// [K] 310
+	fp FoRT;																		//
+	fp Cmem;																		// [F] membrane capacitance
+	fp Qpow;
+
+	// Cell geometry
+	fp cellLength;																	// cell length [um]
+	fp cellRadius;																	// cell radius [um]
+	fp junctionLength;																// junc length [um]
+	fp junctionRadius;																// junc radius [um]
+	fp distSLcyto;																	// dist. SL to cytosol [um]
+	fp distJuncSL;																	// dist. junc to SL [um]
+	fp DcaJuncSL;																	// Dca junc to SL [cm^2/sec]
+	fp DcaSLcyto;																	// Dca SL to cyto [cm^2/sec]
+	fp DnaJuncSL;																	// Dna junc to SL [cm^2/sec]
+	fp DnaSLcyto;																	// Dna SL to cyto [cm^2/sec] 
+	fp Vcell;																		// [L]
+	fp Vmyo; 
+	fp Vsr; 
+	fp Vsl; 
+	fp Vjunc; 
+	fp SAjunc;																		// [um^2]
+	fp SAsl;																		// [um^2]
+	fp J_ca_juncsl;																	// [L/msec]
+	fp J_ca_slmyo;																	// [L/msec]
+	fp J_na_juncsl;																	// [L/msec] 
+	fp J_na_slmyo;																	// [L/msec] 
+
+	// Fractional currents in compartments
+	fp Fjunc;   
+	fp Fsl;
+	fp Fjunc_CaL; 
+	fp Fsl_CaL;
+
+	// Fixed ion concentrations     
+	fp Cli;																			// Intracellular Cl  [mM]
+	fp Clo;																			// Extracellular Cl  [mM]
+	fp Ko;																			// Extracellular K   [mM]
+	fp Nao;																			// Extracellular Na  [mM]
+	fp Cao;																			// Extracellular Ca  [mM]
+	fp Mgi;																			// Intracellular Mg  [mM]
+
+	// Nernst Potentials
+	fp ena_junc;																	// [mV]
+	fp ena_sl;																		// [mV]
+	fp ek;																			// [mV]
+	fp eca_junc;																	// [mV]
+	fp eca_sl;																		// [mV]
+	fp ecl;																			// [mV]
+
+	// Na transport parameters
+	fp GNa;																			// [mS/uF]
+	fp GNaB;																		// [mS/uF] 
+	fp IbarNaK;																		// [uA/uF]
+	fp KmNaip;																		// [mM]
+	fp KmKo;																		// [mM]
+	fp Q10NaK;  
+	fp Q10KmNai;
+
+	// K current parameters
+	fp pNaK;      
+	fp GtoSlow;																		// [mS/uF] 
+	fp GtoFast;																		// [mS/uF] 
+	fp gkp;
+
+	// Cl current parameters
+	fp GClCa;																		// [mS/uF]
+	fp GClB;																		// [mS/uF]
+	fp KdClCa;																		// [mM]																// [mM]
+
+	// I_Ca parameters
+	fp pNa;																			// [cm/sec]
+	fp pCa;																			// [cm/sec]
+	fp pK;																			// [cm/sec]
+	fp KmCa;																		// [mM]
+	fp Q10CaL;       
+
+	// Ca transport parameters
+	fp IbarNCX;																		// [uA/uF]
+	fp KmCai;																		// [mM]
+	fp KmCao;																		// [mM]
+	fp KmNai;																		// [mM]
+	fp KmNao;																		// [mM]
+	fp ksat;																			// [none]  
+	fp nu;																			// [none]
+	fp Kdact;																		// [mM] 
+	fp Q10NCX;																		// [none]
+	fp IbarSLCaP;																	// [uA/uF]
+	fp KmPCa;																		// [mM] 
+	fp GCaB;																		// [uA/uF] 
+	fp Q10SLCaP;																	// [none]																	// [none]
+
+	// SR flux parameters
+	fp Q10SRCaP;																	// [none]
+	fp Vmax_SRCaP;																	// [mM/msec] (mmol/L cytosol/msec)
+	fp Kmf;																			// [mM]
+	fp Kmr;																			// [mM]L cytosol
+	fp hillSRCaP;																	// [mM]
+	fp ks;																			// [1/ms]      
+	fp koCa;																		// [mM^-2 1/ms]      
+	fp kom;																			// [1/ms]     
+	fp kiCa;																		// [1/mM/ms]
+	fp kim;																			// [1/ms]
+	fp ec50SR;																		// [mM]
+
+	// Buffering parameters
+	fp Bmax_Naj;																	// [mM] 
+	fp Bmax_Nasl;																	// [mM]
+	fp koff_na;																		// [1/ms]
+	fp kon_na;																		// [1/mM/ms]
+	fp Bmax_TnClow;																	// [mM], TnC low affinity
+	fp koff_tncl;																	// [1/ms] 
+	fp kon_tncl;																	// [1/mM/ms]
+	fp Bmax_TnChigh;																// [mM], TnC high affinity 
+	fp koff_tnchca;																	// [1/ms] 
+	fp kon_tnchca;																	// [1/mM/ms]
+	fp koff_tnchmg;																	// [1/ms] 
+	fp kon_tnchmg;																	// [1/mM/ms]
+	fp Bmax_CaM;																	// [mM], CaM buffering
+	fp koff_cam;																	// [1/ms] 
+	fp kon_cam;																		// [1/mM/ms]
+	fp Bmax_myosin;																	// [mM], Myosin buffering
+	fp koff_myoca;																	// [1/ms]
+	fp kon_myoca;																	// [1/mM/ms]
+	fp koff_myomg;																	// [1/ms]
+	fp kon_myomg;																	// [1/mM/ms]
+	fp Bmax_SR;																		// [mM] 
+	fp koff_sr;																		// [1/ms]
+	fp kon_sr;																		// [1/mM/ms]
+	fp Bmax_SLlowsl;																// [mM], SL buffering
+	fp Bmax_SLlowj;																	// [mM]    
+	fp koff_sll;																	// [1/ms]
+	fp kon_sll;																		// [1/mM/ms]
+	fp Bmax_SLhighsl;																// [mM] 
+	fp Bmax_SLhighj;																// [mM] 
+	fp koff_slh;																	// [1/ms]
+	fp kon_slh;																		// [1/mM/ms]
+	fp Bmax_Csqn;																	// 140e-3*Vmyo/Vsr; [mM] 
+	fp koff_csqn;																	// [1/ms] 
+	fp kon_csqn;																	// [1/mM/ms] 
+
+	// I_Na: Fast Na Current
+	fp am;
+	fp bm;
+	fp ah;
+	fp bh;
+	fp aj;
+	fp bj;
+	fp I_Na_junc;
+	fp I_Na_sl;
+	fp I_Na;
+
+	// I_nabk: Na Background Current
+	fp I_nabk_junc;
+	fp I_nabk_sl;
+	fp I_nabk;
+
+	// I_nak: Na/K Pump Current
+	fp sigma;
+	fp fnak;
+	fp I_nak_junc;
+	fp I_nak_sl;
+	fp I_nak;
+
+	// I_kr: Rapidly Activating K Current
+	fp gkr;
+	fp xrss;
+	fp tauxr;
+	fp rkr;
+	fp I_kr;
+
+	// I_ks: Slowly Activating K Current
+	fp pcaks_junc; 
+	fp pcaks_sl;  
+	fp gks_junc;
+	fp gks_sl; 
+	fp eks;	
+	fp xsss;
+	fp tauxs; 
+	fp I_ks_junc;
+	fp I_ks_sl;
+	fp I_ks;
+
+	// I_kp: Plateau K current
+	fp kp_kp;
+	fp I_kp_junc;
+	fp I_kp_sl;
+	fp I_kp;
+
+	// I_to: Transient Outward K Current (slow and fast components)
+	fp xtoss;
+	fp ytoss;
+	fp rtoss;
+	fp tauxtos;
+	fp tauytos;
+	fp taurtos; 
+	fp I_tos;	
+
+	//
+	fp tauxtof;
+	fp tauytof;
+	fp I_tof;
+	fp I_to;
+
+	// I_ki: Time-Independent K Current
+	fp aki;
+	fp bki;
+	fp kiss;
+	fp I_ki;
+
+	// I_ClCa: Ca-activated Cl Current, I_Clbk: background Cl Current
+	fp I_ClCa_junc;
+	fp I_ClCa_sl;
+	fp I_ClCa;
+	fp I_Clbk;
+
+	// I_Ca: L-type Calcium Current
+	fp dss;
+	fp taud;
+	fp fss;
+	fp tauf;
+
+	//
+	fp ibarca_j;
+	fp ibarca_sl;
+	fp ibark;
+	fp ibarna_j;
+	fp ibarna_sl;
+	fp I_Ca_junc;
+	fp I_Ca_sl;
+	fp I_Ca;
+	fp I_CaK;
+	fp I_CaNa_junc;
+	fp I_CaNa_sl;
+	fp I_CaNa;
+	fp I_Catot;
+
+	// I_ncx: Na/Ca Exchanger flux
+	fp Ka_junc;
+	fp Ka_sl;
+	fp s1_junc;
+	fp s1_sl;
+	fp s2_junc;
+	fp s3_junc;
+	fp s2_sl;
+	fp s3_sl;
+	fp I_ncx_junc;
+	fp I_ncx_sl;
+	fp I_ncx;
+
+	// I_pca: Sarcolemmal Ca Pump Current
+	fp I_pca_junc;
+	fp I_pca_sl;
+	fp I_pca;
+
+	// I_cabk: Ca Background Current
+	fp I_cabk_junc;
+	fp I_cabk_sl;
+	fp I_cabk;
+	
+	// SR fluxes: Calcium Release, SR Ca pump, SR Ca leak														
+	fp MaxSR;
+	fp MinSR;
+	fp kCaSR;
+	fp koSRCa;
+	fp kiSRCa;
+	fp RI;
+	fp J_SRCarel;																	// [mM/ms]
+	fp J_serca;
+	fp J_SRleak;																		//   [mM/ms]
+
+	// Cytosolic Ca Buffers
+	fp J_CaB_cytosol;
+
+	// Junctional and SL Ca Buffers
+	fp J_CaB_junction;
+	fp J_CaB_sl;
+
+	// SR Ca Concentrations
+	fp oneovervsr;
+
+	// Sodium Concentrations
+	fp I_Na_tot_junc;																// [uA/uF]
+	fp I_Na_tot_sl;																	// [uA/uF]
+	fp oneovervsl;
+
+	// Potassium Concentration
+	fp I_K_tot;
+
+	// Calcium Concentrations
+	fp I_Ca_tot_junc;																// [uA/uF]
+	fp I_Ca_tot_sl;																	// [uA/uF]
+	fp junc_sl;
+	fp sl_junc;
+	fp sl_myo;
+	fp myo_sl;
+
+	//	Simulation type													
+	int state;																			// 0-none; 1-pace; 2-vclamp
+	fp I_app;
+	fp V_hold;
+	fp V_test;
+	fp V_clamp;
+	fp R_clamp;
+	
+	//	Membrane Potential
+	fp I_Na_tot;																		// [uA/uF]
+	fp I_Cl_tot;																		// [uA/uF]
+	fp I_Ca_tot;
+	fp I_tot;
+
+	//=====================================================================
+	//	EXECUTION
+	//=====================================================================
+
+	// variable references
+	offset_1  = initvalu_offset;
+	offset_2  = initvalu_offset+1;
+	offset_3  = initvalu_offset+2;
+	offset_4  = initvalu_offset+3;
+	offset_5  = initvalu_offset+4;
+	offset_6  = initvalu_offset+5;
+	offset_7  = initvalu_offset+6;
+	offset_8  = initvalu_offset+7;
+	offset_9  = initvalu_offset+8;
+	offset_10 = initvalu_offset+9;
+	offset_11 = initvalu_offset+10;
+	offset_12 = initvalu_offset+11;
+	offset_13 = initvalu_offset+12;
+	offset_14 = initvalu_offset+13;
+	offset_15 = initvalu_offset+14;
+	offset_16 = initvalu_offset+15;
+	offset_17 = initvalu_offset+16;
+	offset_18 = initvalu_offset+17;
+	offset_19 = initvalu_offset+18;
+	offset_20 = initvalu_offset+19;
+	offset_21 = initvalu_offset+20;
+	offset_22 = initvalu_offset+21;
+	offset_23 = initvalu_offset+22;
+	offset_24 = initvalu_offset+23;
+	offset_25 = initvalu_offset+24;
+	offset_26 = initvalu_offset+25;
+	offset_27 = initvalu_offset+26;
+	offset_28 = initvalu_offset+27;
+	offset_29 = initvalu_offset+28;
+	offset_30 = initvalu_offset+29;
+	offset_31 = initvalu_offset+30;
+	offset_32 = initvalu_offset+31;
+	offset_33 = initvalu_offset+32;
+	offset_34 = initvalu_offset+33;
+	offset_35 = initvalu_offset+34;
+	offset_36 = initvalu_offset+35;
+	offset_37 = initvalu_offset+36;
+	offset_38 = initvalu_offset+37;
+	offset_39 = initvalu_offset+38;
+	offset_40 = initvalu_offset+39;
+	offset_41 = initvalu_offset+40;
+	offset_42 = initvalu_offset+41;
+	offset_43 = initvalu_offset+42;
+	offset_44 = initvalu_offset+43;
+	offset_45 = initvalu_offset+44;
+	offset_46 = initvalu_offset+45;
+	
+	// variable references
+	parameter_offset_1  = parameter_offset;
+
+	// decoded input initial data
+	initvalu_1  = initvalu[offset_1 ];
+	initvalu_2  = initvalu[offset_2 ];
+	initvalu_3  = initvalu[offset_3 ];
+	initvalu_4  = initvalu[offset_4 ];
+	initvalu_5  = initvalu[offset_5 ];
+	initvalu_6  = initvalu[offset_6 ];
+	initvalu_7  = initvalu[offset_7 ];
+	initvalu_8  = initvalu[offset_8 ];
+	initvalu_9  = initvalu[offset_9 ];
+	initvalu_10 = initvalu[offset_10];
+	initvalu_11 = initvalu[offset_11];
+	initvalu_12 = initvalu[offset_12];
+	initvalu_13 = initvalu[offset_13];
+	initvalu_14 = initvalu[offset_14];
+	initvalu_15 = initvalu[offset_15];
+	initvalu_16 = initvalu[offset_16];
+	initvalu_17 = initvalu[offset_17];
+	initvalu_18 = initvalu[offset_18];
+	initvalu_19 = initvalu[offset_19];
+	initvalu_20 = initvalu[offset_20];
+	initvalu_21 = initvalu[offset_21];
+	initvalu_22 = initvalu[offset_22];
+	initvalu_23 = initvalu[offset_23];
+	initvalu_24 = initvalu[offset_24];
+	initvalu_25 = initvalu[offset_25];
+	initvalu_26 = initvalu[offset_26];
+	initvalu_27 = initvalu[offset_27];
+	initvalu_28 = initvalu[offset_28];
+	initvalu_29 = initvalu[offset_29];
+	initvalu_30 = initvalu[offset_30];
+	initvalu_31 = initvalu[offset_31];
+	initvalu_32 = initvalu[offset_32];
+	initvalu_33 = initvalu[offset_33];
+	initvalu_34 = initvalu[offset_34];
+	initvalu_35 = initvalu[offset_35];
+	initvalu_36 = initvalu[offset_36];
+	initvalu_37 = initvalu[offset_37];
+	initvalu_38 = initvalu[offset_38];
+	initvalu_39 = initvalu[offset_39];
+	initvalu_40 = initvalu[offset_40];
+	initvalu_41 = initvalu[offset_41];
+	initvalu_42 = initvalu[offset_42];
+	initvalu_43 = initvalu[offset_43];
+	initvalu_44 = initvalu[offset_44];
+	initvalu_45 = initvalu[offset_45];
+	initvalu_46 = initvalu[offset_46];
+
+	// decoded input parameters
+	parameter_1 = parameter[parameter_offset_1];
+
+	// matlab constants undefined in c
+	pi = 3.1416;
+
+	// Constants
+	R = 8314;																			// [J/kmol*K]  
+	Frdy = 96485;																		// [C/mol]  
+	Temp = 310;																			// [K] 310
+	FoRT = Frdy/R/Temp;																	//
+	Cmem = 1.3810e-10;																	// [F] membrane capacitance
+	Qpow = (Temp-310)/10;
+
+	// Cell geometry
+	cellLength = 100;																	// cell length [um]
+	cellRadius = 10.25;																	// cell radius [um]
+	junctionLength = 160e-3;															// junc length [um]
+	junctionRadius = 15e-3;																// junc radius [um]
+	distSLcyto = 0.45;																	// dist. SL to cytosol [um]
+	distJuncSL = 0.5;																	// dist. junc to SL [um]
+	DcaJuncSL = 1.64e-6;																// Dca junc to SL [cm^2/sec]
+	DcaSLcyto = 1.22e-6;																// Dca SL to cyto [cm^2/sec]
+	DnaJuncSL = 1.09e-5;																// Dna junc to SL [cm^2/sec]
+	DnaSLcyto = 1.79e-5;																// Dna SL to cyto [cm^2/sec] 
+	Vcell = pi*pow(cellRadius,2)*cellLength*1e-15;											// [L]
+	Vmyo = 0.65*Vcell; 
+	Vsr = 0.035*Vcell; 
+	Vsl = 0.02*Vcell; 
+	Vjunc = 0.0539*0.01*Vcell; 
+	SAjunc = 20150*pi*2*junctionLength*junctionRadius;									// [um^2]
+	SAsl = pi*2*cellRadius*cellLength;													// [um^2]
+	J_ca_juncsl = 1/1.2134e12;															// [L/msec]
+	J_ca_slmyo = 1/2.68510e11;															// [L/msec]
+	J_na_juncsl = 1/(1.6382e12/3*100);													// [L/msec] 
+	J_na_slmyo = 1/(1.8308e10/3*100);													// [L/msec] 
+
+	// Fractional currents in compartments
+	Fjunc = 0.11;   
+	Fsl = 1-Fjunc;
+	Fjunc_CaL = 0.9; 
+	Fsl_CaL = 1-Fjunc_CaL;
+
+	// Fixed ion concentrations     
+	Cli = 15;																			// Intracellular Cl  [mM]
+	Clo = 150;																			// Extracellular Cl  [mM]
+	Ko = 5.4;																			// Extracellular K   [mM]
+	Nao = 140;																			// Extracellular Na  [mM]
+	Cao = 1.8;																			// Extracellular Ca  [mM]
+	Mgi = 1;																			// Intracellular Mg  [mM]
+
+	// Nernst Potentials
+	ena_junc = (1/FoRT)*log(Nao/initvalu_32);													// [mV]
+	ena_sl = (1/FoRT)*log(Nao/initvalu_33);													// [mV]
+	ek = (1/FoRT)*log(Ko/initvalu_35);														// [mV]
+	eca_junc = (1/FoRT/2)*log(Cao/initvalu_36);												// [mV]
+	eca_sl = (1/FoRT/2)*log(Cao/initvalu_37);													// [mV]
+	ecl = (1/FoRT)*log(Cli/Clo);														// [mV]
+
+	// Na transport parameters
+	GNa =  16.0;																		// [mS/uF]
+	GNaB = 0.297e-3;																	// [mS/uF] 
+	IbarNaK = 1.90719;																	// [uA/uF]
+	KmNaip = 11;																		// [mM]
+	KmKo = 1.5;																			// [mM]
+	Q10NaK = 1.63;  
+	Q10KmNai = 1.39;
+
+	// K current parameters
+	pNaK = 0.01833;      
+	GtoSlow = 0.06;																		// [mS/uF] 
+	GtoFast = 0.02;																		// [mS/uF] 
+	gkp = 0.001;
+
+	// Cl current parameters
+	GClCa = 0.109625;																	// [mS/uF]
+	GClB = 9e-3;																		// [mS/uF]
+	KdClCa = 100e-3;																	// [mM]
+
+	// I_Ca parameters
+	pNa = 1.5e-8;																		// [cm/sec]
+	pCa = 5.4e-4;																		// [cm/sec]
+	pK = 2.7e-7;																		// [cm/sec]
+	KmCa = 0.6e-3;																		// [mM]
+	Q10CaL = 1.8;       
+
+	// Ca transport parameters
+	IbarNCX = 9.0;																		// [uA/uF]
+	KmCai = 3.59e-3;																	// [mM]
+	KmCao = 1.3;																		// [mM]
+	KmNai = 12.29;																		// [mM]
+	KmNao = 87.5;																		// [mM]
+	ksat = 0.27;																		// [none]  
+	nu = 0.35;																			// [none]
+	Kdact = 0.256e-3;																	// [mM] 
+	Q10NCX = 1.57;																		// [none]
+	IbarSLCaP = 0.0673;																	// [uA/uF]
+	KmPCa = 0.5e-3;																		// [mM] 
+	GCaB = 2.513e-4;																	// [uA/uF] 
+	Q10SLCaP = 2.35;																	// [none]
+
+	// SR flux parameters
+	Q10SRCaP = 2.6;																		// [none]
+	Vmax_SRCaP = 2.86e-4;																// [mM/msec] (mmol/L cytosol/msec)
+	Kmf = 0.246e-3;																		// [mM]
+	Kmr = 1.7;																			// [mM]L cytosol
+	hillSRCaP = 1.787;																	// [mM]
+	ks = 25;																			// [1/ms]      
+	koCa = 10;																			// [mM^-2 1/ms]      
+	kom = 0.06;																			// [1/ms]     
+	kiCa = 0.5;																			// [1/mM/ms]
+	kim = 0.005;																		// [1/ms]
+	ec50SR = 0.45;																		// [mM]
+
+	// Buffering parameters
+	Bmax_Naj = 7.561;																	// [mM] 
+	Bmax_Nasl = 1.65;																	// [mM]
+	koff_na = 1e-3;																		// [1/ms]
+	kon_na = 0.1e-3;																	// [1/mM/ms]
+	Bmax_TnClow = 70e-3;																// [mM], TnC low affinity
+	koff_tncl = 19.6e-3;																// [1/ms] 
+	kon_tncl = 32.7;																	// [1/mM/ms]
+	Bmax_TnChigh = 140e-3;																// [mM], TnC high affinity 
+	koff_tnchca = 0.032e-3;																// [1/ms] 
+	kon_tnchca = 2.37;																	// [1/mM/ms]
+	koff_tnchmg = 3.33e-3;																// [1/ms] 
+	kon_tnchmg = 3e-3;																	// [1/mM/ms]
+	Bmax_CaM = 24e-3;																	// [mM], CaM buffering
+	koff_cam = 238e-3;																	// [1/ms] 
+	kon_cam = 34;																		// [1/mM/ms]
+	Bmax_myosin = 140e-3;																// [mM], Myosin buffering
+	koff_myoca = 0.46e-3;																// [1/ms]
+	kon_myoca = 13.8;																	// [1/mM/ms]
+	koff_myomg = 0.057e-3;																// [1/ms]
+	kon_myomg = 0.0157;																	// [1/mM/ms]
+	Bmax_SR = 19*0.9e-3;																	// [mM] 
+	koff_sr = 60e-3;																	// [1/ms]
+	kon_sr = 100;																		// [1/mM/ms]
+	Bmax_SLlowsl = 37.38e-3*Vmyo/Vsl;													// [mM], SL buffering
+	Bmax_SLlowj = 4.62e-3*Vmyo/Vjunc*0.1;												// [mM]    
+	koff_sll = 1300e-3;																	// [1/ms]
+	kon_sll = 100;																		// [1/mM/ms]
+	Bmax_SLhighsl = 13.35e-3*Vmyo/Vsl;													// [mM] 
+	Bmax_SLhighj = 1.65e-3*Vmyo/Vjunc*0.1;												// [mM] 
+	koff_slh = 30e-3;																	// [1/ms]
+	kon_slh = 100;																		// [1/mM/ms]
+	Bmax_Csqn = 2.7;																	// 140e-3*Vmyo/Vsr; [mM] 
+	koff_csqn = 65;																		// [1/ms] 
+	kon_csqn = 100;																		// [1/mM/ms] 
+
+	// I_Na: Fast Na Current
+	am = 0.32*(initvalu_39+47.13)/(1-exp(-0.1*(initvalu_39+47.13)));
+	bm = 0.08*exp(-initvalu_39/11);
+	if(initvalu_39 >= -40){
+		ah = 0; aj = 0;
+		bh = 1/(0.13*(1+exp(-(initvalu_39+10.66)/11.1)));
+		bj = 0.3*exp(-2.535e-7*initvalu_39)/(1+exp(-0.1*(initvalu_39+32)));
+	}
+	else{
+		ah = 0.135*exp((80+initvalu_39)/-6.8);
+		bh = 3.56*exp(0.079*initvalu_39)+3.1e5*exp(0.35*initvalu_39);
+		aj = (-127140*exp(0.2444*initvalu_39)-3.474e-5*exp(-0.04391*initvalu_39))*(initvalu_39+37.78)/(1+exp(0.311*(initvalu_39+79.23)));
+		bj = 0.1212*exp(-0.01052*initvalu_39)/(1+exp(-0.1378*(initvalu_39+40.14)));
+	}
+	finavalu[offset_1] = am*(1-initvalu_1)-bm*initvalu_1;
+	finavalu[offset_2] = ah*(1-initvalu_2)-bh*initvalu_2;
+	finavalu[offset_3] = aj*(1-initvalu_3)-bj*initvalu_3;
+	I_Na_junc = Fjunc*GNa*pow(initvalu_1,3)*initvalu_2*initvalu_3*(initvalu_39-ena_junc);
+	I_Na_sl = Fsl*GNa*pow(initvalu_1,3)*initvalu_2*initvalu_3*(initvalu_39-ena_sl);
+	I_Na = I_Na_junc+I_Na_sl;
+
+	// I_nabk: Na Background Current
+	I_nabk_junc = Fjunc*GNaB*(initvalu_39-ena_junc);
+	I_nabk_sl = Fsl*GNaB*(initvalu_39-ena_sl);
+	I_nabk = I_nabk_junc+I_nabk_sl;
+
+	// I_nak: Na/K Pump Current
+	sigma = (exp(Nao/67.3)-1)/7;
+	fnak = 1/(1+0.1245*exp(-0.1*initvalu_39*FoRT)+0.0365*sigma*exp(-initvalu_39*FoRT));
+	I_nak_junc = Fjunc*IbarNaK*fnak*Ko /(1+pow((KmNaip/initvalu_32),4)) /(Ko+KmKo);
+	I_nak_sl = Fsl*IbarNaK*fnak*Ko /(1+pow((KmNaip/initvalu_33),4)) /(Ko+KmKo);
+	I_nak = I_nak_junc+I_nak_sl;
+
+	// I_kr: Rapidly Activating K Current
+	gkr = 0.03*sqrt(Ko/5.4);
+	xrss = 1/(1+exp(-(initvalu_39+50)/7.5));
+	tauxr = 1/(0.00138*(initvalu_39+7)/(1-exp(-0.123*(initvalu_39+7)))+6.1e-4*(initvalu_39+10)/(exp(0.145*(initvalu_39+10))-1));
+	finavalu[offset_12] = (xrss-initvalu_12)/tauxr;
+	rkr = 1/(1+exp((initvalu_39+33)/22.4));
+	I_kr = gkr*initvalu_12*rkr*(initvalu_39-ek);
+
+	// I_ks: Slowly Activating K Current
+	pcaks_junc = -log10(initvalu_36)+3.0; 
+	pcaks_sl = -log10(initvalu_37)+3.0;  
+	gks_junc = 0.07*(0.057 +0.19/(1+ exp((-7.2+pcaks_junc)/0.6)));
+	gks_sl = 0.07*(0.057 +0.19/(1+ exp((-7.2+pcaks_sl)/0.6))); 
+	eks = (1/FoRT)*log((Ko+pNaK*Nao)/(initvalu_35+pNaK*initvalu_34));	
+	xsss = 1/(1+exp(-(initvalu_39-1.5)/16.7));
+	tauxs = 1/(7.19e-5*(initvalu_39+30)/(1-exp(-0.148*(initvalu_39+30)))+1.31e-4*(initvalu_39+30)/(exp(0.0687*(initvalu_39+30))-1)); 
+	finavalu[offset_13] = (xsss-initvalu_13)/tauxs;
+	I_ks_junc = Fjunc*gks_junc*pow(initvalu_12,2)*(initvalu_39-eks);
+	I_ks_sl = Fsl*gks_sl*pow(initvalu_13,2)*(initvalu_39-eks);
+	I_ks = I_ks_junc+I_ks_sl;
+
+	// I_kp: Plateau K current
+	kp_kp = 1/(1+exp(7.488-initvalu_39/5.98));
+	I_kp_junc = Fjunc*gkp*kp_kp*(initvalu_39-ek);
+	I_kp_sl = Fsl*gkp*kp_kp*(initvalu_39-ek);
+	I_kp = I_kp_junc+I_kp_sl;
+
+	// I_to: Transient Outward K Current (slow and fast components)
+	xtoss = 1/(1+exp(-(initvalu_39+3.0)/15));
+	ytoss = 1/(1+exp((initvalu_39+33.5)/10));
+	rtoss = 1/(1+exp((initvalu_39+33.5)/10));
+	tauxtos = 9/(1+exp((initvalu_39+3.0)/15))+0.5;
+	tauytos = 3e3/(1+exp((initvalu_39+60.0)/10))+30;
+	taurtos = 2800/(1+exp((initvalu_39+60.0)/10))+220; 
+	finavalu[offset_8] = (xtoss-initvalu_8)/tauxtos;
+	finavalu[offset_9] = (ytoss-initvalu_9)/tauytos;
+	finavalu[offset_40]= (rtoss-initvalu_40)/taurtos; 
+	I_tos = GtoSlow*initvalu_8*(initvalu_9+0.5*initvalu_40)*(initvalu_39-ek);									// [uA/uF]
+
+	//
+	tauxtof = 3.5*exp(-initvalu_39*initvalu_39/30/30)+1.5;
+	tauytof = 20.0/(1+exp((initvalu_39+33.5)/10))+20.0;
+	finavalu[offset_10] = (xtoss-initvalu_10)/tauxtof;
+	finavalu[offset_11] = (ytoss-initvalu_11)/tauytof;
+	I_tof = GtoFast*initvalu_10*initvalu_11*(initvalu_39-ek);
+	I_to = I_tos + I_tof;
+
+	// I_ki: Time-Independent K Current
+	aki = 1.02/(1+exp(0.2385*(initvalu_39-ek-59.215)));
+	bki =(0.49124*exp(0.08032*(initvalu_39+5.476-ek)) + exp(0.06175*(initvalu_39-ek-594.31))) /(1 + exp(-0.5143*(initvalu_39-ek+4.753)));
+	kiss = aki/(aki+bki);
+	I_ki = 0.9*sqrt(Ko/5.4)*kiss*(initvalu_39-ek);
+
+	// I_ClCa: Ca-activated Cl Current, I_Clbk: background Cl Current
+	I_ClCa_junc = Fjunc*GClCa/(1+KdClCa/initvalu_36)*(initvalu_39-ecl);
+	I_ClCa_sl = Fsl*GClCa/(1+KdClCa/initvalu_37)*(initvalu_39-ecl);
+	I_ClCa = I_ClCa_junc+I_ClCa_sl;
+	I_Clbk = GClB*(initvalu_39-ecl);
+
+	// I_Ca: L-type Calcium Current
+	dss = 1/(1+exp(-(initvalu_39+14.5)/6.0));
+	taud = dss*(1-exp(-(initvalu_39+14.5)/6.0))/(0.035*(initvalu_39+14.5));
+	fss = 1/(1+exp((initvalu_39+35.06)/3.6))+0.6/(1+exp((50-initvalu_39)/20));
+	tauf = 1/(0.0197*exp(-pow(0.0337*(initvalu_39+14.5),2))+0.02);
+	finavalu[offset_4] = (dss-initvalu_4)/taud;
+	finavalu[offset_5] = (fss-initvalu_5)/tauf;
+	finavalu[offset_6] = 1.7*initvalu_36*(1-initvalu_6)-11.9e-3*initvalu_6;											// fCa_junc  
+	finavalu[offset_7] = 1.7*initvalu_37*(1-initvalu_7)-11.9e-3*initvalu_7;											// fCa_sl
+
+	//
+	ibarca_j = pCa*4*(initvalu_39*Frdy*FoRT) * (0.341*initvalu_36*exp(2*initvalu_39*FoRT)-0.341*Cao) /(exp(2*initvalu_39*FoRT)-1);
+	ibarca_sl = pCa*4*(initvalu_39*Frdy*FoRT) * (0.341*initvalu_37*exp(2*initvalu_39*FoRT)-0.341*Cao) /(exp(2*initvalu_39*FoRT)-1);
+	ibark = pK*(initvalu_39*Frdy*FoRT)*(0.75*initvalu_35*exp(initvalu_39*FoRT)-0.75*Ko) /(exp(initvalu_39*FoRT)-1);
+	ibarna_j = pNa*(initvalu_39*Frdy*FoRT) *(0.75*initvalu_32*exp(initvalu_39*FoRT)-0.75*Nao)  /(exp(initvalu_39*FoRT)-1);
+	ibarna_sl = pNa*(initvalu_39*Frdy*FoRT) *(0.75*initvalu_33*exp(initvalu_39*FoRT)-0.75*Nao)  /(exp(initvalu_39*FoRT)-1);
+	I_Ca_junc = (Fjunc_CaL*ibarca_j*initvalu_4*initvalu_5*(1-initvalu_6)*pow(Q10CaL,Qpow))*0.45;
+	I_Ca_sl = (Fsl_CaL*ibarca_sl*initvalu_4*initvalu_5*(1-initvalu_7)*pow(Q10CaL,Qpow))*0.45;
+	I_Ca = I_Ca_junc+I_Ca_sl;
+	finavalu[offset_43]=-I_Ca*Cmem/(Vmyo*2*Frdy)*1e3;
+	I_CaK = (ibark*initvalu_4*initvalu_5*(Fjunc_CaL*(1-initvalu_6)+Fsl_CaL*(1-initvalu_7))*pow(Q10CaL,Qpow))*0.45;
+	I_CaNa_junc = (Fjunc_CaL*ibarna_j*initvalu_4*initvalu_5*(1-initvalu_6)*pow(Q10CaL,Qpow))*0.45;
+	I_CaNa_sl = (Fsl_CaL*ibarna_sl*initvalu_4*initvalu_5*(1-initvalu_7)*pow(Q10CaL,Qpow))*0.45;
+	I_CaNa = I_CaNa_junc+I_CaNa_sl;
+	I_Catot = I_Ca+I_CaK+I_CaNa;
+
+	// I_ncx: Na/Ca Exchanger flux
+	Ka_junc = 1/(1+pow((Kdact/initvalu_36),3));
+	Ka_sl = 1/(1+pow((Kdact/initvalu_37),3));
+	s1_junc = exp(nu*initvalu_39*FoRT)*pow(initvalu_32,3)*Cao;
+	s1_sl = exp(nu*initvalu_39*FoRT)*pow(initvalu_33,3)*Cao;
+	s2_junc = exp((nu-1)*initvalu_39*FoRT)*pow(Nao,3)*initvalu_36;
+	s3_junc = (KmCai*pow(Nao,3)*(1+pow((initvalu_32/KmNai),3))+pow(KmNao,3)*initvalu_36+ pow(KmNai,3)*Cao*(1+initvalu_36/KmCai)+KmCao*pow(initvalu_32,3)+pow(initvalu_32,3)*Cao+pow(Nao,3)*initvalu_36)*(1+ksat*exp((nu-1)*initvalu_39*FoRT));
+	s2_sl = exp((nu-1)*initvalu_39*FoRT)*pow(Nao,3)*initvalu_37;
+	s3_sl = (KmCai*pow(Nao,3)*(1+pow((initvalu_33/KmNai),3)) + pow(KmNao,3)*initvalu_37+pow(KmNai,3)*Cao*(1+initvalu_37/KmCai)+KmCao*pow(initvalu_33,3)+pow(initvalu_33,3)*Cao+pow(Nao,3)*initvalu_37)*(1+ksat*exp((nu-1)*initvalu_39*FoRT));
+	I_ncx_junc = Fjunc*IbarNCX*pow(Q10NCX,Qpow)*Ka_junc*(s1_junc-s2_junc)/s3_junc;
+	I_ncx_sl = Fsl*IbarNCX*pow(Q10NCX,Qpow)*Ka_sl*(s1_sl-s2_sl)/s3_sl;
+	I_ncx = I_ncx_junc+I_ncx_sl;
+	finavalu[offset_45]=2*I_ncx*Cmem/(Vmyo*2*Frdy)*1e3;
+
+	// I_pca: Sarcolemmal Ca Pump Current
+	I_pca_junc = 	Fjunc * 
+					pow(Q10SLCaP,Qpow) * 
+					IbarSLCaP * 
+					pow(initvalu_36,1.6) /
+					(pow(KmPCa,1.6) + pow(initvalu_36,1.6));
+	I_pca_sl = 	Fsl * 
+				pow(Q10SLCaP,Qpow) * 
+				IbarSLCaP * 
+				pow(initvalu_37,1.6) / 
+				(pow(KmPCa,1.6) + pow(initvalu_37,1.6));
+	I_pca = I_pca_junc+I_pca_sl;
+	finavalu[offset_44]=-I_pca*Cmem/(Vmyo*2*Frdy)*1e3;
+
+	// I_cabk: Ca Background Current
+	I_cabk_junc = Fjunc*GCaB*(initvalu_39-eca_junc);
+	I_cabk_sl = Fsl*GCaB*(initvalu_39-eca_sl);
+	I_cabk = I_cabk_junc+I_cabk_sl;
+	finavalu[offset_46]=-I_cabk*Cmem/(Vmyo*2*Frdy)*1e3;
+	
+	// SR fluxes: Calcium Release, SR Ca pump, SR Ca leak														
+	MaxSR = 15; 
+	MinSR = 1;
+	kCaSR = MaxSR - (MaxSR-MinSR)/(1+pow(ec50SR/initvalu_31,2.5));
+	koSRCa = koCa/kCaSR;
+	kiSRCa = kiCa*kCaSR;
+	RI = 1-initvalu_14-initvalu_15-initvalu_16;
+	finavalu[offset_14] = (kim*RI-kiSRCa*initvalu_36*initvalu_14)-(koSRCa*pow(initvalu_36,2)*initvalu_14-kom*initvalu_15);			// R
+	finavalu[offset_15] = (koSRCa*pow(initvalu_36,2)*initvalu_14-kom*initvalu_15)-(kiSRCa*initvalu_36*initvalu_15-kim*initvalu_16);			// O
+	finavalu[offset_16] = (kiSRCa*initvalu_36*initvalu_15-kim*initvalu_16)-(kom*initvalu_16-koSRCa*pow(initvalu_36,2)*RI);			// I
+	J_SRCarel = ks*initvalu_15*(initvalu_31-initvalu_36);													// [mM/ms]
+	J_serca = pow(Q10SRCaP,Qpow)*Vmax_SRCaP*(pow((initvalu_38/Kmf),hillSRCaP)-pow((initvalu_31/Kmr),hillSRCaP))
+										 /(1+pow((initvalu_38/Kmf),hillSRCaP)+pow((initvalu_31/Kmr),hillSRCaP));
+	J_SRleak = 5.348e-6*(initvalu_31-initvalu_36);													//   [mM/ms]
+
+	// Sodium and Calcium Buffering														
+	finavalu[offset_17] = kon_na*initvalu_32*(Bmax_Naj-initvalu_17)-koff_na*initvalu_17;								// NaBj      [mM/ms]
+	finavalu[offset_18] = kon_na*initvalu_33*(Bmax_Nasl-initvalu_18)-koff_na*initvalu_18;							// NaBsl     [mM/ms]
+
+	// Cytosolic Ca Buffers
+	finavalu[offset_19] = kon_tncl*initvalu_38*(Bmax_TnClow-initvalu_19)-koff_tncl*initvalu_19;						// TnCL      [mM/ms]
+	finavalu[offset_20] = kon_tnchca*initvalu_38*(Bmax_TnChigh-initvalu_20-initvalu_21)-koff_tnchca*initvalu_20;			// TnCHc     [mM/ms]
+	finavalu[offset_21] = kon_tnchmg*Mgi*(Bmax_TnChigh-initvalu_20-initvalu_21)-koff_tnchmg*initvalu_21;				// TnCHm     [mM/ms]
+	finavalu[offset_22] = 0;																		// CaM       [mM/ms]
+	finavalu[offset_23] = kon_myoca*initvalu_38*(Bmax_myosin-initvalu_23-initvalu_24)-koff_myoca*initvalu_23;				// Myosin_ca [mM/ms]
+	finavalu[offset_24] = kon_myomg*Mgi*(Bmax_myosin-initvalu_23-initvalu_24)-koff_myomg*initvalu_24;				// Myosin_mg [mM/ms]
+	finavalu[offset_25] = kon_sr*initvalu_38*(Bmax_SR-initvalu_25)-koff_sr*initvalu_25;								// SRB       [mM/ms]
+	J_CaB_cytosol = finavalu[offset_19] + finavalu[offset_20] + finavalu[offset_21] + finavalu[offset_22] + finavalu[offset_23] + finavalu[offset_24] + finavalu[offset_25];
+
+	// Junctional and SL Ca Buffers
+	finavalu[offset_26] = kon_sll*initvalu_36*(Bmax_SLlowj-initvalu_26)-koff_sll*initvalu_26;						// SLLj      [mM/ms]
+	finavalu[offset_27] = kon_sll*initvalu_37*(Bmax_SLlowsl-initvalu_27)-koff_sll*initvalu_27;						// SLLsl     [mM/ms]
+	finavalu[offset_28] = kon_slh*initvalu_36*(Bmax_SLhighj-initvalu_28)-koff_slh*initvalu_28;						// SLHj      [mM/ms]
+	finavalu[offset_29] = kon_slh*initvalu_37*(Bmax_SLhighsl-initvalu_29)-koff_slh*initvalu_29;						// SLHsl     [mM/ms]
+	J_CaB_junction = finavalu[offset_26]+finavalu[offset_28];
+	J_CaB_sl = finavalu[offset_27]+finavalu[offset_29];
+
+	// SR Ca Concentrations
+	finavalu[offset_30] = kon_csqn*initvalu_31*(Bmax_Csqn-initvalu_30)-koff_csqn*initvalu_30;						// Csqn      [mM/ms]
+	oneovervsr = 1/Vsr;
+	finavalu[offset_31] = J_serca*Vmyo*oneovervsr-(J_SRleak*Vmyo*oneovervsr+J_SRCarel)-finavalu[offset_30];   // Ca_sr     [mM/ms] %Ratio 3 leak current
+
+	// Sodium Concentrations
+	I_Na_tot_junc = I_Na_junc+I_nabk_junc+3*I_ncx_junc+3*I_nak_junc+I_CaNa_junc;		// [uA/uF]
+	I_Na_tot_sl = I_Na_sl+I_nabk_sl+3*I_ncx_sl+3*I_nak_sl+I_CaNa_sl;					// [uA/uF]
+	finavalu[offset_32] = -I_Na_tot_junc*Cmem/(Vjunc*Frdy)+J_na_juncsl/Vjunc*(initvalu_33-initvalu_32)-finavalu[offset_17];
+	oneovervsl = 1/Vsl;
+	finavalu[offset_33] = -I_Na_tot_sl*Cmem*oneovervsl/Frdy+J_na_juncsl*oneovervsl*(initvalu_32-initvalu_33)+J_na_slmyo*oneovervsl*(initvalu_34-initvalu_33)-finavalu[offset_18];
+	finavalu[offset_34] = J_na_slmyo/Vmyo*(initvalu_33-initvalu_34);											// [mM/msec] 
+
+	// Potassium Concentration
+	I_K_tot = I_to+I_kr+I_ks+I_ki-2*I_nak+I_CaK+I_kp;									// [uA/uF]
+	finavalu[offset_35] = 0;															// [mM/msec]
+
+	// Calcium Concentrations
+	I_Ca_tot_junc = I_Ca_junc+I_cabk_junc+I_pca_junc-2*I_ncx_junc;						// [uA/uF]
+	I_Ca_tot_sl = I_Ca_sl+I_cabk_sl+I_pca_sl-2*I_ncx_sl;								// [uA/uF]
+	finavalu[offset_36] = -I_Ca_tot_junc*Cmem/(Vjunc*2*Frdy)+J_ca_juncsl/Vjunc*(initvalu_37-initvalu_36)
+	         - J_CaB_junction+(J_SRCarel)*Vsr/Vjunc+J_SRleak*Vmyo/Vjunc;				// Ca_j
+	finavalu[offset_37] = -I_Ca_tot_sl*Cmem/(Vsl*2*Frdy)+J_ca_juncsl/Vsl*(initvalu_36-initvalu_37)
+	         + J_ca_slmyo/Vsl*(initvalu_38-initvalu_37)-J_CaB_sl;									// Ca_sl
+	finavalu[offset_38] = -J_serca-J_CaB_cytosol +J_ca_slmyo/Vmyo*(initvalu_37-initvalu_38);
+	junc_sl=J_ca_juncsl/Vsl*(initvalu_36-initvalu_37);
+	sl_junc=J_ca_juncsl/Vjunc*(initvalu_37-initvalu_36);
+	sl_myo=J_ca_slmyo/Vsl*(initvalu_38-initvalu_37);
+	myo_sl=J_ca_slmyo/Vmyo*(initvalu_37-initvalu_38);
+
+	// Simulation type													
+	state = 1;																			
+	switch(state){
+		case 0:
+			I_app = 0;
+			break;
+		case 1:																			// pace w/ current injection at cycleLength 'cycleLength'
+			if(fmod(timeinst,parameter_1) <= 5){
+				I_app = 9.5;
+			}
+			else{
+				I_app = 0.0;
+			}
+			break;
+		case 2:     
+			V_hold = -55;
+			V_test = 0;
+			if(timeinst>0.5 & timeinst<200.5){
+				V_clamp = V_test;
+			}
+			else{
+				V_clamp = V_hold;
+			}
+			R_clamp = 0.04;
+			I_app = (V_clamp-initvalu_39)/R_clamp;
+			break;
+	} 
+
+	// Membrane Potential												
+	I_Na_tot = I_Na_tot_junc + I_Na_tot_sl;												// [uA/uF]
+	I_Cl_tot = I_ClCa+I_Clbk;															// [uA/uF]
+	I_Ca_tot = I_Ca_tot_junc+I_Ca_tot_sl;
+	I_tot = I_Na_tot+I_Cl_tot+I_Ca_tot+I_K_tot;
+	finavalu[offset_39] = -(I_tot-I_app);
+
+	// Set unused output values to 0 (MATLAB does it by default)
+	finavalu[offset_41] = 0;
+	finavalu[offset_42] = 0;
+
+}
+
+//=====================================================================
+//	MAIN FUNCTION
+//=====================================================================
+fp cam(fp timeinst,
+			fp *initvalu,
+			int initvalu_offset,
+			fp *parameter,
+			int parameter_offset,
+			fp *finavalu,
+			fp Ca){
+
+	//=====================================================================
+	//	VARIABLES
+	//=====================================================================
+
+	// output
+	fp JCa;
+
+	// input data and output data variable references
+	int offset_1;
+	int offset_2;
+	int offset_3;
+	int offset_4;
+	int offset_5;
+	int offset_6;
+	int offset_7;
+	int offset_8;
+	int offset_9;
+	int offset_10;
+	int offset_11;
+	int offset_12;
+	int offset_13;
+	int offset_14;
+	int offset_15;
+
+	// parameter variable references
+	int parameter_offset_1;
+	int parameter_offset_2;
+	int parameter_offset_3;
+	int parameter_offset_4;
+	int parameter_offset_5;
+
+	// decoding input initial values
+	fp CaM;
+	fp Ca2CaM;
+	fp Ca4CaM;
+	fp CaMB;
+	fp Ca2CaMB;
+	fp Ca4CaMB;           
+	fp Pb2;
+	fp Pb;
+	fp Pt;
+	fp Pt2;
+	fp Pa;                            
+	fp Ca4CaN;
+	fp CaMCa4CaN;
+	fp Ca2CaMCa4CaN;
+	fp Ca4CaMCa4CaN;
+
+	// decoding input parameters
+	fp CaMtot;
+	fp Btot;
+	fp CaMKIItot;
+	fp CaNtot;
+	fp PP1tot;
+
+	// constants
+	fp K;																			//
+	fp Mg;																			//
+
+	// Ca/CaM parameters
+	fp Kd02;																		// [uM^2]
+	fp Kd24;																		// [uM^2]
+	fp k20;																			// [s^-1]      
+	fp k02;																			// [uM^-2 s^-1]
+	fp k42;																			// [s^-1]      
+	fp k24;																			// [uM^-2 s^-1]
+
+	// CaM buffering (B) parameters
+	fp k0Boff;																		// [s^-1] 
+	fp k0Bon;																		// [uM^-1 s^-1] kon = koff/Kd
+	fp k2Boff;																		// [s^-1] 
+	fp k2Bon;																		// [uM^-1 s^-1]
+	fp k4Boff;																		// [s^-1]
+	fp k4Bon;																		// [uM^-1 s^-1]
+
+	// using thermodynamic constraints
+	fp k20B;																		// [s^-1] thermo constraint on loop 1
+	fp k02B;																		// [uM^-2 s^-1] 
+	fp k42B;																		// [s^-1] thermo constraint on loop 2
+	fp k24B;																		// [uM^-2 s^-1]
+
+	// Wi Wa Wt Wp
+	fp kbi;																			// [s^-1] (Ca4CaM dissocation from Wb)
+	fp kib;																			// [uM^-1 s^-1]
+	fp kpp1;																		// [s^-1] (PP1-dep dephosphorylation rates)
+	fp Kmpp1;																		// [uM]
+	fp kib2;
+	fp kb2i;
+	fp kb24;
+	fp kb42;
+	fp kta;																			// [s^-1] (Ca4CaM dissociation from Wt)
+	fp kat;																			// [uM^-1 s^-1] (Ca4CaM reassociation with Wa)
+	fp kt42;
+	fp kt24;
+	fp kat2;
+	fp kt2a;
+
+	// CaN parameters
+	fp kcanCaoff;																	// [s^-1] 
+	fp kcanCaon;																	// [uM^-1 s^-1] 
+	fp kcanCaM4on;																	// [uM^-1 s^-1]
+	fp kcanCaM4off;																	// [s^-1]
+	fp kcanCaM2on;
+	fp kcanCaM2off;
+	fp kcanCaM0on;
+	fp kcanCaM0off;
+	fp k02can;
+	fp k20can;
+	fp k24can;
+	fp k42can;
+
+	// CaM Reaction fluxes
+	fp rcn02;
+	fp rcn24;
+
+	// CaM buffer fluxes
+	fp B;
+	fp rcn02B;
+	fp rcn24B;
+	fp rcn0B;
+	fp rcn2B;
+	fp rcn4B;
+
+	// CaN reaction fluxes 
+	fp Ca2CaN;
+	fp rcnCa4CaN;
+	fp rcn02CaN; 
+	fp rcn24CaN;
+	fp rcn0CaN;
+	fp rcn2CaN;
+	fp rcn4CaN;
+
+	// CaMKII reaction fluxes
+	fp Pix;
+	fp rcnCKib2;
+	fp rcnCKb2b;
+	fp rcnCKib;
+	fp T;
+	fp kbt;
+	fp rcnCKbt;
+	fp rcnCKtt2;
+	fp rcnCKta;
+	fp rcnCKt2a;
+	fp rcnCKt2b2;
+	fp rcnCKai;
+
+	// CaM equations
+	fp dCaM;
+	fp dCa2CaM;
+	fp dCa4CaM;
+	fp dCaMB;
+	fp dCa2CaMB;
+	fp dCa4CaMB;
+
+	// CaMKII equations
+	fp dPb2;																		// Pb2
+	fp dPb;																			// Pb
+	fp dPt;																			// Pt
+	fp dPt2;																		// Pt2
+	fp dPa;																			// Pa
+
+	// CaN equations
+	fp dCa4CaN;																		// Ca4CaN
+	fp dCaMCa4CaN;																	// CaMCa4CaN
+	fp dCa2CaMCa4CaN;																// Ca2CaMCa4CaN
+	fp dCa4CaMCa4CaN;																// Ca4CaMCa4CaN
+
+	//=====================================================================
+	//	COMPUTATION
+	//=====================================================================
+
+	// input data and output data variable references
+	offset_1  = initvalu_offset;
+	offset_2  = initvalu_offset+1;
+	offset_3  = initvalu_offset+2;
+	offset_4  = initvalu_offset+3;
+	offset_5  = initvalu_offset+4;
+	offset_6  = initvalu_offset+5;
+	offset_7  = initvalu_offset+6;
+	offset_8  = initvalu_offset+7;
+	offset_9  = initvalu_offset+8;
+	offset_10 = initvalu_offset+9;
+	offset_11 = initvalu_offset+10;
+	offset_12 = initvalu_offset+11;
+	offset_13 = initvalu_offset+12;
+	offset_14 = initvalu_offset+13;
+	offset_15 = initvalu_offset+14;
+	
+	// input parameters variable references
+	parameter_offset_1  = parameter_offset;
+	parameter_offset_2  = parameter_offset+1;
+	parameter_offset_3  = parameter_offset+2;
+	parameter_offset_4  = parameter_offset+3;
+	parameter_offset_5  = parameter_offset+4;
+
+	// decoding input array
+	CaM				= initvalu[offset_1];
+	Ca2CaM			= initvalu[offset_2];
+	Ca4CaM			= initvalu[offset_3];
+	CaMB			= initvalu[offset_4];
+	Ca2CaMB			= initvalu[offset_5];
+	Ca4CaMB			= initvalu[offset_6];           
+	Pb2				= initvalu[offset_7];
+	Pb				= initvalu[offset_8];
+	Pt				= initvalu[offset_9];
+	Pt2				= initvalu[offset_10];
+	Pa				= initvalu[offset_11];                            
+	Ca4CaN			= initvalu[offset_12];
+	CaMCa4CaN		= initvalu[offset_13];
+	Ca2CaMCa4CaN	= initvalu[offset_14];
+	Ca4CaMCa4CaN	= initvalu[offset_15];
+
+	// decoding input parameters
+	CaMtot			= parameter[parameter_offset_1];
+	Btot			= parameter[parameter_offset_2];
+	CaMKIItot		= parameter[parameter_offset_3];
+	CaNtot			= parameter[parameter_offset_4];
+	PP1tot			= parameter[parameter_offset_5];
+
+	// values [CONSTANTS FOR ALL THREADS]
+	K = 135;																			//
+	Mg = 1;																				//
+
+	// Ca/CaM parameters
+	if (Mg <= 1){
+		Kd02 = 0.0025*(1+K/0.94-Mg/0.012)*(1+K/8.1+Mg/0.022);							// [uM^2]
+		Kd24 = 0.128*(1+K/0.64+Mg/0.0014)*(1+K/13.0-Mg/0.153);							// [uM^2]
+	}
+	else{
+		Kd02 = 0.0025*(1+K/0.94-1/0.012+(Mg-1)/0.060)*(1+K/8.1+1/0.022+(Mg-1)/0.068);   // [uM^2]
+		Kd24 = 0.128*(1+K/0.64+1/0.0014+(Mg-1)/0.005)*(1+K/13.0-1/0.153+(Mg-1)/0.150);  // [uM^2]
+	}
+	k20 = 10;																			// [s^-1]      
+	k02 = k20/Kd02;																		// [uM^-2 s^-1]
+	k42 = 500;																			// [s^-1]      
+	k24 = k42/Kd24;																		// [uM^-2 s^-1]
+
+	// CaM buffering (B) parameters
+	k0Boff = 0.0014;																	// [s^-1] 
+	k0Bon = k0Boff/0.2;																	// [uM^-1 s^-1] kon = koff/Kd
+	k2Boff = k0Boff/100;																// [s^-1] 
+	k2Bon = k0Bon;																		// [uM^-1 s^-1]
+	k4Boff = k2Boff;																	// [s^-1]
+	k4Bon = k0Bon;																		// [uM^-1 s^-1]
+
+	// using thermodynamic constraints
+	k20B = k20/100;																		// [s^-1] thermo constraint on loop 1
+	k02B = k02;																			// [uM^-2 s^-1] 
+	k42B = k42;																			// [s^-1] thermo constraint on loop 2
+	k24B = k24;																			// [uM^-2 s^-1]
+
+	// Wi Wa Wt Wp
+	kbi = 2.2;																			// [s^-1] (Ca4CaM dissocation from Wb)
+	kib = kbi/33.5e-3;																	// [uM^-1 s^-1]
+	kpp1 = 1.72;																		// [s^-1] (PP1-dep dephosphorylation rates)
+	Kmpp1 = 11.5;																		// [uM]
+	kib2 = kib;
+	kb2i = kib2*5;
+	kb24 = k24;
+	kb42 = k42*33.5e-3/5;
+	kta = kbi/1000;																		// [s^-1] (Ca4CaM dissociation from Wt)
+	kat = kib;																			// [uM^-1 s^-1] (Ca4CaM reassociation with Wa)
+	kt42 = k42*33.5e-6/5;
+	kt24 = k24;
+	kat2 = kib;
+	kt2a = kib*5;
+
+	// CaN parameters
+	kcanCaoff = 1;																		// [s^-1] 
+	kcanCaon = kcanCaoff/0.5;															// [uM^-1 s^-1] 
+	kcanCaM4on = 46;																	// [uM^-1 s^-1]
+	kcanCaM4off = 0.0013;																// [s^-1]
+	kcanCaM2on = kcanCaM4on;
+	kcanCaM2off = 2508*kcanCaM4off;
+	kcanCaM0on = kcanCaM4on;
+	kcanCaM0off = 165*kcanCaM2off;
+	k02can = k02;
+	k20can = k20/165;
+	k24can = k24;
+	k42can = k20/2508;
+
+	// CaM Reaction fluxes
+	rcn02 = k02*pow(Ca,2)*CaM - k20*Ca2CaM;
+	rcn24 = k24*pow(Ca,2)*Ca2CaM - k42*Ca4CaM;
+	
+	// CaM buffer fluxes
+	B = Btot - CaMB - Ca2CaMB - Ca4CaMB;
+	rcn02B = k02B*pow(Ca,2)*CaMB - k20B*Ca2CaMB;
+	rcn24B = k24B*pow(Ca,2)*Ca2CaMB - k42B*Ca4CaMB;
+	rcn0B = k0Bon*CaM*B - k0Boff*CaMB;
+	rcn2B = k2Bon*Ca2CaM*B - k2Boff*Ca2CaMB;
+	rcn4B = k4Bon*Ca4CaM*B - k4Boff*Ca4CaMB;
+	
+	// CaN reaction fluxes 
+	Ca2CaN = CaNtot - Ca4CaN - CaMCa4CaN - Ca2CaMCa4CaN - Ca4CaMCa4CaN;
+	rcnCa4CaN = kcanCaon*pow(Ca,2)*Ca2CaN - kcanCaoff*Ca4CaN;
+	rcn02CaN = k02can*pow(Ca,2)*CaMCa4CaN - k20can*Ca2CaMCa4CaN; 
+	rcn24CaN = k24can*pow(Ca,2)*Ca2CaMCa4CaN - k42can*Ca4CaMCa4CaN;
+	rcn0CaN = kcanCaM0on*CaM*Ca4CaN - kcanCaM0off*CaMCa4CaN;
+	rcn2CaN = kcanCaM2on*Ca2CaM*Ca4CaN - kcanCaM2off*Ca2CaMCa4CaN;
+	rcn4CaN = kcanCaM4on*Ca4CaM*Ca4CaN - kcanCaM4off*Ca4CaMCa4CaN;
+
+	// CaMKII reaction fluxes
+	Pix = 1 - Pb2 - Pb - Pt - Pt2 - Pa;
+	rcnCKib2 = kib2*Ca2CaM*Pix - kb2i*Pb2;
+	rcnCKb2b = kb24*pow(Ca,2)*Pb2 - kb42*Pb;
+	rcnCKib = kib*Ca4CaM*Pix - kbi*Pb;
+	T = Pb + Pt + Pt2 + Pa;
+	kbt = 0.055*T + 0.0074*pow(T,2) + 0.015*pow(T,3);
+	rcnCKbt = kbt*Pb - kpp1*PP1tot*Pt/(Kmpp1+CaMKIItot*Pt);
+	rcnCKtt2 = kt42*Pt - kt24*pow(Ca,2)*Pt2;
+	rcnCKta = kta*Pt - kat*Ca4CaM*Pa;
+	rcnCKt2a = kt2a*Pt2 - kat2*Ca2CaM*Pa;
+	rcnCKt2b2 = kpp1*PP1tot*Pt2/(Kmpp1+CaMKIItot*Pt2);
+	rcnCKai = kpp1*PP1tot*Pa/(Kmpp1+CaMKIItot*Pa);
+
+	// CaM equations
+	dCaM = 1e-3*(-rcn02 - rcn0B - rcn0CaN);
+	dCa2CaM = 1e-3*(rcn02 - rcn24 - rcn2B - rcn2CaN + CaMKIItot*(-rcnCKib2 + rcnCKt2a) );
+	dCa4CaM = 1e-3*(rcn24 - rcn4B - rcn4CaN + CaMKIItot*(-rcnCKib+rcnCKta) );
+	dCaMB = 1e-3*(rcn0B-rcn02B);
+	dCa2CaMB = 1e-3*(rcn02B + rcn2B - rcn24B);
+	dCa4CaMB = 1e-3*(rcn24B + rcn4B);
+
+	// CaMKII equations
+	dPb2 = 1e-3*(rcnCKib2 - rcnCKb2b + rcnCKt2b2);										// Pb2
+	dPb = 1e-3*(rcnCKib + rcnCKb2b - rcnCKbt);											// Pb
+	dPt = 1e-3*(rcnCKbt-rcnCKta-rcnCKtt2);												// Pt
+	dPt2 = 1e-3*(rcnCKtt2-rcnCKt2a-rcnCKt2b2);											// Pt2
+	dPa = 1e-3*(rcnCKta+rcnCKt2a-rcnCKai);												// Pa
+
+	// CaN equations
+	dCa4CaN = 1e-3*(rcnCa4CaN - rcn0CaN - rcn2CaN - rcn4CaN);							// Ca4CaN
+	dCaMCa4CaN = 1e-3*(rcn0CaN - rcn02CaN);												// CaMCa4CaN
+	dCa2CaMCa4CaN = 1e-3*(rcn2CaN+rcn02CaN-rcn24CaN);									// Ca2CaMCa4CaN
+	dCa4CaMCa4CaN = 1e-3*(rcn4CaN+rcn24CaN);											// Ca4CaMCa4CaN
+
+	// encode output array
+	finavalu[offset_1] = dCaM;
+	finavalu[offset_2] = dCa2CaM;
+	finavalu[offset_3] = dCa4CaM;
+	finavalu[offset_4] = dCaMB;
+	finavalu[offset_5] = dCa2CaMB;
+	finavalu[offset_6] = dCa4CaMB;
+	finavalu[offset_7] = dPb2;
+	finavalu[offset_8] = dPb;
+	finavalu[offset_9] = dPt;
+	finavalu[offset_10] = dPt2;
+	finavalu[offset_11] = dPa;
+	finavalu[offset_12] = dCa4CaN;
+	finavalu[offset_13] = dCaMCa4CaN;
+	finavalu[offset_14] = dCa2CaMCa4CaN;
+	finavalu[offset_15] = dCa4CaMCa4CaN;
+
+	// write to global variables for adjusting Ca buffering in EC coupling model
+	JCa = 1e-3*(2*CaMKIItot*(rcnCKtt2-rcnCKb2b) - 2*(rcn02+rcn24+rcn02B+rcn24B+rcnCa4CaN+rcn02CaN+rcn24CaN)); // [uM/msec]
+
+	// return
+	return JCa;
+
+}
+
+//=====================================================================
+//	MAIN FUNCTION
+//=====================================================================
+void fin(	fp *initvalu,
+				int initvalu_offset_ecc,
+				int initvalu_offset_Dyad,
+				int initvalu_offset_SL,
+				int initvalu_offset_Cyt,
+				fp *parameter,
+				fp *finavalu,
+				fp JCaDyad,
+				fp JCaSL,
+				fp JCaCyt){
+
+//=====================================================================
+//	VARIABLES
+//=====================================================================
+
+	// decoded input parameters
+	fp BtotDyad;																		//
+	fp CaMKIItotDyad;																	//
+
+	// compute variables
+	fp Vmyo;																			// [L]
+	fp Vdyad;																			// [L]
+	fp VSL;																				// [L]
+	fp kDyadSL;																			// [L/msec]
+	fp kSLmyo;																			// [L/msec]
+	fp k0Boff;																			// [s^-1] 
+	fp k0Bon;																			// [uM^-1 s^-1] kon = koff/Kd
+	fp k2Boff;																			// [s^-1] 
+	fp k2Bon;																			// [uM^-1 s^-1]
+	fp k4Boff;																			// [s^-1]
+	fp k4Bon;																			// [uM^-1 s^-1]
+	fp CaMtotDyad;
+	fp Bdyad;																			// [uM dyad]
+	fp J_cam_dyadSL;																	// [uM/msec dyad]
+	fp J_ca2cam_dyadSL;																	// [uM/msec dyad]
+	fp J_ca4cam_dyadSL;																	// [uM/msec dyad]
+	fp J_cam_SLmyo;																		// [umol/msec]
+	fp J_ca2cam_SLmyo;																	// [umol/msec]
+	fp J_ca4cam_SLmyo;																	// [umol/msec]
+
+//=====================================================================
+//	COMPUTATION
+//=====================================================================
+
+	// decoded input parameters
+	BtotDyad      = parameter[2];														//
+	CaMKIItotDyad = parameter[3];														//
+
+	// set variables
+	Vmyo = 2.1454e-11;																	// [L]
+	Vdyad = 1.7790e-14;																	// [L]
+	VSL = 6.6013e-13;																	// [L]
+	kDyadSL = 3.6363e-16;																// [L/msec]
+	kSLmyo = 8.587e-15;																	// [L/msec]
+	k0Boff = 0.0014;																	// [s^-1] 
+	k0Bon = k0Boff/0.2;																	// [uM^-1 s^-1] kon = koff/Kd
+	k2Boff = k0Boff/100;																// [s^-1] 
+	k2Bon = k0Bon;																		// [uM^-1 s^-1]
+	k4Boff = k2Boff;																	// [s^-1]
+	k4Bon = k0Bon;																		// [uM^-1 s^-1]
+
+	// ADJUST ECC incorporate Ca buffering from CaM, convert JCaCyt from uM/msec to mM/msec
+	finavalu[initvalu_offset_ecc+35] = finavalu[initvalu_offset_ecc+35] + 1e-3*JCaDyad;
+	finavalu[initvalu_offset_ecc+36] = finavalu[initvalu_offset_ecc+36] + 1e-3*JCaSL;
+	finavalu[initvalu_offset_ecc+37] = finavalu[initvalu_offset_ecc+37] + 1e-3*JCaCyt; 
+
+	// incorporate CaM diffusion between compartments
+	CaMtotDyad = initvalu[initvalu_offset_Dyad+0]
+			   + initvalu[initvalu_offset_Dyad+1]
+			   + initvalu[initvalu_offset_Dyad+2]
+			   + initvalu[initvalu_offset_Dyad+3]
+			   + initvalu[initvalu_offset_Dyad+4]
+			   + initvalu[initvalu_offset_Dyad+5]
+			   + CaMKIItotDyad * (  initvalu[initvalu_offset_Dyad+6]
+								  + initvalu[initvalu_offset_Dyad+7]
+								  + initvalu[initvalu_offset_Dyad+8]
+								  + initvalu[initvalu_offset_Dyad+9])
+			   + initvalu[initvalu_offset_Dyad+12]
+			   + initvalu[initvalu_offset_Dyad+13]
+			   + initvalu[initvalu_offset_Dyad+14];
+	Bdyad = BtotDyad - CaMtotDyad;																				// [uM dyad]
+	J_cam_dyadSL = 1e-3 * (  k0Boff*initvalu[initvalu_offset_Dyad+0] - k0Bon*Bdyad*initvalu[initvalu_offset_SL+0]);			// [uM/msec dyad]
+	J_ca2cam_dyadSL = 1e-3 * (  k2Boff*initvalu[initvalu_offset_Dyad+1] - k2Bon*Bdyad*initvalu[initvalu_offset_SL+1]);		// [uM/msec dyad]
+	J_ca4cam_dyadSL = 1e-3 * (  k2Boff*initvalu[initvalu_offset_Dyad+2] - k4Bon*Bdyad*initvalu[initvalu_offset_SL+2]);		// [uM/msec dyad]
+	
+	J_cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+0] - initvalu[initvalu_offset_Cyt+0]);								// [umol/msec]
+	J_ca2cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+1] - initvalu[initvalu_offset_Cyt+1]);							// [umol/msec]
+	J_ca4cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+2] - initvalu[initvalu_offset_Cyt+2]);							// [umol/msec]
+	
+	// ADJUST CAM Dyad 
+	finavalu[initvalu_offset_Dyad+0] = finavalu[initvalu_offset_Dyad+0] - J_cam_dyadSL;
+	finavalu[initvalu_offset_Dyad+1] = finavalu[initvalu_offset_Dyad+1] - J_ca2cam_dyadSL;
+	finavalu[initvalu_offset_Dyad+2] = finavalu[initvalu_offset_Dyad+2] - J_ca4cam_dyadSL;
+	
+	// ADJUST CAM Sl
+	finavalu[initvalu_offset_SL+0] = finavalu[initvalu_offset_SL+0] + J_cam_dyadSL*Vdyad/VSL - J_cam_SLmyo/VSL;
+	finavalu[initvalu_offset_SL+1] = finavalu[initvalu_offset_SL+1] + J_ca2cam_dyadSL*Vdyad/VSL - J_ca2cam_SLmyo/VSL;
+	finavalu[initvalu_offset_SL+2] = finavalu[initvalu_offset_SL+2] + J_ca4cam_dyadSL*Vdyad/VSL - J_ca4cam_SLmyo/VSL;
+
+	// ADJUST CAM Cyt 
+	finavalu[initvalu_offset_Cyt+0] = finavalu[initvalu_offset_Cyt+0] + J_cam_SLmyo/Vmyo;
+	finavalu[initvalu_offset_Cyt+1] = finavalu[initvalu_offset_Cyt+1] + J_ca2cam_SLmyo/Vmyo;
+	finavalu[initvalu_offset_Cyt+2] = finavalu[initvalu_offset_Cyt+2] + J_ca4cam_SLmyo/Vmyo;
+
+}
+
+//=====================================================================
+//	MAIN FUNCTION
+//=====================================================================
+
+void master(fp timeinst,
+					fp* initvalu,
+					fp* parameter,
+					fp* finavalu,
+					int mode){
+
+	//=====================================================================
+	//	VARIABLES
+	//=====================================================================
+
+	// counters
+	int i;
+
+	// intermediate output on host
+	fp JCaDyad;
+	fp JCaSL;
+	fp JCaCyt;
+
+	// offset pointers
+	int initvalu_offset_batch;															//
+	int initvalu_offset_ecc;																// 46 points
+	int parameter_offset_ecc;
+	int initvalu_offset_Dyad;															// 15 points
+	int parameter_offset_Dyad;
+	int initvalu_offset_SL;																// 15 points
+	int parameter_offset_SL;
+	int initvalu_offset_Cyt;																// 15 poitns
+	int parameter_offset_Cyt;
+
+	// module parameters
+	fp CaDyad;																					// from ECC model, *** Converting from [mM] to [uM] ***
+	fp CaSL;																						// from ECC model, *** Converting from [mM] to [uM] ***
+	fp CaCyt;																					// from ECC model, *** Converting from [mM] to [uM] ***
+
+		// thread counters
+		int th_id, nthreads;
+		int th_count[4];
+		int temp;
+
+	//=====================================================================
+	//	KERNELS FOR 1 WORKLOAD - PARALLEL
+	//=====================================================================
+
+	nthreads = omp_get_max_threads();
+
+	if(mode == 0){
+
+		// partition workload between threads
+		temp = 0;
+		for(i=0; i<4; i++){													// do for all 4 pieces of work
+			if(temp>=nthreads){											// limit according to number of threads
+				temp = 0;
+			}
+			th_count[i] = temp;												// assign thread to piece of work
+			temp = temp +1;
+		}
+
+		// run pieces of work in parallel
+		#pragma omp parallel private(th_id)
+		{
+
+			if (th_id == th_count[1]) {
+
+				// ecc function
+				initvalu_offset_ecc = 0;												// 46 points
+				parameter_offset_ecc = 0;
+				ecc(						timeinst,
+											initvalu,
+											initvalu_offset_ecc,
+											parameter,
+											parameter_offset_ecc,
+											finavalu);
+
+			}
+
+			if (th_id == th_count[2]) {
+
+				// cam function for Dyad
+				initvalu_offset_Dyad = 46;											// 15 points
+				parameter_offset_Dyad = 1;
+				CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
+				JCaDyad = cam(timeinst,
+											initvalu,
+											initvalu_offset_Dyad,
+											parameter,
+											parameter_offset_Dyad,
+											finavalu,
+											CaDyad);
+
+			}
+
+			if (th_id == th_count[3]) {
+
+				// cam function for SL
+				initvalu_offset_SL = 61;											// 15 points
+				parameter_offset_SL = 6;
+				CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
+				JCaSL = cam(		timeinst,
+											initvalu,
+											initvalu_offset_SL,
+											parameter,
+											parameter_offset_SL,
+											finavalu,
+											CaSL);
+
+			}
+
+			if (th_id == th_count[4]) {
+
+				// cam function for Cyt
+				initvalu_offset_Cyt = 76;												// 15 poitns
+				parameter_offset_Cyt = 11;
+				CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
+				JCaCyt = cam(	timeinst,
+											initvalu,
+											initvalu_offset_Cyt,
+											parameter,
+											parameter_offset_Cyt,
+											finavalu,
+											CaCyt);
+
+			}
+
+		}
+
+	}
+
+	//=====================================================================
+	//	KERNELS FOR MANY WORKLOAD - SERIAL
+	//=====================================================================
+
+	else{
+
+		// ecc function
+		initvalu_offset_ecc = 0;												// 46 points
+		parameter_offset_ecc = 0;
+		ecc(						timeinst,
+									initvalu,
+									initvalu_offset_ecc,
+									parameter,
+									parameter_offset_ecc,
+									finavalu);
+
+		// cam function for Dyad
+		initvalu_offset_Dyad = 46;											// 15 points
+		parameter_offset_Dyad = 1;
+		CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
+		JCaDyad = cam(timeinst,
+									initvalu,
+									initvalu_offset_Dyad,
+									parameter,
+									parameter_offset_Dyad,
+									finavalu,
+									CaDyad);
+
+		// cam function for SL
+		initvalu_offset_SL = 61;											// 15 points
+		parameter_offset_SL = 6;
+		CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
+		JCaSL = cam(		timeinst,
+									initvalu,
+									initvalu_offset_SL,
+									parameter,
+									parameter_offset_SL,
+									finavalu,
+									CaSL);
+
+		// cam function for Cyt
+		initvalu_offset_Cyt = 76;												// 15 poitns
+		parameter_offset_Cyt = 11;
+		CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
+		JCaCyt = cam(	timeinst,
+									initvalu,
+									initvalu_offset_Cyt,
+									parameter,
+									parameter_offset_Cyt,
+									finavalu,
+									CaCyt);
+
+	}
+
+	//=====================================================================
+	//	FINAL KERNEL
+	//=====================================================================
+
+	// final adjustments
+	fin(						initvalu,
+								initvalu_offset_ecc,
+								initvalu_offset_Dyad,
+								initvalu_offset_SL,
+								initvalu_offset_Cyt,
+								parameter,
+								finavalu,
+								JCaDyad,
+								JCaSL,
+								JCaCyt);
+
+	//=====================================================================
+	//	COMPENSATION FOR NANs and INFs
+	//=====================================================================
+
+	// make sure function does not return NANs and INFs
+	for(i=0; i<EQUATIONS; i++){
+		if (isnan(finavalu[i]) == 1){ 
+			finavalu[i] = 0.0001;												// for NAN set rate of change to 0.0001
+		}
+		else if (isinf(finavalu[i]) == 1){ 
+			finavalu[i] = 0.0001;												// for INF set rate of change to 0.0001
+		}
+	}
+
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// File: embedded_fehlberg_7_8.c                                              //
+// Routines:                                                                  //
+//    Embedded_Fehlberg_7_8                                                   //
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+//                                                                            //
+//  Description:                                                              //
+//     The Runge-Kutta-Fehlberg method is an adaptive procedure for approxi-  //
+//     mating the solution of the differential equation y'(x) = f(x,y) with   //
+//     initial condition y(x0) = c.  This implementation evaluates f(x,y)     //
+//     thirteen times per step using embedded seventh order and eight order   //
+//     Runge-Kutta estimates to estimate the not only the solution but also   //
+//     the error.                                                             //
+//     The next step size is then calculated using the preassigned tolerance  //
+//     and error estimate.                                                    //
+//     For step i+1,                                                          //
+//        y[i+1] = y[i] +  h * (41/840 * k1 + 34/105 * finavalu_temp[5] + 9/35 * finavalu_temp[6]         //
+//                        + 9/35 * finavalu_temp[7] + 9/280 * finavalu_temp[8] + 9/280 finavalu_temp[9] + 41/840 finavalu_temp[10] ) //
+//     where                                                                  //
+//     k1 = f( x[i],y[i] ),                                                   //
+//     finavalu_temp[1] = f( x[i]+2h/27, y[i] + 2h*k1/27),                                  //
+//     finavalu_temp[2] = f( x[i]+h/9, y[i]+h/36*( k1 + 3 finavalu_temp[1]) ),                            //
+//     finavalu_temp[3] = f( x[i]+h/6, y[i]+h/24*( k1 + 3 finavalu_temp[2]) ),                            //
+//     finavalu_temp[4] = f( x[i]+5h/12, y[i]+h/48*(20 k1 - 75 finavalu_temp[2] + 75 finavalu_temp[3])),                //
+//     finavalu_temp[5] = f( x[i]+h/2, y[i]+h/20*( k1 + 5 finavalu_temp[3] + 4 finavalu_temp[4] ) ),                    //
+//     finavalu_temp[6] = f( x[i]+5h/6, y[i]+h/108*( -25 k1 + 125 finavalu_temp[3] - 260 finavalu_temp[4] + 250 finavalu_temp[5] ) ), //
+//     finavalu_temp[7] = f( x[i]+h/6, y[i]+h*( 31/300 k1 + 61/225 finavalu_temp[4] - 2/9 finavalu_temp[5]              //
+//                                                            + 13/900 finavalu_temp[6]) )  //
+//     finavalu_temp[8] = f( x[i]+2h/3, y[i]+h*( 2 k1 - 53/6 finavalu_temp[3] + 704/45 finavalu_temp[4] - 107/9 finavalu_temp[5]      //
+//                                                      + 67/90 finavalu_temp[6] + 3 finavalu_temp[7]) ), //
+//     finavalu_temp[9] = f( x[i]+h/3, y[i]+h*( -91/108 k1 + 23/108 finavalu_temp[3] - 976/135 finavalu_temp[4]        //
+//                             + 311/54 finavalu_temp[5] - 19/60 finavalu_temp[6] + 17/6 finavalu_temp[7] - 1/12 finavalu_temp[8]) ), //
+//     finavalu_temp[10] = f( x[i]+h, y[i]+h*( 2383/4100 k1 - 341/164 finavalu_temp[3] + 4496/1025 finavalu_temp[4]     //
+//          - 301/82 finavalu_temp[5] + 2133/4100 finavalu_temp[6] + 45/82 finavalu_temp[7] + 45/164 finavalu_temp[8] + 18/41 finavalu_temp[9]) )  //
+//     finavalu_temp[11] = f( x[i], y[i]+h*( 3/205 k1 - 6/41 finavalu_temp[5] - 3/205 finavalu_temp[6] - 3/41 finavalu_temp[7]        //
+//                                                   + 3/41 finavalu_temp[8] + 6/41 finavalu_temp[9]) )  //
+//     finavalu_temp[12] = f( x[i]+h, y[i]+h*( -1777/4100 k1 - 341/164 finavalu_temp[3] + 4496/1025 finavalu_temp[4]    //
+//                      - 289/82 finavalu_temp[5] + 2193/4100 finavalu_temp[6] + 51/82 finavalu_temp[7] + 33/164 finavalu_temp[8] +   //
+//                                                        12/41 finavalu_temp[9] + finavalu_temp[11]) )  //
+//     x[i+1] = x[i] + h.                                                     //
+//                                                                            //
+//     The error is estimated to be                                           //
+//        err = -41/840 * h * ( k1 + finavalu_temp[10] - finavalu_temp[11] - finavalu_temp[12])                         //
+//     The step size h is then scaled by the scale factor                     //
+//         scale = 0.8 * | epsilon * y[i] / [err * (xmax - x[0])] | ^ 1/7     //
+//     The scale factor is further constrained 0.125 < scale < 4.0.           //
+//     The new step size is h := scale * h.                                   //
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+//  static fp Runge_Kutta(fp (*f)(fp,fp), fp *y,          //
+//                                                       fp x0, fp h) //
+//                                                                            //
+//  Description:                                                              //
+//     This routine uses Fehlberg's embedded 7th and 8th order methods to     //
+//     approximate the solution of the differential equation y'=f(x,y) with   //
+//     the initial condition y = y[0] at x = x0.  The value at x + h is       //
+//     returned in y[1].  The function returns err / h ( the absolute error   //
+//     per step size ).                                                       //
+//                                                                            //
+//  Arguments:                                                                //
+//     fp *f  Pointer to the function which returns the slope at (x,y) of //
+//                integral curve of the differential equation y' = f(x,y)     //
+//                which passes through the point (x0,y[0]).                   //
+//     fp y[] On input y[0] is the initial value of y at x, on output     //
+//                y[1] is the solution at x + h.                              //
+//     fp x   Initial value of x.                                         //
+//     fp h   Step size                                                   //
+//                                                                            //
+//  Return Values:                                                            //
+//     This routine returns the err / h.  The solution of y(x) at x + h is    //
+//     returned in y[1].                                                      //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+//		PARTICULAR SOLVER FUNCTION
+//===============================================================================================================================================================================================================
+//===============================================================================================================================================================================================================
+
+static fp embedded_fehlberg_7_8(	fp timeinst,
+															fp h,
+															fp* initvalu,
+															fp* finavalu,
+															fp* error,
+															fp* parameter,
+															int mode) {
+
+	// printf("initvalu[0] = %f\n", initvalu[0]);
+	// printf("initvalu[10] = %f\n", initvalu[10]);
+	// printf("initvalu[50] = %f\n", initvalu[50]);
+	// printf("initvalu[90] = %f\n", initvalu[90]);
+
+	// printf("finavalu[0] = %f\n", finavalu[0]);
+	// printf("finavalu[10] = %f\n", finavalu[10]);
+	// printf("finavalu[50] = %f\n", finavalu[50]);
+	// printf("finavalu[90] = %f\n", finavalu[90]);
+
+	//======================================================================================================================================================
+	//	VARIABLES
+	//======================================================================================================================================================
+
+	static const fp c_1_11 = 41.0 / 840.0;
+	static const fp c6 = 34.0 / 105.0;
+	static const fp c_7_8= 9.0 / 35.0;
+	static const fp c_9_10 = 9.0 / 280.0;
+
+	static const fp a2 = 2.0 / 27.0;
+	static const fp a3 = 1.0 / 9.0;
+	static const fp a4 = 1.0 / 6.0;
+	static const fp a5 = 5.0 / 12.0;
+	static const fp a6 = 1.0 / 2.0;
+	static const fp a7 = 5.0 / 6.0;
+	static const fp a8 = 1.0 / 6.0;
+	static const fp a9 = 2.0 / 3.0;
+	static const fp a10 = 1.0 / 3.0;
+
+	static const fp b31 = 1.0 / 36.0;
+	static const fp b32 = 3.0 / 36.0;
+	static const fp b41 = 1.0 / 24.0;
+	static const fp b43 = 3.0 / 24.0;
+	static const fp b51 = 20.0 / 48.0;
+	static const fp b53 = -75.0 / 48.0;
+	static const fp b54 = 75.0 / 48.0;
+	static const fp b61 = 1.0 / 20.0;
+	static const fp b64 = 5.0 / 20.0;
+	static const fp b65 = 4.0 / 20.0;
+	static const fp b71 = -25.0 / 108.0;
+	static const fp b74 =  125.0 / 108.0;
+	static const fp b75 = -260.0 / 108.0;
+	static const fp b76 =  250.0 / 108.0;
+	static const fp b81 = 31.0/300.0;
+	static const fp b85 = 61.0/225.0;
+	static const fp b86 = -2.0/9.0;
+	static const fp b87 = 13.0/900.0;
+	static const fp b91 = 2.0;
+	static const fp b94 = -53.0/6.0;
+	static const fp b95 = 704.0 / 45.0;
+	static const fp b96 = -107.0 / 9.0;
+	static const fp b97 = 67.0 / 90.0;
+	static const fp b98 = 3.0;
+	static const fp b10_1 = -91.0 / 108.0;
+	static const fp b10_4 = 23.0 / 108.0;
+	static const fp b10_5 = -976.0 / 135.0;
+	static const fp b10_6 = 311.0 / 54.0;
+	static const fp b10_7 = -19.0 / 60.0;
+	static const fp b10_8 = 17.0 / 6.0;
+	static const fp b10_9 = -1.0 / 12.0;
+	static const fp b11_1 = 2383.0 / 4100.0;
+	static const fp b11_4 = -341.0 / 164.0;
+	static const fp b11_5 = 4496.0 / 1025.0;
+	static const fp b11_6 = -301.0 / 82.0;
+	static const fp b11_7 = 2133.0 / 4100.0;
+	static const fp b11_8 = 45.0 / 82.0;
+	static const fp b11_9 = 45.0 / 164.0;
+	static const fp b11_10 = 18.0 / 41.0;
+	static const fp b12_1 = 3.0 / 205.0;
+	static const fp b12_6 = - 6.0 / 41.0;
+	static const fp b12_7 = - 3.0 / 205.0;
+	static const fp b12_8 = - 3.0 / 41.0;
+	static const fp b12_9 = 3.0 / 41.0;
+	static const fp b12_10 = 6.0 / 41.0;
+	static const fp b13_1 = -1777.0 / 4100.0;
+	static const fp b13_4 = -341.0 / 164.0;
+	static const fp b13_5 = 4496.0 / 1025.0;
+	static const fp b13_6 = -289.0 / 82.0;
+	static const fp b13_7 = 2193.0 / 4100.0;
+	static const fp b13_8 = 51.0 / 82.0;
+	static const fp b13_9 = 33.0 / 164.0;
+	static const fp b13_10 = 12.0 / 41.0;
+
+	static const fp err_factor  = -41.0 / 840.0;
+
+	fp h2_7 = a2 * h;
+
+	fp timeinst_temp;
+	fp* initvalu_temp;
+	fp** finavalu_temp;
+
+	int i;
+
+	//======================================================================================================================================================
+	//		TEMPORARY STORAGE ALLOCATION
+	//======================================================================================================================================================
+
+	initvalu_temp= (fp *) malloc(EQUATIONS* sizeof(fp));
+
+	finavalu_temp= (fp **) malloc(13* sizeof(fp *));
+	for (i= 0; i<13; i++){
+		finavalu_temp[i]= (fp *) malloc(EQUATIONS* sizeof(fp));
+	}
+
+	//======================================================================================================================================================
+	//		EVALUATIONS
+	//======================================================================================================================================================
+
+	//===================================================================================================
+	//		1
+	//===================================================================================================
+
+	timeinst_temp = timeinst;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] ;
+		// printf("initvalu[%d] = %f\n", i, initvalu[i]);
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[0],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[0][%d] = %f\n", i, finavalu_temp[0][i]);
+	// }
+
+	//===================================================================================================
+	//		2
+	//===================================================================================================
+
+	timeinst_temp = timeinst+h2_7;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h2_7 * (finavalu_temp[0][i]);
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[1],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[1][%d] = %f\n", i, finavalu_temp[1][i]);
+	// }
+
+	//===================================================================================================
+	//		3
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a3*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b31*finavalu_temp[0][i] + b32*finavalu_temp[1][i]);
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[2],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[2][%d] = %f\n", i, finavalu_temp[2][i]);
+	// }
+
+	//===================================================================================================
+	//		4
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a4*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b41*finavalu_temp[0][i] + b43*finavalu_temp[2][i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[3],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[3][%d] = %f\n", i, finavalu_temp[3][i]);
+	// }
+
+	//===================================================================================================
+	//		5
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a5*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b51*finavalu_temp[0][i] + b53*finavalu_temp[2][i] + b54*finavalu_temp[3][i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[4],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[4][%d] = %f\n", i, finavalu_temp[4][i]);
+	// }
+
+	//===================================================================================================
+	//		6
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a6*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b61*finavalu_temp[0][i] + b64*finavalu_temp[3][i] + b65*finavalu_temp[4][i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[5],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[5][%d] = %f\n", i, finavalu_temp[5][i]);
+	// }
+
+	//===================================================================================================
+	//		7
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a7*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b71*finavalu_temp[0][i] + b74*finavalu_temp[3][i] + b75*finavalu_temp[4][i] + b76*finavalu_temp[5][i]);
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[6],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[6][%d] = %f\n", i, finavalu_temp[6][i]);
+	// }
+
+	//===================================================================================================
+	//		8
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a8*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b81*finavalu_temp[0][i] + b85*finavalu_temp[4][i] + b86*finavalu_temp[5][i] + b87*finavalu_temp[6][i]);
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[7],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[7][%d] = %f\n", i, finavalu_temp[7][i]);
+	// }
+
+	//===================================================================================================
+	//		9
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a9*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b91*finavalu_temp[0][i] + b94*finavalu_temp[3][i] + b95*finavalu_temp[4][i] + b96*finavalu_temp[5][i] + b97*finavalu_temp[6][i]+ b98*finavalu_temp[7][i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[8],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[8][%d] = %f\n", i, finavalu_temp[8][i]);
+	// }
+
+	//===================================================================================================
+	//		10
+	//===================================================================================================
+
+	timeinst_temp = timeinst+a10*h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b10_1*finavalu_temp[0][i] + b10_4*finavalu_temp[3][i] + b10_5*finavalu_temp[4][i] + b10_6*finavalu_temp[5][i] + b10_7*finavalu_temp[6][i] + b10_8*finavalu_temp[7][i] + b10_9*finavalu_temp[8] [i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[9],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[9][%d] = %f\n", i, finavalu_temp[9][i]);
+	// }
+
+	//===================================================================================================
+	//		11
+	//===================================================================================================
+
+	timeinst_temp = timeinst+h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b11_1*finavalu_temp[0][i] + b11_4*finavalu_temp[3][i] + b11_5*finavalu_temp[4][i] + b11_6*finavalu_temp[5][i] + b11_7*finavalu_temp[6][i] + b11_8*finavalu_temp[7][i] + b11_9*finavalu_temp[8][i]+ b11_10 * finavalu_temp[9][i]);
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[10],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[10][%d] = %f\n", i, finavalu_temp[10][i]);
+	// }
+
+	//===================================================================================================
+	//		12
+	//===================================================================================================
+
+	timeinst_temp = timeinst;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b12_1*finavalu_temp[0][i] + b12_6*finavalu_temp[5][i] + b12_7*finavalu_temp[6][i] + b12_8*finavalu_temp[7][i] + b12_9*finavalu_temp[8][i] + b12_10 * finavalu_temp[9][i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[11],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[11][%d] = %f\n", i, finavalu_temp[11][i]);
+	// }
+
+	//===================================================================================================
+	//		13
+	//===================================================================================================
+
+	timeinst_temp = timeinst+h;
+	for(i=0; i<EQUATIONS; i++){
+		initvalu_temp[i] = initvalu[i] + h * ( b13_1*finavalu_temp[0][i] + b13_4*finavalu_temp[3][i] + b13_5*finavalu_temp[4][i] + b13_6*finavalu_temp[5][i] + b13_7*finavalu_temp[6][i] + b13_8*finavalu_temp[7][i] + b13_9*finavalu_temp[8][i] + b13_10*finavalu_temp[9][i] + finavalu_temp[11][i]) ;
+	}
+
+	master(	timeinst_temp,
+					initvalu_temp,
+					parameter,
+					finavalu_temp[12],
+					mode);
+
+	// for(i=0; i<EQUATIONS; i++){
+		// printf("finavalu_temp[12][%d] = %f\n", i, finavalu_temp[12][i]);
+	// }
+
+	//======================================================================================================================================================
+	//		FINAL VALUE
+	//======================================================================================================================================================
+
+	for(i=0; i<EQUATIONS; i++){
+		finavalu[i]= initvalu[i] +  h * (c_1_11 * (finavalu_temp[0][i] + finavalu_temp[10][i])  + c6 * finavalu_temp[5][i] + c_7_8 * (finavalu_temp[6][i] + finavalu_temp[7][i]) + c_9_10 * (finavalu_temp[8][i] + finavalu_temp[9][i]) );
+		// printf("finavalu_temp[0][%d] = %f\n", i, finavalu_temp[0][i]);
+		// printf("finavalu_temp[10][%d] = %f\n", i, finavalu_temp[10][i]);
+		// printf("finavalu_temp[5][%d] = %f\n", i, finavalu_temp[5][i]);
+		// printf("finavalu_temp[6][%d] = %f\n", i, finavalu_temp[6][i]);
+		// printf("finavalu_temp[7][%d] = %f\n", i, finavalu_temp[7][i]);
+		// printf("finavalu_temp[8][%d] = %f\n", i, finavalu_temp[8][i]);
+		// printf("finavalu_temp[9][%d] = %f\n", i, finavalu_temp[9][i]);
+		// printf("finavalu[%d] = %f\n", i, finavalu[i]);
+	}
+
+	//======================================================================================================================================================
+	//		RETURN
+	//======================================================================================================================================================
+
+	for(i=0; i<EQUATIONS; i++){
+		error[i] = fabs(err_factor * (finavalu_temp[0][i] + finavalu_temp[10][i] - finavalu_temp[11][i] - finavalu_temp[12][i]));
+		// printf("Error[%d] = %f\n", i, error[i]);
+	}
+
+	//======================================================================================================================================================
+	//		DEALLOCATION
+	//======================================================================================================================================================
+
+	free(initvalu_temp);
+	free(finavalu_temp);
+
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// int solver( fp (*f)(fp, fp), fp y[],        //
+//       fp x, fp h, fp xmax, fp *h_next, fp tolerance )  //
+//                                                                            //
+//  Description:                                                              //
+//     This function solves the differential equation y'=f(x,y) with the      //
+//     initial condition y(x) = y[0].  The value at xmax is returned in y[1]. //
+//     The function returns 0 if successful or -1 if it fails.                //
+//                                                                            //
+//  Arguments:                                                                //
+//     fp *f  Pointer to the function which returns the slope at (x,y) of //
+//                integral curve of the differential equation y' = f(x,y)     //
+//                which passes through the point (x0,y0) corresponding to the //
+//                initial condition y(x0) = y0.                               //
+//     fp y[] On input y[0] is the initial value of y at x, on output     //
+//                y[1] is the solution at xmax.                               //
+//     fp x   The initial value of x.                                     //
+//     fp h   Initial step size.                                          //
+//     fp xmax The endpoint of x.                                         //
+//     fp *h_next   A pointer to the estimated step size for successive   //
+//                      calls to solver.                       //
+//     fp tolerance The tolerance of y(xmax), i.e. a solution is sought   //
+//                so that the relative error < tolerance.                     //
+//                                                                            //
+//  Return Values:                                                            //
+//     0   The solution of y' = f(x,y) from x to xmax is stored y[1] and      //
+//         h_next has the value to the next size to try.                      //
+//    -1   The solution of y' = f(x,y) from x to xmax failed.                 //
+//    -2   Failed because either xmax < x or the step size h <= 0.            //
+//    -3   Memory limit allocated for results was reached                                //
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+//	Summary of changes by Lukasz G. Szafaryn:
+
+//	1) The original code was obtained from: Mathematics Source Library (http://mymathlib.webtrellis.net/index.html)
+// 2) This solver and particular solving algorithm used with it (embedded_fehlberg_7_8) were adapted to work with a set of equations, not just one like in original version.
+
+//	3) In order for solver to provide deterministic number of steps (needed for particular amount of memore previousely allocated for results), every next step is incremented by 1 time unit (h_init).
+//	4) Function assumes that time interval starts at 0 (xmin) and ends at integer value (xmax) specified by the uses as a parameter on command line.
+// 5) The appropriate amount of memory is previousely allocated for that range (y).
+
+//	5) This setup in 3) - 5) allows solver to adjust the step ony from current time instance to current time instance + 0.9. The next time instance is current time instance + 1;
+
+//	6) Solver also takes parameters (params) that it then passes to the equations.
+
+//	7) The original solver cannot handle cases when equations return NAN and INF values due to discontinuities and /0. That is why equations provided by user need to make sure that no NAN and INF are returned.
+
+//	Last update: 15 DEC 09
+////////////////////////////////////////////////////////////////////////////////
+
+//======================================================================================================================================================
+//======================================================================================================================================================
+//		INCLUDE
+//======================================================================================================================================================
+//======================================================================================================================================================
+
+#include <math.h>
+
+#define max(x,y) ( (x) < (y) ? (y) : (x) )
+#define min(x,y) ( (x) < (y) ? (x) : (y) )
+
+#define ATTEMPTS 12
+#define MIN_SCALE_FACTOR 0.125
+#define MAX_SCALE_FACTOR 4.0
+
+//======================================================================================================================================================
+//======================================================================================================================================================
+//		SOLVER FUNCTION
+//======================================================================================================================================================
+//======================================================================================================================================================
+
+int solver(	fp** y,
+					fp* x,
+					int xmax,
+					fp* params,
+					int mode) {
+
+	//========================================================================================================================
+	//	VARIABLES
+	//========================================================================================================================
+
+	// solver parameters
+	fp err_exponent;
+	fp last_interval;
+	int error;
+	int outside;
+	fp h;
+	fp h_init;
+	fp tolerance;
+	int xmin;
+
+	// memory
+	fp scale_min;
+	fp scale_fina;
+	fp* err= (fp *) malloc(EQUATIONS* sizeof(fp));
+	fp* scale= (fp *) malloc(EQUATIONS* sizeof(fp));
+	fp* yy= (fp *) malloc(EQUATIONS* sizeof(fp));
+
+	// counters
+	int i, j, k;
+
+	//========================================================================================================================
+	//		INITIAL SETUP
+	//========================================================================================================================
+
+	// solver parameters
+	err_exponent = 1.0 / 7.0;
+	last_interval = 0;
+	h_init = 1;
+	h = h_init;
+	xmin = 0;
+	tolerance = 10 / (fp)(xmax-xmin);
+
+	// save value for initial time instance
+	x[0] = 0;
+
+	//========================================================================================================================
+	//		CHECKING
+	//========================================================================================================================
+
+	// Verify that the step size is positive and that the upper endpoint of integration is greater than the initial enpoint.               //
+	if (xmax < xmin || h <= 0.0){
+		return -2;
+	}
+
+	// If the upper endpoint of the independent variable agrees with the initial value of the independent variable.  Set the value of the dependent variable and return success. //
+	if (xmax == xmin){
+		return 0; 
+	}
+
+	// Insure that the step size h is not larger than the length of the integration interval.                                            //
+	if (h > (xmax - xmin) ) { 
+		h = (fp)xmax - (fp)xmin; 
+		last_interval = 1;
+	}
+
+	//========================================================================================================================
+	//		SOLVING
+	//========================================================================================================================
+
+	for(k=1; k<=xmax; k++) {											// start after initial value
+
+		x[k] = k-1;
+		h = h_init;
+
+		//==========================================================================================
+		//		REINITIALIZE VARIABLES
+		//==========================================================================================
+
+		scale_fina = 1.0;
+
+		//==========================================================================================
+		//		MAKE ATTEMPTS TO MINIMIZE ERROR
+		//==========================================================================================
+
+		// make attempts to minimize error
+		for (j = 0; j < ATTEMPTS; j++) {
+
+			//============================================================
+			//		REINITIALIZE VARIABLES
+			//============================================================
+
+			error = 0;
+			outside = 0;
+			scale_min = MAX_SCALE_FACTOR;
+
+			//============================================================
+			//		EVALUATE ALL EQUATIONS
+			//============================================================
+
+			embedded_fehlberg_7_8(	x[k],
+														h,
+														y[k-1],
+														y[k],
+														err,
+														params,
+														mode);
+
+			//============================================================
+			//		IF THERE WAS NO ERROR FOR ANY OF EQUATIONS, SET SCALE AND LEAVE THE LOOP
+			//============================================================
+
+			for(i=0; i<EQUATIONS; i++){
+				if(err[i] > 0){
+					error = 1;
+				}
+			}
+			if (error != 1) {
+				scale_fina = MAX_SCALE_FACTOR; 
+				break;
+			}
+
+			//============================================================
+			//		FIGURE OUT SCALE AS THE MINIMUM OF COMPONENT SCALES
+			//============================================================
+
+			for(i=0; i<EQUATIONS; i++){
+				if(y[k-1][i] == 0.0){
+					yy[i] = tolerance;
+				}
+				else{
+					yy[i] = fabs(y[k-1][i]);
+				}
+				scale[i] = 0.8 * pow( tolerance * yy[i] / err[i] , err_exponent );
+				if(scale[i]<scale_min){
+					scale_min = scale[i];
+				}
+			}
+			scale_fina = min( max(scale_min,MIN_SCALE_FACTOR), MAX_SCALE_FACTOR);
+
+			//============================================================
+			//		IF WITHIN TOLERANCE, FINISH ATTEMPTS...
+			//============================================================
+
+			for(i=0; i<EQUATIONS; i++){
+				if ( err[i] > ( tolerance * yy[i] ) ){
+					outside = 1;
+				}
+			}
+			if (outside == 0){
+				break;
+			}
+
+			//============================================================
+			//		...OTHERWISE, ADJUST STEP FOR NEXT ATTEMPT
+			//============================================================
+
+			// scale next step in a default way
+			h = h * scale_fina;
+
+			// limit step to 0.9, because when it gets close to 1, it no longer makes sense, as 1 is already the next time instance (added to original algorithm)
+			if (h >= 0.9) {
+				h = 0.9;
+			}
+
+			// if instance+step exceeds range limit, limit to that range
+			if ( x[k] + h > (fp)xmax ){
+				h = (fp)xmax - x[k];
+			}
+
+			// if getting closer to range limit, decrease step
+			else if ( x[k] + h + 0.5 * h > (fp)xmax ){
+				h = 0.5 * h;
+			}
+
+		}
+
+		//==========================================================================================
+		//		SAVE TIME INSTANCE THAT SOLVER ENDED UP USING
+		//==========================================================================================
+
+		x[k] = x[k] + h;
+
+		//==========================================================================================
+		//		IF MAXIMUM NUMBER OF ATTEMPTS REACHED AND CANNOT GIVE SOLUTION, EXIT PROGRAM WITH ERROR
+		//==========================================================================================
+
+		if ( j >= ATTEMPTS ) {
+			return -1; 
+		}
+
+	}
+
+	//========================================================================================================================
+	//		FREE MEMORY
+	//========================================================================================================================
+
+	free(err);
+	free(scale);
+	free(yy);
+
+	//========================================================================================================================
+	//		FINAL RETURN
+	//========================================================================================================================
+
+	return 0;
+
+//======================================================================================================================================================
+//======================================================================================================================================================
+//		END OF SOLVER FUNCTION
+//======================================================================================================================================================
+//======================================================================================================================================================
+
+} 
+
+
+//========================================================================================================================
+//	INCLUDE/DEFINE
+//========================================================================================================================
+
+// #include <stdlib.h>
+// #include <string.h>
+#include <stdio.h>
+// #include <math.h>
+// #include <time.h>
+// #include <sys/types.h>
+// #include <dirent.h>
+// #include <errno.h>
+
+//========================================================================================================================
+//	WRITE FUNCTION
+//========================================================================================================================
+
+void write(	char* filename,
+					fp* input, 
+					int data_rows, 
+					int data_cols, 
+					int major,
+					int data_range){
+
+	//=====================================================================
+	//	VARIABLES
+	//=====================================================================
+
+	FILE* fid;
+	int i, j;
+
+	//=====================================================================
+	//	CREATE/OPEN FILE FOR WRITING
+	//=====================================================================
+
+	fid = fopen(filename, "w");
+	if( fid == NULL ){
+		printf( "The file was not created/opened for writing\n" );
+		return;
+	}
+
+	//=====================================================================
+	//	WRITE VALUES TO THE FILE
+	//=====================================================================
+
+	// if matrix is saved row major in memory (C)
+	if(major==0){
+		for(i=0; i<data_rows; i++){
+			for(j=0; j<data_cols; j++){
+				fprintf(fid, "%f ", (fp)input[i*data_cols+j]);
+			}
+			fprintf(fid, "\n");
+		}
+	}
+	// if matrix is saved column major in memory (MATLAB)
+	else{
+		for(i=0; i<data_rows; i++){
+			for(j=0; j<data_cols; j++){
+				fprintf(fid, "%f ", (fp)input[j*data_rows+i]);
+			}
+			fprintf(fid, "\n");
+		}
+	}
+
+	//=====================================================================
+	//	CLOSE FILE
+	//=====================================================================
+
+	fclose(fid);
+
+}
+
+//========================================================================================================================
+//	READ FUNCTION
+//========================================================================================================================
+
+void read(	char* filename,
+					fp* input,
+					int data_rows, 
+					int data_cols,
+					int major){
+
+	//=====================================================================
+	//	VARIABLES
+	//=====================================================================
+
+	FILE* fid;
+	int i, j;
+	char c;
+	fp temp;
+
+	//=====================================================================
+	//	OPEN FILE FOR READING
+	//=====================================================================
+
+	fid = fopen(filename, "r");
+	if( fid == NULL ){
+		printf( "The file was not opened for reading\n" );
+		return;
+	}
+
+	//=====================================================================
+	//	READ VALUES FROM THE FILE
+	//=====================================================================
+
+	if(major==0){																// if matrix is saved row major in memory (C)
+		for(i=0; i<data_rows; i++){
+			for(j=0; j<data_cols; j++){
+				fscanf(fid, "%f", &temp);
+				input[i*data_cols+j] = (fp)temp;
+			}
+		}
+	}
+	else{																				// if matrix is saved column major in memory (MATLAB)
+		for(i=0; i<data_rows; i++){
+			for(j=0; j<data_cols; j++){
+				fscanf(fid, "%f", &temp);
+				input[j*data_rows+i] = (fp)temp;
+			}
+		}
+	}
+
+	//=====================================================================
+	//	CLOSE FILE
+	//=====================================================================
+
+	fclose(fid);
+
+}
+
+#include <stdlib.h>
+#include <sys/time.h>
 
-#include "file.c"
-#include "timer.c"
+ // Returns the current system time in microseconds
+long long get_time() {
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (tv.tv_sec * 1000000) + tv.tv_usec;
+}
 
 //====================================================================================================100
 //	MAIN FUNCTION
@@ -256,7 +2809,7 @@
 
 	// y
 	for(i=0; i<workload; i++){
-		read(	"../../data/myocyte/y.txt",
+		read(	"y.txt",
 					y[i][0],
 					91,
 					1,
@@ -265,7 +2818,7 @@
 
 	// params
 	for(i=0; i<workload; i++){
-		read(	"../../data/myocyte/params.txt",
+		read(	"params.txt",
 					params[i],
 					16,
 					1,
@@ -365,7 +2918,7 @@
 	printf("%.12f s, %.12f % : READ DATA FROM FILES\n", 												(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time5-time0) * 100);
 	printf("%.12f s, %.12f % : RUN COMPUTATION\n", 														(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time5-time0) * 100);
 	printf("%.12f s, %.12f % : FREE MEMORY\n", 																(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time5-time0) * 100);
-	printf("Total time:\n");
+	printf("Total time: ");
 	printf("%.12f s\n", 																											(float) (time5-time0) / 1000000);
 
 //====================================================================================================100
diff -ruN rodinia_3.1/openmp/myocyte/Makefile rodinia_3.1_new/openmp/myocyte/Makefile
--- rodinia_3.1/openmp/myocyte/Makefile	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/myocyte/Makefile	2024-08-29 14:50:13.820123514 -0700
@@ -7,26 +7,17 @@
           # .
 	# command n
 
+CC = gcc
+CC_FLAGS = -g -O3 -fopenmp
+
 # link objects(binaries) together
 myocyte.out:	main.o
-	gcc	main.o \
-			-lm -fopenmp \
-	-o myocyte.out
+	$(CC) $(CC_FLAGS) main.o -o myocyte.out -lm
 
 # compile main function file into object (binary)
-main.o: 	main.c \
-				define.c \
-				ecc.c \
-				cam.c \
-				fin.c \
-				master.c \
-				embedded_fehlberg_7_8.c \
-				solver.c \
-				file.c \
-				timer.c
-	gcc	main.c \
-			-c -O3 -fopenmp
+main.o: 	main.c
+	$(CC) $(CC_FLAGS) main.c -c
 
 # delete all object files
 clean:
-	rm *.o myocyte.out output.txt
+	rm *.o myocyte.out
diff -ruN rodinia_3.1/openmp/myocyte/master.c rodinia_3.1_new/openmp/myocyte/master.c
--- rodinia_3.1/openmp/myocyte/master.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/master.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,216 +0,0 @@
-//=====================================================================
-//	MAIN FUNCTION
-//=====================================================================
-
-void master(fp timeinst,
-					fp* initvalu,
-					fp* parameter,
-					fp* finavalu,
-					int mode){
-
-	//=====================================================================
-	//	VARIABLES
-	//=====================================================================
-
-	// counters
-	int i;
-
-	// intermediate output on host
-	fp JCaDyad;
-	fp JCaSL;
-	fp JCaCyt;
-
-	// offset pointers
-	int initvalu_offset_batch;															//
-	int initvalu_offset_ecc;																// 46 points
-	int parameter_offset_ecc;
-	int initvalu_offset_Dyad;															// 15 points
-	int parameter_offset_Dyad;
-	int initvalu_offset_SL;																// 15 points
-	int parameter_offset_SL;
-	int initvalu_offset_Cyt;																// 15 poitns
-	int parameter_offset_Cyt;
-
-	// module parameters
-	fp CaDyad;																					// from ECC model, *** Converting from [mM] to [uM] ***
-	fp CaSL;																						// from ECC model, *** Converting from [mM] to [uM] ***
-	fp CaCyt;																					// from ECC model, *** Converting from [mM] to [uM] ***
-
-		// thread counters
-		int th_id, nthreads;
-		int th_count[4];
-		int temp;
-
-	//=====================================================================
-	//	KERNELS FOR 1 WORKLOAD - PARALLEL
-	//=====================================================================
-
-	nthreads = omp_get_max_threads();
-
-	if(mode == 0){
-
-		// partition workload between threads
-		temp = 0;
-		for(i=0; i<4; i++){													// do for all 4 pieces of work
-			if(temp>=nthreads){											// limit according to number of threads
-				temp = 0;
-			}
-			th_count[i] = temp;												// assign thread to piece of work
-			temp = temp +1;
-		}
-
-		// run pieces of work in parallel
-		#pragma omp parallel private(th_id)
-		{
-
-			if (th_id == th_count[1]) {
-
-				// ecc function
-				initvalu_offset_ecc = 0;												// 46 points
-				parameter_offset_ecc = 0;
-				ecc(						timeinst,
-											initvalu,
-											initvalu_offset_ecc,
-											parameter,
-											parameter_offset_ecc,
-											finavalu);
-
-			}
-
-			if (th_id == th_count[2]) {
-
-				// cam function for Dyad
-				initvalu_offset_Dyad = 46;											// 15 points
-				parameter_offset_Dyad = 1;
-				CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
-				JCaDyad = cam(timeinst,
-											initvalu,
-											initvalu_offset_Dyad,
-											parameter,
-											parameter_offset_Dyad,
-											finavalu,
-											CaDyad);
-
-			}
-
-			if (th_id == th_count[3]) {
-
-				// cam function for SL
-				initvalu_offset_SL = 61;											// 15 points
-				parameter_offset_SL = 6;
-				CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
-				JCaSL = cam(		timeinst,
-											initvalu,
-											initvalu_offset_SL,
-											parameter,
-											parameter_offset_SL,
-											finavalu,
-											CaSL);
-
-			}
-
-			if (th_id == th_count[4]) {
-
-				// cam function for Cyt
-				initvalu_offset_Cyt = 76;												// 15 poitns
-				parameter_offset_Cyt = 11;
-				CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
-				JCaCyt = cam(	timeinst,
-											initvalu,
-											initvalu_offset_Cyt,
-											parameter,
-											parameter_offset_Cyt,
-											finavalu,
-											CaCyt);
-
-			}
-
-		}
-
-	}
-
-	//=====================================================================
-	//	KERNELS FOR MANY WORKLOAD - SERIAL
-	//=====================================================================
-
-	else{
-
-		// ecc function
-		initvalu_offset_ecc = 0;												// 46 points
-		parameter_offset_ecc = 0;
-		ecc(						timeinst,
-									initvalu,
-									initvalu_offset_ecc,
-									parameter,
-									parameter_offset_ecc,
-									finavalu);
-
-		// cam function for Dyad
-		initvalu_offset_Dyad = 46;											// 15 points
-		parameter_offset_Dyad = 1;
-		CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
-		JCaDyad = cam(timeinst,
-									initvalu,
-									initvalu_offset_Dyad,
-									parameter,
-									parameter_offset_Dyad,
-									finavalu,
-									CaDyad);
-
-		// cam function for SL
-		initvalu_offset_SL = 61;											// 15 points
-		parameter_offset_SL = 6;
-		CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
-		JCaSL = cam(		timeinst,
-									initvalu,
-									initvalu_offset_SL,
-									parameter,
-									parameter_offset_SL,
-									finavalu,
-									CaSL);
-
-		// cam function for Cyt
-		initvalu_offset_Cyt = 76;												// 15 poitns
-		parameter_offset_Cyt = 11;
-		CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***
-		JCaCyt = cam(	timeinst,
-									initvalu,
-									initvalu_offset_Cyt,
-									parameter,
-									parameter_offset_Cyt,
-									finavalu,
-									CaCyt);
-
-	}
-
-	//=====================================================================
-	//	FINAL KERNEL
-	//=====================================================================
-
-	// final adjustments
-	fin(						initvalu,
-								initvalu_offset_ecc,
-								initvalu_offset_Dyad,
-								initvalu_offset_SL,
-								initvalu_offset_Cyt,
-								parameter,
-								finavalu,
-								JCaDyad,
-								JCaSL,
-								JCaCyt);
-
-	//=====================================================================
-	//	COMPENSATION FOR NANs and INFs
-	//=====================================================================
-
-	// make sure function does not return NANs and INFs
-	for(i=0; i<EQUATIONS; i++){
-		if (isnan(finavalu[i]) == 1){ 
-			finavalu[i] = 0.0001;												// for NAN set rate of change to 0.0001
-		}
-		else if (isinf(finavalu[i]) == 1){ 
-			finavalu[i] = 0.0001;												// for INF set rate of change to 0.0001
-		}
-	}
-
-}
diff -ruN rodinia_3.1/openmp/myocyte/run rodinia_3.1_new/openmp/myocyte/run
--- rodinia_3.1/openmp/myocyte/run	2024-08-29 14:54:06.574368075 -0700
+++ rodinia_3.1_new/openmp/myocyte/run	2024-08-29 14:50:13.820123514 -0700
@@ -1 +1 @@
-./myocyte.out 100 1 0 4
+./myocyte.out 1000 500 1 14
diff -ruN rodinia_3.1/openmp/myocyte/solver.c rodinia_3.1_new/openmp/myocyte/solver.c
--- rodinia_3.1/openmp/myocyte/solver.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/solver.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,285 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-// int solver( fp (*f)(fp, fp), fp y[],        //
-//       fp x, fp h, fp xmax, fp *h_next, fp tolerance )  //
-//                                                                            //
-//  Description:                                                              //
-//     This function solves the differential equation y'=f(x,y) with the      //
-//     initial condition y(x) = y[0].  The value at xmax is returned in y[1]. //
-//     The function returns 0 if successful or -1 if it fails.                //
-//                                                                            //
-//  Arguments:                                                                //
-//     fp *f  Pointer to the function which returns the slope at (x,y) of //
-//                integral curve of the differential equation y' = f(x,y)     //
-//                which passes through the point (x0,y0) corresponding to the //
-//                initial condition y(x0) = y0.                               //
-//     fp y[] On input y[0] is the initial value of y at x, on output     //
-//                y[1] is the solution at xmax.                               //
-//     fp x   The initial value of x.                                     //
-//     fp h   Initial step size.                                          //
-//     fp xmax The endpoint of x.                                         //
-//     fp *h_next   A pointer to the estimated step size for successive   //
-//                      calls to solver.                       //
-//     fp tolerance The tolerance of y(xmax), i.e. a solution is sought   //
-//                so that the relative error < tolerance.                     //
-//                                                                            //
-//  Return Values:                                                            //
-//     0   The solution of y' = f(x,y) from x to xmax is stored y[1] and      //
-//         h_next has the value to the next size to try.                      //
-//    -1   The solution of y' = f(x,y) from x to xmax failed.                 //
-//    -2   Failed because either xmax < x or the step size h <= 0.            //
-//    -3   Memory limit allocated for results was reached                                //
-////////////////////////////////////////////////////////////////////////////////
-
-////////////////////////////////////////////////////////////////////////////////
-//	Summary of changes by Lukasz G. Szafaryn:
-
-//	1) The original code was obtained from: Mathematics Source Library (http://mymathlib.webtrellis.net/index.html)
-// 2) This solver and particular solving algorithm used with it (embedded_fehlberg_7_8) were adapted to work with a set of equations, not just one like in original version.
-
-//	3) In order for solver to provide deterministic number of steps (needed for particular amount of memore previousely allocated for results), every next step is incremented by 1 time unit (h_init).
-//	4) Function assumes that time interval starts at 0 (xmin) and ends at integer value (xmax) specified by the uses as a parameter on command line.
-// 5) The appropriate amount of memory is previousely allocated for that range (y).
-
-//	5) This setup in 3) - 5) allows solver to adjust the step ony from current time instance to current time instance + 0.9. The next time instance is current time instance + 1;
-
-//	6) Solver also takes parameters (params) that it then passes to the equations.
-
-//	7) The original solver cannot handle cases when equations return NAN and INF values due to discontinuities and /0. That is why equations provided by user need to make sure that no NAN and INF are returned.
-
-//	Last update: 15 DEC 09
-////////////////////////////////////////////////////////////////////////////////
-
-//======================================================================================================================================================
-//======================================================================================================================================================
-//		INCLUDE
-//======================================================================================================================================================
-//======================================================================================================================================================
-
-#include <math.h>
-
-#define max(x,y) ( (x) < (y) ? (y) : (x) )
-#define min(x,y) ( (x) < (y) ? (x) : (y) )
-
-#define ATTEMPTS 12
-#define MIN_SCALE_FACTOR 0.125
-#define MAX_SCALE_FACTOR 4.0
-
-//======================================================================================================================================================
-//======================================================================================================================================================
-//		SOLVER FUNCTION
-//======================================================================================================================================================
-//======================================================================================================================================================
-
-int solver(	fp** y,
-					fp* x,
-					int xmax,
-					fp* params,
-					int mode) {
-
-	//========================================================================================================================
-	//	VARIABLES
-	//========================================================================================================================
-
-	// solver parameters
-	fp err_exponent;
-	fp last_interval;
-	int error;
-	int outside;
-	fp h;
-	fp h_init;
-	fp tolerance;
-	int xmin;
-
-	// memory
-	fp scale_min;
-	fp scale_fina;
-	fp* err= (fp *) malloc(EQUATIONS* sizeof(fp));
-	fp* scale= (fp *) malloc(EQUATIONS* sizeof(fp));
-	fp* yy= (fp *) malloc(EQUATIONS* sizeof(fp));
-
-	// counters
-	int i, j, k;
-
-	//========================================================================================================================
-	//		INITIAL SETUP
-	//========================================================================================================================
-
-	// solver parameters
-	err_exponent = 1.0 / 7.0;
-	last_interval = 0;
-	h_init = 1;
-	h = h_init;
-	xmin = 0;
-	tolerance = 10 / (fp)(xmax-xmin);
-
-	// save value for initial time instance
-	x[0] = 0;
-
-	//========================================================================================================================
-	//		CHECKING
-	//========================================================================================================================
-
-	// Verify that the step size is positive and that the upper endpoint of integration is greater than the initial enpoint.               //
-	if (xmax < xmin || h <= 0.0){
-		return -2;
-	}
-
-	// If the upper endpoint of the independent variable agrees with the initial value of the independent variable.  Set the value of the dependent variable and return success. //
-	if (xmax == xmin){
-		return 0; 
-	}
-
-	// Insure that the step size h is not larger than the length of the integration interval.                                            //
-	if (h > (xmax - xmin) ) { 
-		h = (fp)xmax - (fp)xmin; 
-		last_interval = 1;
-	}
-
-	//========================================================================================================================
-	//		SOLVING
-	//========================================================================================================================
-
-	for(k=1; k<=xmax; k++) {											// start after initial value
-
-		x[k] = k-1;
-		h = h_init;
-
-		//==========================================================================================
-		//		REINITIALIZE VARIABLES
-		//==========================================================================================
-
-		scale_fina = 1.0;
-
-		//==========================================================================================
-		//		MAKE ATTEMPTS TO MINIMIZE ERROR
-		//==========================================================================================
-
-		// make attempts to minimize error
-		for (j = 0; j < ATTEMPTS; j++) {
-
-			//============================================================
-			//		REINITIALIZE VARIABLES
-			//============================================================
-
-			error = 0;
-			outside = 0;
-			scale_min = MAX_SCALE_FACTOR;
-
-			//============================================================
-			//		EVALUATE ALL EQUATIONS
-			//============================================================
-
-			embedded_fehlberg_7_8(	x[k],
-														h,
-														y[k-1],
-														y[k],
-														err,
-														params,
-														mode);
-
-			//============================================================
-			//		IF THERE WAS NO ERROR FOR ANY OF EQUATIONS, SET SCALE AND LEAVE THE LOOP
-			//============================================================
-
-			for(i=0; i<EQUATIONS; i++){
-				if(err[i] > 0){
-					error = 1;
-				}
-			}
-			if (error != 1) {
-				scale_fina = MAX_SCALE_FACTOR; 
-				break;
-			}
-
-			//============================================================
-			//		FIGURE OUT SCALE AS THE MINIMUM OF COMPONENT SCALES
-			//============================================================
-
-			for(i=0; i<EQUATIONS; i++){
-				if(y[k-1][i] == 0.0){
-					yy[i] = tolerance;
-				}
-				else{
-					yy[i] = fabs(y[k-1][i]);
-				}
-				scale[i] = 0.8 * pow( tolerance * yy[i] / err[i] , err_exponent );
-				if(scale[i]<scale_min){
-					scale_min = scale[i];
-				}
-			}
-			scale_fina = min( max(scale_min,MIN_SCALE_FACTOR), MAX_SCALE_FACTOR);
-
-			//============================================================
-			//		IF WITHIN TOLERANCE, FINISH ATTEMPTS...
-			//============================================================
-
-			for(i=0; i<EQUATIONS; i++){
-				if ( err[i] > ( tolerance * yy[i] ) ){
-					outside = 1;
-				}
-			}
-			if (outside == 0){
-				break;
-			}
-
-			//============================================================
-			//		...OTHERWISE, ADJUST STEP FOR NEXT ATTEMPT
-			//============================================================
-
-			// scale next step in a default way
-			h = h * scale_fina;
-
-			// limit step to 0.9, because when it gets close to 1, it no longer makes sense, as 1 is already the next time instance (added to original algorithm)
-			if (h >= 0.9) {
-				h = 0.9;
-			}
-
-			// if instance+step exceeds range limit, limit to that range
-			if ( x[k] + h > (fp)xmax ){
-				h = (fp)xmax - x[k];
-			}
-
-			// if getting closer to range limit, decrease step
-			else if ( x[k] + h + 0.5 * h > (fp)xmax ){
-				h = 0.5 * h;
-			}
-
-		}
-
-		//==========================================================================================
-		//		SAVE TIME INSTANCE THAT SOLVER ENDED UP USING
-		//==========================================================================================
-
-		x[k] = x[k] + h;
-
-		//==========================================================================================
-		//		IF MAXIMUM NUMBER OF ATTEMPTS REACHED AND CANNOT GIVE SOLUTION, EXIT PROGRAM WITH ERROR
-		//==========================================================================================
-
-		if ( j >= ATTEMPTS ) {
-			return -1; 
-		}
-
-	}
-
-	//========================================================================================================================
-	//		FREE MEMORY
-	//========================================================================================================================
-
-	free(err);
-	free(scale);
-	free(yy);
-
-	//========================================================================================================================
-	//		FINAL RETURN
-	//========================================================================================================================
-
-	return 0;
-
-//======================================================================================================================================================
-//======================================================================================================================================================
-//		END OF SOLVER FUNCTION
-//======================================================================================================================================================
-//======================================================================================================================================================
-
-} 
diff -ruN rodinia_3.1/openmp/myocyte/timer.c rodinia_3.1_new/openmp/myocyte/timer.c
--- rodinia_3.1/openmp/myocyte/timer.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/myocyte/timer.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,9 +0,0 @@
-#include <stdlib.h>
-#include <sys/time.h>
-
- // Returns the current system time in microseconds
-long long get_time() {
-	struct timeval tv;
-	gettimeofday(&tv, NULL);
-	return (tv.tv_sec * 1000000) + tv.tv_usec;
-}
diff -ruN rodinia_3.1/openmp/nn/filelist_4 rodinia_3.1_new/openmp/nn/filelist_4
--- rodinia_3.1/openmp/nn/filelist_4	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/nn/filelist_4	1969-12-31 16:00:00.000000000 -0800
@@ -1,4 +0,0 @@
-../../data/nn/cane4_0.db
-../../data/nn/cane4_1.db
-../../data/nn/cane4_2.db
-../../data/nn/cane4_3.db
Binary files rodinia_3.1/openmp/nn/nn and rodinia_3.1_new/openmp/nn/nn differ
diff -ruN rodinia_3.1/openmp/nn/nn_openmp.c rodinia_3.1_new/openmp/nn/nn_openmp.c
--- rodinia_3.1/openmp/nn/nn_openmp.c	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/nn/nn_openmp.c	2024-08-29 14:50:14.131123780 -0700
@@ -26,7 +26,7 @@
 * REC_WINDOW has been arbitrarily assigned; A larger value would allow more work for the threads
 */
 int main(int argc, char* argv[]) {
-	long long time0 = clock();
+	double total_time = 0.0;
     FILE   *flist,*fp;
 	int    i=0,j=0, k=0, rec_count=0, done=0;
 	char   sandbox[REC_LENGTH * REC_WINDOW], *rec_iter,*rec_iter2, dbname[64];
@@ -112,7 +112,8 @@
 			// z[i] = sqrt(( (tmp_lat-target_lat) * (tmp_lat-target_lat) )+( (tmp_long-target_long) * (tmp_long-target_long) ));
 		// } /* omp end parallel */
 		// #pragma omp barrier
-       
+		double time0 = omp_get_wtime();
+
         #pragma omp parallel for shared (z, target_lat, target_long) private(i,rec_iter)
         for (i = 0; i < rec_count; i++){
 			rec_iter = sandbox+(i * REC_LENGTH + LATITUDE_POS - 1);
@@ -141,19 +142,21 @@
 			  	neighbors[max_idx].dist = z[i];
 			}
 		}
+
+		double time1 = omp_get_wtime() - time0;
+		total_time += time1;
 	}//End while loop
 
-	fprintf(stderr, "The %d nearest neighbors are:\n", k);
-	for( j = 0 ; j < k ; j++ ) {
-		if( !(neighbors[j].dist == OPEN) )
-			fprintf(stderr, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist);
-	}
+	//fprintf(stderr, "The %d nearest neighbors are:\n", k);
+	//for( j = 0 ; j < k ; j++ ) {
+	//	if( !(neighbors[j].dist == OPEN) )
+	//		fprintf(stderr, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist);
+	//}
 
 	fclose(flist);
-	
 
-    long long time1 = clock();
-    printf("total time : %15.12f s", (float) (time1 - time0) / 1000000);
+
+	printf("total time: %.12f s\n", total_time);
     return 0;
 }
 
diff -ruN rodinia_3.1/openmp/nn/run rodinia_3.1_new/openmp/nn/run
--- rodinia_3.1/openmp/nn/run	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/nn/run	2024-08-29 14:50:14.131123780 -0700
@@ -1 +1 @@
-./nn filelist_4 5 30 90
\ No newline at end of file
+./nn filelist.txt 10000 30 90
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/nw/Makefile rodinia_3.1_new/openmp/nw/Makefile
--- rodinia_3.1/openmp/nw/Makefile	2024-08-29 14:54:06.576368078 -0700
+++ rodinia_3.1_new/openmp/nw/Makefile	2024-08-29 14:50:14.133123782 -0700
@@ -1,10 +1,10 @@
 # C compiler
 CC = g++
-ICC = icc
+ICC = icpx
 CC_FLAGS = -g -O3 -fopenmp
 OFFLOAD_CC_FLAGS = -offload-option,mic,compiler,"-no-opt-prefetch"
 
-all: needle needle_offload
+all: needle #needle_offload
 
 needle: 
 	$(CC) $(CC_FLAGS) needle.cpp -o needle 
diff -ruN rodinia_3.1/openmp/nw/needle.cpp rodinia_3.1_new/openmp/nw/needle.cpp
--- rodinia_3.1/openmp/nw/needle.cpp	2024-08-29 14:54:06.576368078 -0700
+++ rodinia_3.1_new/openmp/nw/needle.cpp	2024-08-29 14:50:14.133123782 -0700
@@ -309,7 +309,7 @@
 
     long long end_time = get_time();
 
-    printf("Total time: %.3f seconds\n", ((float) (end_time - start_time)) / (1000*1000));
+    printf("Total time: %.6f seconds\n", ((float) (end_time - start_time)) / (1000*1000));
 
 #define TRACEBACK
 #ifdef TRACEBACK
diff -ruN rodinia_3.1/openmp/nw/run rodinia_3.1_new/openmp/nw/run
--- rodinia_3.1/openmp/nw/run	2024-08-29 14:54:06.576368078 -0700
+++ rodinia_3.1_new/openmp/nw/run	2024-08-29 14:50:14.133123782 -0700
@@ -1 +1 @@
-./needle 2048 10 2 
\ No newline at end of file
+./needle 32768 10 14
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/nw/run_offload rodinia_3.1_new/openmp/nw/run_offload
--- rodinia_3.1/openmp/nw/run_offload	2024-08-29 14:54:06.576368078 -0700
+++ rodinia_3.1_new/openmp/nw/run_offload	2024-08-29 14:50:14.133123782 -0700
@@ -1 +1 @@
-./needle_offload 2048 10 2
+./needle_offload 32768 10 14
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/particlefilter/Makefile rodinia_3.1_new/openmp/particlefilter/Makefile
--- rodinia_3.1/openmp/particlefilter/Makefile	2024-08-29 14:54:06.587368091 -0700
+++ rodinia_3.1_new/openmp/particlefilter/Makefile	2024-08-29 14:50:14.133123782 -0700
@@ -1,11 +1,14 @@
 #makefile
 
+CC = gcc
+
+
 openmp: ex_particle_OPENMP_seq.c
-	gcc -O3 -ffast-math -fopenmp ex_particle_OPENMP_seq.c -o particle_filter -lm 
+	$(CC) -O3 -ffast-math -fopenmp ex_particle_OPENMP_seq.c -o particle_filter -lm 
 
 
 icc_openmp: ex_particle_OPENMP_seq.c
-	icc -O3 -fast -openmp ex_particle_OPENMP_seq.c -o particle_filter
+	icpx -O3 -fast -openmp ex_particle_OPENMP_seq.c -o particle_filter
 
 
 clean:
Binary files rodinia_3.1/openmp/particlefilter/particle_filter and rodinia_3.1_new/openmp/particlefilter/particle_filter differ
diff -ruN rodinia_3.1/openmp/particlefilter/run rodinia_3.1_new/openmp/particlefilter/run
--- rodinia_3.1/openmp/particlefilter/run	2024-08-29 14:54:06.587368091 -0700
+++ rodinia_3.1_new/openmp/particlefilter/run	2024-08-29 14:50:14.133123782 -0700
@@ -1 +1 @@
-./particle_filter -x 128 -y 128 -z 10 -np 10000
+./particle_filter -x 512 -y 512 -z 100 -np 10000
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/pathfinder/Makefile rodinia_3.1_new/openmp/pathfinder/Makefile
--- rodinia_3.1/openmp/pathfinder/Makefile	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/pathfinder/Makefile	2024-08-29 14:50:14.133123782 -0700
@@ -1,7 +1,9 @@
 CC = g++
 SRC = pathfinder.cpp
 EXE = pathfinder
-FLAGS = -fopenmp
+FLAGS = -fopenmp -O3
+
+all: release
 
 release:
 	$(CC) $(SRC) $(FLAGS) -o $(EXE)
diff -ruN rodinia_3.1/openmp/pathfinder/pathfinder.cpp rodinia_3.1_new/openmp/pathfinder/pathfinder.cpp
--- rodinia_3.1/openmp/pathfinder/pathfinder.cpp	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/pathfinder/pathfinder.cpp	2024-08-29 14:50:14.133123782 -0700
@@ -10,7 +10,7 @@
 /* define timer macros */
 #define pin_stats_reset()   startCycle()
 #define pin_stats_pause(cycles)   stopCycle(cycles)
-#define pin_stats_dump(cycles)    printf("timer: %Lu\n", cycles)
+#define pin_stats_dump(cycles)    printf("timer: %.6f\n", (double)cycles/CLOCKS_PER_SEC)
 
 #define BENCH_PRINT
 
@@ -48,7 +48,7 @@
     }
     for (int j = 0; j < cols; j++)
         result[j] = wall[0][j];
-#ifdef BENCH_PRINT
+#if 0//def BENCH_PRINT
     for (int i = 0; i < rows; i++)
     {
         for (int j = 0; j < cols; j++)
@@ -109,13 +109,20 @@
     pin_stats_pause(cycles);
     pin_stats_dump(cycles);
 
-#ifdef BENCH_PRINT
-    for (int i = 0; i < cols; i++)
-            printf("%d ",data[i]) ;
-    printf("\n") ;
-    for (int i = 0; i < cols; i++)
-            printf("%d ",dst[i]) ;
-    printf("\n") ;
+#ifdef BENCH_PRINT
+
+    for (int i = 0; i < cols; i++)
+
+            printf("%d ",data[i]) ;
+
+    printf("\n") ;
+
+    for (int i = 0; i < cols; i++)
+
+            printf("%d ",dst[i]) ;
+
+    printf("\n") ;
+
 #endif
 
     delete [] data;
diff -ruN rodinia_3.1/openmp/pathfinder/timer.h rodinia_3.1_new/openmp/pathfinder/timer.h
--- rodinia_3.1/openmp/pathfinder/timer.h	2024-08-29 14:54:06.573368074 -0700
+++ rodinia_3.1_new/openmp/pathfinder/timer.h	2024-08-29 14:50:14.133123782 -0700
@@ -3,7 +3,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 
-// #define BENCH_PRINT
+// #define BENCH_PRINT
 
 
 /*----------- using cycle counter ------------*/
@@ -16,8 +16,8 @@
      }
 
 unsigned long long start_cycles;
-#define startCycle() (start_cycles = rdtsc())
-#define stopCycle(cycles) (cycles = rdtsc()-start_cycles)
+#define startCycle() (start_cycles = clock())
+#define stopCycle(cycles) (cycles = clock()-start_cycles)
 
 /*--------- using gettimeofday ------------*/
 
diff -ruN rodinia_3.1/openmp/srad/Makefile rodinia_3.1_new/openmp/srad/Makefile
--- rodinia_3.1/openmp/srad/Makefile	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/Makefile	2024-08-29 14:50:14.133123782 -0700
@@ -1,17 +1,11 @@
 
-all: SRAD_V1 SRAD_V2
-
-SRAD_V1:
-	cd srad_v1; 	make
+all: SRAD_V2
 
 SRAD_V2:
 	cd srad_v2; 	make
 
-clean: SRAD_V1_clean SRAD_V2_clean
+clean: SRAD_V2_clean
 
-SRAD_V1_clean:
-	cd srad_v1; 	make clean
-	
 SRAD_V2_clean:
 	cd srad_v2; 	make clean
 
diff -ruN rodinia_3.1/openmp/srad/srad_v1/define.c rodinia_3.1_new/openmp/srad/srad_v1/define.c
--- rodinia_3.1/openmp/srad/srad_v1/define.c	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/define.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,7 +0,0 @@
-//====================================================================================================100
-//====================================================================================================100
-//	DEFINE
-//====================================================================================================100
-//====================================================================================================100
-
-#define fp float
diff -ruN rodinia_3.1/openmp/srad/srad_v1/graphics.c rodinia_3.1_new/openmp/srad/srad_v1/graphics.c
--- rodinia_3.1/openmp/srad/srad_v1/graphics.c	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/graphics.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,155 +0,0 @@
-//====================================================================================================100
-//====================================================================================================100
-//	INCLUDE/DEFINE
-//====================================================================================================100
-//====================================================================================================100
-
-// #include <stdlib.h>
-// #include <string.h>
-#include <stdio.h>
-// #include <math.h>
-// #include <time.h>
-// #include <sys/types.h>
-// #include <dirent.h>
-// #include <errno.h>
-
-//====================================================================================================100
-//====================================================================================================100
-//	WRITE FUNCTION
-//====================================================================================================100
-//====================================================================================================100
-
-void write_graphics(	char* filename,
-									fp* input, 
-									int data_rows, 
-									int data_cols, 
-									int major,
-									int data_range){
-
-	//================================================================================80
-	//	VARIABLES
-	//================================================================================80
-
-	FILE* fid;
-	int i, j;
-
-	//================================================================================80
-	//	CREATE/OPEN FILE FOR WRITING
-	//================================================================================80
-
-	fid = fopen(filename, "w");
-	if( fid == NULL ){
-		printf( "The file was not created/opened for writing\n" );
-		return;
-	}
-
-	//================================================================================80
-	//	WRITE PGM FILE HEADER
-	//================================================================================80
-
-	fprintf(fid, "P2\n");
-	fprintf(fid, "%d %d\n", data_cols, data_rows);
-	fprintf(fid, "%d\n", data_range);
-
-	//================================================================================80
-	//	WRITE VALUES TO THE FILE
-	//================================================================================80
-
-	// if matrix is saved row major in memory (C)
-	if(major==0){
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fprintf(fid, "%d ", (int)input[i*data_cols+j]);
-			}
-			fprintf(fid, "\n");
-		}
-	}
-	// if matrix is saved column major in memory (MATLAB)
-	else{
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fprintf(fid, "%d ", (int)input[j*data_rows+i]);
-			}
-			fprintf(fid, "\n");
-		}
-	}
-
-	//================================================================================80
-	//	CLOSE FILE
-	//================================================================================80
-
-	fclose(fid);
-
-}
-
-//====================================================================================================100
-//====================================================================================================100
-//	READ FUNCTION
-//====================================================================================================100
-//====================================================================================================100
-
-void read_graphics(	char* filename,
-									fp* input,
-									int data_rows, 
-									int data_cols,
-									int major){
-
-	//================================================================================80
-	//	VARIABLES
-	//================================================================================80
-
-	FILE* fid;
-	int i, j;
-	char c;
-	int temp;
-
-	//================================================================================80
-	//	OPEN FILE FOR READING
-	//================================================================================80
-
-	fid = fopen(filename, "r");
-	if( fid == NULL ){
-		printf( "The file was not opened for reading\n" );
-		return;
-	}
-
-	//================================================================================80
-	//	SKIP PGM FILE HEADER
-	//================================================================================80
-
-	i = 0;
-	while(i<3){
-		c = fgetc(fid);
-		if(c == '\n'){
-			i = i+1;
-		}
-	};
-
-	//================================================================================80
-	//	READ VALUES FROM THE FILE
-	//================================================================================80
-
-	if(major==0){																// if matrix is saved row major in memory (C)
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fscanf(fid, "%d", &temp);
-				input[i*data_cols+j] = (fp)temp;
-			}
-		}
-	}
-	else{																				// if matrix is saved column major in memory (MATLAB)
-		for(i=0; i<data_rows; i++){
-			for(j=0; j<data_cols; j++){
-				fscanf(fid, "%d", &temp);
-				input[j*data_rows+i] = (fp)temp;
-			}
-		}
-	}
-
-	//================================================================================80
-	//	CLOSE FILE
-	//================================================================================80
-
-	fclose(fid);
-
-}
diff -ruN rodinia_3.1/openmp/srad/srad_v1/include.h rodinia_3.1_new/openmp/srad/srad_v1/include.h
--- rodinia_3.1/openmp/srad/srad_v1/include.h	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/include.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,18 +0,0 @@
-#include <stdlib.h>
-#include <math.h>
-#include <time.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <mex.h>
-
-#include <define.h>
-
-#include <print.c>
-
-#include <prepare_kernel.cu>
-#include <extract_kernel.cu>
-#include <reduce_kernel.cu>
-#include <srad_kernel.cu>
-#include <srad2_kernel.cu>
-#include <compress_kernel.cu>
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/srad/srad_v1/main.c rodinia_3.1_new/openmp/srad/srad_v1/main.c
--- rodinia_3.1/openmp/srad/srad_v1/main.c	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/main.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,388 +0,0 @@
-//====================================================================================================100
-//		UPDATE
-//====================================================================================================100
-
-//    2006.03   Rob Janiczek
-//        --creation of prototype version
-//    2006.03   Drew Gilliam
-//        --rewriting of prototype version into current version
-//        --got rid of multiple function calls, all code in a  
-//         single function (for speed)
-//        --code cleanup & commenting
-//        --code optimization efforts   
-//    2006.04   Drew Gilliam
-//        --added diffusion coefficent saturation on [0,1]
-//		2009.12 Lukasz G. Szafaryn
-//		-- reading from image, command line inputs
-//		2010.01 Lukasz G. Szafaryn
-//		--comments
-
-//====================================================================================================100
-//	DEFINE / INCLUDE
-//====================================================================================================100
-
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include <omp.h>
-
-#include "define.c"
-#include "graphics.c"
-#include "resize.c"
-#include "timer.c"
-
-//====================================================================================================100
-//====================================================================================================100
-//	MAIN FUNCTION
-//====================================================================================================100
-//====================================================================================================100
-
-int main(int argc, char *argv []){
-
-	//================================================================================80
-	// 	VARIABLES
-	//================================================================================80
-
-	// time
-	long long time0;
-	long long time1;
-	long long time2;
-	long long time3;
-	long long time4;
-	long long time5;
-	long long time6;
-	long long time7;
-	long long time8;
-	long long time9;
-	long long time10;
-
-	time0 = get_time();
-
-    // inputs image, input paramenters
-    fp* image_ori;																// originalinput image
-	int image_ori_rows;
-	int image_ori_cols;
-	long image_ori_elem;
-
-    // inputs image, input paramenters
-    fp* image;															// input image
-    long Nr,Nc;													// IMAGE nbr of rows/cols/elements
-	long Ne;
-
-	// algorithm parameters
-    int niter;																// nbr of iterations
-    fp lambda;															// update step size
-
-    // size of IMAGE
-	int r1,r2,c1,c2;												// row/col coordinates of uniform ROI
-	long NeROI;														// ROI nbr of elements
-    
-    // ROI statistics
-    fp meanROI, varROI, q0sqr;											//local region statistics
-    
-    // surrounding pixel indicies
-    int *iN,*iS,*jE,*jW;    
-
-    // center pixel value
-    fp Jc;
-
-	// directional derivatives
-	fp *dN,*dS,*dW,*dE;
-    
-    // calculation variables
-    fp tmp,sum,sum2;
-    fp G2,L,num,den,qsqr,D;
-       
-    // diffusion coefficient
-    fp *c; 
-	fp cN,cS,cW,cE;
-    
-    // counters
-    int iter;   // primary loop
-    long i,j;    // image row/col
-    long k;      // image single index    
-
-	// number of threads
-	int threads;
-
-	time1 = get_time();
-
-	//================================================================================80
-	// 	GET INPUT PARAMETERS
-	//================================================================================80
-
-	if(argc != 6){
-		printf("ERROR: wrong number of arguments\n");
-		return 0;
-	}
-	else{
-		niter = atoi(argv[1]);
-		lambda = atof(argv[2]);
-		Nr = atoi(argv[3]);						// it is 502 in the original image
-		Nc = atoi(argv[4]);						// it is 458 in the original image
-		threads = atoi(argv[5]);
-	}
-
-	omp_set_num_threads(threads);
-	// printf("THREAD %d\n", omp_get_thread_num());
-	// printf("NUMBER OF THREADS: %d\n", omp_get_num_threads());
-
-	time2 = get_time();
-
-	//================================================================================80
-	// 	READ IMAGE (SIZE OF IMAGE HAS TO BE KNOWN)
-	//================================================================================80
-
-    // read image
-	image_ori_rows = 502;
-	image_ori_cols = 458;
-	image_ori_elem = image_ori_rows * image_ori_cols;
-
-	image_ori = (fp*)malloc(sizeof(fp) * image_ori_elem);
-
-	read_graphics(	"../../../data/srad/image.pgm",
-								image_ori,
-								image_ori_rows,
-								image_ori_cols,
-								1);
-
-	time3 = get_time();
-
-	//================================================================================80
-	// 	RESIZE IMAGE (ASSUMING COLUMN MAJOR STORAGE OF image_orig)
-	//================================================================================80
-
-	Ne = Nr*Nc;
-
-	image = (fp*)malloc(sizeof(fp) * Ne);
-
-	resize(	image_ori,
-				image_ori_rows,
-				image_ori_cols,
-				image,
-				Nr,
-				Nc,
-				1);
-
-	time4 = get_time();
-
-	//================================================================================80
-	// 	SETUP
-	//================================================================================80
-
-    r1     = 0;											// top row index of ROI
-    r2     = Nr - 1;									// bottom row index of ROI
-    c1     = 0;											// left column index of ROI
-    c2     = Nc - 1;									// right column index of ROI
-
-    // ROI image size    
-    NeROI = (r2-r1+1)*(c2-c1+1);											// number of elements in ROI, ROI size
-    
-    // allocate variables for surrounding pixels
-    iN = malloc(sizeof(int*)*Nr) ;									// north surrounding element
-    iS = malloc(sizeof(int*)*Nr) ;									// south surrounding element
-    jW = malloc(sizeof(int*)*Nc) ;									// west surrounding element
-    jE = malloc(sizeof(int*)*Nc) ;									// east surrounding element
-    
-	// allocate variables for directional derivatives
-	dN = malloc(sizeof(fp)*Ne) ;											// north direction derivative
-    dS = malloc(sizeof(fp)*Ne) ;											// south direction derivative
-    dW = malloc(sizeof(fp)*Ne) ;											// west direction derivative
-    dE = malloc(sizeof(fp)*Ne) ;											// east direction derivative
-
-	// allocate variable for diffusion coefficient
-    c  = malloc(sizeof(fp)*Ne) ;											// diffusion coefficient
-        
-    // N/S/W/E indices of surrounding pixels (every element of IMAGE)
-	// #pragma omp parallel
-    for (i=0; i<Nr; i++) {
-        iN[i] = i-1;														// holds index of IMAGE row above
-        iS[i] = i+1;														// holds index of IMAGE row below
-    }
-	// #pragma omp parallel
-    for (j=0; j<Nc; j++) {
-        jW[j] = j-1;														// holds index of IMAGE column on the left
-        jE[j] = j+1;														// holds index of IMAGE column on the right
-    }
-	// N/S/W/E boundary conditions, fix surrounding indices outside boundary of IMAGE
-    iN[0]    = 0;															// changes IMAGE top row index from -1 to 0
-    iS[Nr-1] = Nr-1;														// changes IMAGE bottom row index from Nr to Nr-1 
-    jW[0]    = 0;															// changes IMAGE leftmost column index from -1 to 0
-    jE[Nc-1] = Nc-1;														// changes IMAGE rightmost column index from Nc to Nc-1
-
-	time5 = get_time();
-
-	//================================================================================80
-	// 	SCALE IMAGE DOWN FROM 0-255 TO 0-1 AND EXTRACT
-	//================================================================================80
-
-	// #pragma omp parallel
-	for (i=0; i<Ne; i++) {													// do for the number of elements in input IMAGE
-		image[i] = exp(image[i]/255);											// exponentiate input IMAGE and copy to output image
-    }
-
-	time6 = get_time();
-
-	//================================================================================80
-	// 	COMPUTATION
-	//================================================================================80
-
-	// printf("iterations: ");
-
-    // primary loop
-    for (iter=0; iter<niter; iter++){										// do for the number of iterations input parameter
-
-		// printf("%d ", iter);
-		// fflush(NULL);
-
-        // ROI statistics for entire ROI (single number for ROI)
-        sum=0; 
-		sum2=0;
-        for (i=r1; i<=r2; i++) {											// do for the range of rows in ROI
-            for (j=c1; j<=c2; j++) {										// do for the range of columns in ROI
-                tmp   = image[i + Nr*j];										// get coresponding value in IMAGE
-                sum  += tmp ;												// take corresponding value and add to sum
-                sum2 += tmp*tmp;											// take square of corresponding value and add to sum2
-            }
-        }
-        meanROI = sum / NeROI;												// gets mean (average) value of element in ROI
-        varROI  = (sum2 / NeROI) - meanROI*meanROI;							// gets variance of ROI
-        q0sqr   = varROI / (meanROI*meanROI);								// gets standard deviation of ROI
-
-        // directional derivatives, ICOV, diffusion coefficent
-		#pragma omp parallel for shared(image, dN, dS, dW, dE, c, Nr, Nc, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)
-		for (j=0; j<Nc; j++) {												// do for the range of columns in IMAGE
-
-            for (i=0; i<Nr; i++) {											// do for the range of rows in IMAGE 
-
-                // current index/pixel
-                k = i + Nr*j;												// get position of current element
-                Jc = image[k];													// get value of the current element
-
-                // directional derivates (every element of IMAGE)
-                dN[k] = image[iN[i] + Nr*j] - Jc;								// north direction derivative
-                dS[k] = image[iS[i] + Nr*j] - Jc;								// south direction derivative
-                dW[k] = image[i + Nr*jW[j]] - Jc;								// west direction derivative
-                dE[k] = image[i + Nr*jE[j]] - Jc;								// east direction derivative
-
-                // normalized discrete gradient mag squared (equ 52,53)
-                G2 = (dN[k]*dN[k] + dS[k]*dS[k]								// gradient (based on derivatives)
-                    + dW[k]*dW[k] + dE[k]*dE[k]) / (Jc*Jc);
-
-                // normalized discrete laplacian (equ 54)
-                L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;					// laplacian (based on derivatives)
-
-                // ICOV (equ 31/35)
-                num  = (0.5*G2) - ((1.0/16.0)*(L*L)) ;						// num (based on gradient and laplacian)
-                den  = 1 + (.25*L);											// den (based on laplacian)
-                qsqr = num/(den*den);										// qsqr (based on num and den)
- 
-                // diffusion coefficent (equ 33) (every element of IMAGE)
-                den = (qsqr-q0sqr) / (q0sqr * (1+q0sqr)) ;					// den (based on qsqr and q0sqr)
-                c[k] = 1.0 / (1.0+den) ;									// diffusion coefficient (based on den)
-
-                // saturate diffusion coefficent to 0-1 range
-                if (c[k] < 0)												// if diffusion coefficient < 0
-					{c[k] = 0;}												// ... set to 0
-                else if (c[k] > 1)											// if diffusion coefficient > 1
-					{c[k] = 1;}												// ... set to 1
-
-            }
-
-        }
-
-        // divergence & image update
-		#pragma omp parallel for shared(image, c, Nr, Nc, lambda) private(i, j, k, D, cS, cN, cW, cE)
-        for (j=0; j<Nc; j++) {												// do for the range of columns in IMAGE
-
-			// printf("NUMBER OF THREADS: %d\n", omp_get_num_threads());
-
-            for (i=0; i<Nr; i++) {											// do for the range of rows in IMAGE
-
-                // current index
-                k = i + Nr*j;												// get position of current element
-
-                // diffusion coefficent
-                cN = c[k];													// north diffusion coefficient
-                cS = c[iS[i] + Nr*j];										// south diffusion coefficient
-                cW = c[k];													// west diffusion coefficient
-                cE = c[i + Nr*jE[j]];										// east diffusion coefficient
-
-                // divergence (equ 58)
-                D = cN*dN[k] + cS*dS[k] + cW*dW[k] + cE*dE[k];				// divergence
-
-                // image update (equ 61) (every element of IMAGE)
-                image[k] = image[k] + 0.25*lambda*D;								// updates image (based on input time step and divergence)
-
-            }
-
-        }
-
-	}
-
-	// printf("\n");
-
-	time7 = get_time();
-
-	//================================================================================80
-	// 	SCALE IMAGE UP FROM 0-1 TO 0-255 AND COMPRESS
-	//================================================================================80
-
-	// #pragma omp parallel
-	for (i=0; i<Ne; i++) {													// do for the number of elements in IMAGE
-		image[i] = log(image[i])*255;													// take logarithm of image, log compress
-	}
-
-	time8 = get_time();
-
-	//================================================================================80
-	// 	WRITE IMAGE AFTER PROCESSING
-	//================================================================================80
-
-	write_graphics(	"image_out.pgm",
-								image,
-								Nr,
-								Nc,
-								1,
-								255);
-
-	time9 = get_time();
-
-	//================================================================================80
-	// 	DEALLOCATE
-	//================================================================================80
-
-	free(image_ori);
-	free(image);
-
-    free(iN); free(iS); free(jW); free(jE);									// deallocate surrounding pixel memory
-    free(dN); free(dS); free(dW); free(dE);									// deallocate directional derivative memory
-    free(c);																// deallocate diffusion coefficient memory
-
-	time10 = get_time();
-
-	//================================================================================80
-	//		DISPLAY TIMING
-	//================================================================================80
-
-	printf("Time spent in different stages of the application:\n");
-	printf("%.12f s, %.12f % : SETUP VARIABLES\n", 									(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : READ COMMAND LINE PARAMETERS\n", 	(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : READ IMAGE FROM FILE\n", 						(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : RESIZE IMAGE\n", 										(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : SETUP, MEMORY ALLOCATION\n", 				(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : EXTRACT IMAGE\n", 									(float) (time6-time5) / 1000000, (float) (time6-time5) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : COMPUTE\n", 												(float) (time7-time6) / 1000000, (float) (time7-time6) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : COMPRESS IMAGE\n", 									(float) (time8-time7) / 1000000, (float) (time8-time7) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : SAVE IMAGE INTO FILE\n", 							(float) (time9-time8) / 1000000, (float) (time9-time8) / (float) (time10-time0) * 100);
-	printf("%.12f s, %.12f % : FREE MEMORY\n", 										(float) (time10-time9) / 1000000, (float) (time10-time9) / (float) (time10-time0) * 100);
-	printf("Total time:\n");
-	printf("%.12f s\n", 																					(float) (time10-time0) / 1000000);
-
-//====================================================================================================100
-//	END OF FILE
-//====================================================================================================100
-
-}
-
-
diff -ruN rodinia_3.1/openmp/srad/srad_v1/makefile rodinia_3.1_new/openmp/srad/srad_v1/makefile
--- rodinia_3.1/openmp/srad/srad_v1/makefile	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,24 +0,0 @@
-# Example
-# target: dependencies
-	# command 1
-	# command 2
-          # .
-          # .
-          # .
-	# command n
-
-# link objects(binaries) together
-a.out:	main.o
-	gcc	main.o \
-			-lm -fopenmp -o srad
-
-# compile main function file into object (binary)
-main.o: 	main.c \
-				define.c \
-				graphics.c
-	gcc	main.c \
-			-c -O3 -fopenmp
-
-# delete all object files
-clean:
-	rm *.o srad
diff -ruN rodinia_3.1/openmp/srad/srad_v1/README rodinia_3.1_new/openmp/srad/srad_v1/README
--- rodinia_3.1/openmp/srad/srad_v1/README	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/README	1969-12-31 16:00:00.000000000 -0800
@@ -1,56 +0,0 @@
-//====================================================================================================100
-//		HEART WALL DESCRIPTION
-//====================================================================================================100
-
-// The Heart Wall application tracks the movement of a mouse heart over a sequence of 104 609x590 ultrasound images to record response to the stimulus. 
-// In its initial stage, the program performs image processing operations on the first image to detect initial, partial shapes of inner and outer heart walls. 
-// These operations include: edge detection, SRAD despeckling (also part of Rodinia suite), morphological transformation and dilation. In order to reconstruct 
-// approximated full shapes of heart walls, the program generates ellipses that are superimposed over the image and sampled to mark points on the heart walls 
-// (Hough Search). In its final stage (Heart Wall Tracking presented here), program tracks movement of surfaces by detecting the movement of image areas under 
-// sample points as the shapes of the heart walls change throughout the sequence of images.
-
-// For more information, see:
-// Papers:
-// [1] L. G. Szafaryn, K. Skadron, and J. J. Saucerman. "Experiences Accelerating MATLAB Systems Biology Applications." In Proceedings of the Workshop on Biomedicine 
-// in Computing: Systems, Architectures, and Circuits (BiC) 2009, in conjunction with the 36th IEEE/ACM International Symposium on Computer Architecture (ISCA), 
-// June 2009. <http://www.cs.virginia.edu/~skadron/Papers/BiC09.pdf>
-// [2] Y. Yu, S. Acton, Speckle reducing anisotropic diffusion, IEEE Transactions on Image Processing 11(11)(2002) 1260-1270 <http://people.virginia.edu/~sc5nf/
-// 01097762.pdf>
-// Presentation Slides:<br>
-// [3] L. G. Szafaryn, K. Skadron. "Experiences Accelerating MATLAB Systems Biology Applications - Heart Wall Tracking". <http://www.cs.virginia.edu/~lgs9a/rodinia/
-// heart_wall/tracking/tracking.ppt>
-
-//====================================================================================================100
-//		SRAD DESCIPTION
-//====================================================================================================100
-
-// SRAD is one of the first stages of the Heart Wall application. SRAD (Speckle Reducing Anisotropic Diffusion) is a diffusion method for ultrasonic and radar imaging 
-// applications based on partial differential equations (PDEs). It is used to remove locally correlated noise, known as speckles, without destroying important image 
-// features. SRAD consists of several pieces of work: image extraction, continuous iterations over the image (preparation, reduction, statistics, computation 1 and 
-// computation 2) and image compression. The sequential dependency between all of these stages requires synchronization after each stage (because each stage 
-// operates on the entire image). 
-
-// Partitioning of the working set between caches and avoiding of cache trashing contribute to the performance. In CUDA version, each stage is a separate kernel 
-// (due to synchronization requirements) that operates on data already residing in GPU memory. In order to improve GPU performance data was transferred to GPU at 
-// the beginning of the code and then transferred back to CPU after all of the computation stages were completed in GPU. Some of the kernels use GPU shared memory 
-// for additional improvement in performance. Speedup achievable with CUDA version depends on the image size (up to the point where GPU saturates).
- 
-//====================================================================================================100
-//		USE
-//====================================================================================================100
-
-// This is the OpenMP version of SRAD code.
-
-// Input image is generated by expanding the original image (image.pgm) via concatenating its parts. The original image needs to be located in the same folder as source 
-// files.
-
-// The following are the command parameters to the application:
-// 1) Number of iterations. Needs to be integer > 0.
-// 2) Saturation coefficient. Needs to be float > 0.
-// 3) Number of rows in the input image. Needs to be integer > 0.
-// 4) Number of columns in the input image. Needs to be integer > 0.
-// 5) Number of threads. Needs to be integer > 0.
-// Example:
-// a.out 100 0.5 502 458 4
-//
-// for more information see main.c
diff -ruN rodinia_3.1/openmp/srad/srad_v1/resize.c rodinia_3.1_new/openmp/srad/srad_v1/resize.c
--- rodinia_3.1/openmp/srad/srad_v1/resize.c	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/resize.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,66 +0,0 @@
-//====================================================================================================100
-//====================================================================================================100
-//	RESIZE FUNCTION
-//====================================================================================================100
-//====================================================================================================100
-
-void resize(	fp* input, 
-					int input_rows,
-					int input_cols,
-					fp* output,
-					int output_rows,
-					int output_cols,
-					int major){
-
-	//================================================================================80
-	//	VARIABLES
-	//================================================================================80
-
-	int i, j;
-	int i2, j2;
-
-	//================================================================================80
-	//	COMPUTATION
-	//================================================================================80 
-
-	//============================================================60
-	//	ROW MAJOR
-	//============================================================60
-
-	if(major == 0){																												// do if data is saved row major
-
-		for(i=0, i2=0; i<output_rows; i++, i2++){
-			if(i2>=input_rows){
-				i2 = i2 - input_rows;
-			}
-			for(j=0, j2=0; j<output_cols; j++, j2++){
-				if(j2>=input_cols){
-					j2 = j2 - input_cols;
-				}
-				output[i*output_cols+j] = input[i2*input_cols+j2];
-			}
-		}
-
-	}
-
-	//============================================================60
-	//	COLUMN MAJOR
-	//============================================================60
-
-	else{																															// do if data is saved column major
-
-		for(j=0, j2=0; j<output_cols; j++, j2++){
-			if(j2>=input_cols){
-				j2 = j2 - input_cols;
-			}
-			for(i=0, i2=0; i<output_rows; i++, i2++){
-				if(i2>=input_rows){
-					i2 = i2 - input_rows;
-				}
-				output[j*output_rows+i] = input[j2*input_rows+i2];
-			}
-		}
-
-	}
-
-}
diff -ruN rodinia_3.1/openmp/srad/srad_v1/run rodinia_3.1_new/openmp/srad/srad_v1/run
--- rodinia_3.1/openmp/srad/srad_v1/run	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/run	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-./srad 100 0.5 502 458 4
diff -ruN rodinia_3.1/openmp/srad/srad_v1/timer.c rodinia_3.1_new/openmp/srad/srad_v1/timer.c
--- rodinia_3.1/openmp/srad/srad_v1/timer.c	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v1/timer.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,9 +0,0 @@
-#include <stdlib.h>
-#include <sys/time.h>
-
- // Returns the current system time in microseconds
-long long get_time() {
-	struct timeval tv;
-	gettimeofday(&tv, NULL);
-	return (tv.tv_sec * 1000000) + tv.tv_usec;
-}
diff -ruN rodinia_3.1/openmp/srad/srad_v2/run rodinia_3.1_new/openmp/srad/srad_v2/run
--- rodinia_3.1/openmp/srad/srad_v2/run	2024-08-29 14:54:06.588368092 -0700
+++ rodinia_3.1_new/openmp/srad/srad_v2/run	2024-08-29 14:50:14.133123782 -0700
@@ -1 +1 @@
-./srad 2048 2048 0 127 0 127 2 0.5 2
\ No newline at end of file
+./srad 2048 2048 0 127 0 127 1 0.5 100
\ No newline at end of file
diff -ruN rodinia_3.1/openmp/streamcluster/Makefile rodinia_3.1_new/openmp/streamcluster/Makefile
--- rodinia_3.1/openmp/streamcluster/Makefile	2024-08-29 14:54:06.576368078 -0700
+++ rodinia_3.1_new/openmp/streamcluster/Makefile	2024-08-29 14:50:14.134123783 -0700
@@ -1,7 +1,5 @@
 PREFIX=${PARSECDIR}/pkgs/kernels/streamcluster/inst/${PARSECPLAT}
 
-TARGET_C = sc_cpu
-
 TARGET_O = sc_omp
 
 ifdef version
@@ -10,15 +8,14 @@
   endif
 endif
 
-all: cpu omp
+CXX = g++
 
-cpu:
-	$(CXX) $(CXXFLAGS) $(LDFLAGS) streamcluster_original.cpp -o $(TARGET_C) $(LIBS) -DENABLE_THREADS -pthread
+all: omp
 
 omp:
-	g++ -O3 -fopenmp -o $(TARGET_O) streamcluster_omp.cpp
+	$(CXX) -O3 -fopenmp -o $(TARGET_O) streamcluster_omp.cpp
 
 
 clean:
-	rm -f *.o *~ *.txt sc_cpu sc_omp
+	rm -f *.o *~ *.txt sc_omp
 	
diff -ruN rodinia_3.1/openmp/streamcluster/run rodinia_3.1_new/openmp/streamcluster/run
--- rodinia_3.1/openmp/streamcluster/run	2024-08-29 14:54:06.576368078 -0700
+++ rodinia_3.1_new/openmp/streamcluster/run	2024-08-29 14:50:14.134123783 -0700
@@ -1 +1 @@
-./sc_omp 10 20 256 65536 65536 1000 none output.txt 4
\ No newline at end of file
+./sc_omp 10 20 256 65536 65536 1000 none output.txt 14
\ No newline at end of file
