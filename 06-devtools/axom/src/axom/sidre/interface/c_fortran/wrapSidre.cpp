// wrapSidre.cpp
// This file is generated by Shroud 0.14.0. Do not edit.
//
// Copyright (c) 2017-2025, Lawrence Livermore National Security, LLC and
// other Axom Project Developers. See the top-level LICENSE file for details.
//
// SPDX-License-Identifier: (BSD-3-Clause)

#include "axom/sidre/core/SidreTypes.hpp"
#include <string>
#include "wrapSidre.h"

// splicer begin CXX_definitions
// splicer end CXX_definitions

extern "C" {

// helper char_len_trim
// Returns the length of character string src with length nsrc,
// ignoring any trailing blanks.
static int ShroudCharLenTrim(const char* src, int nsrc)
{
  int i;

  for(i = nsrc - 1; i >= 0; i--)
  {
    if(src[i] != ' ')
    {
      break;
    }
  }

  return i + 1;
}

// splicer begin C_definitions
// equivalent to C_LOC
// called from Fortran
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53945
// Work around a problem with gfortran 4.7 where C_LOC does not work
// with assumed shape array.  Passing the first element of the
// array to a function without an interface will force the compiler
// to use f77 semantics and pass the address of the data, essentially
// the same as C_LOC.
// XXX Pass the first element, not the entire array, to avoid getting
// XXX a copy of the array.
//
// The result must be an argument because some compilers (Intel)
// cannot return type(C_PTR)
void sidre_c_loc(void* addr, void** out) { *out = addr; }
void sidre_c_loc_(void* addr, void** out) { *out = addr; }

// splicer end C_definitions

bool SIDRE_name_is_valid(const char* name)
{
  // splicer begin function.nameIsValid
  return name != NULL;
  // splicer end function.nameIsValid
}

bool SIDRE_name_is_valid_bufferify(char* name, int SHT_name_len)
{
  // splicer begin function.nameIsValid_bufferify
  int SHC_name_trim = ShroudCharLenTrim(name, SHT_name_len);
  const std::string SHC_name_cxx(name, SHC_name_trim);
  bool SHC_rv = axom::sidre::nameIsValid(SHC_name_cxx);
  return SHC_rv;
  // splicer end function.nameIsValid_bufferify
}

}  // extern "C"
