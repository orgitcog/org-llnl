#include "geometry/geometry.hpp"

#include "gtest/gtest.h"

#include <algorithm>
#include <iostream>
#include <array>
#include <cmath>

using namespace geometry;

constexpr int numpoints = 100;
vec3f points[numpoints] = {{0.61709, 0.388393, 0.337874}, {0.404253, 0.32143, 0.0738073}, {0.692816, 0.430049, 0.306071}, {0.339957, 0.552427, 0.855159}, {0.162124, 0.747412, 0.57929}, {0.593848, 0.537503, 0.884467}, {0.591712, 0.796929, 0.344032}, {0.0843282, 0.918307, 0.119988}, {0.372653, 0.534355, 0.280149}, {0.71544, 0.730682, 0.838831}, {0.0643716, 0.840842, 0.234811}, {0.437949, 0.596556, 0.488785}, {0.123474, 0.921054, 0.48056}, {0.144983, 0.298273, 0.790133}, {0.0755195, 0.265311, 0.487256}, {0.820955, 0.908853, 0.221298}, {0.0554563, 0.965068, 0.704245}, {0.404596, 0.906502, 0.490494}, {0.774179, 0.258582, 0.288089}, {0.358868, 0.330471, 0.622111}, {0.110332, 0.0225949, 0.287844}, {0.809933, 0.562656, 0.876924}, {0.137753, 0.626966, 0.641492}, {0.76032, 0.903618, 0.475537}, {0.154114, 0.392679, 0.7272}, {0.0788248, 0.660072, 0.983613}, {0.643541, 0.0145764, 0.875775}, {0.242093, 0.260275, 0.651402}, {0.442803, 0.433124, 0.0150031}, {0.645707, 0.160087, 0.841587}, {0.07671, 0.730915, 0.442566}, {0.621748, 0.670736, 0.40725}, {0.619071, 0.519762, 0.176819}, {0.694269, 0.368347, 0.635381}, {0.182868, 0.0293341, 0.409547}, {0.0625916, 0.451528, 0.457834}, {0.388406, 0.967296, 0.797715}, {0.885428, 0.30326, 0.701563}, {0.409083, 0.596186, 0.274332}, {0.124445, 0.442697, 0.45329}, {0.258352, 0.523728, 0.976419}, {0.202912, 0.363215, 0.980617}, {0.789659, 0.212622, 0.612723}, {0.759711, 0.645271, 0.471541}, {0.648974, 0.747228, 0.444152}, {0.951649, 0.43483, 0.916819}, {0.0942138, 0.130525, 0.219863}, {0.663238, 0.0312157, 0.797853}, {0.342837, 0.459021, 0.584839}, {0.55922, 0.711579, 0.558065}, {0.524417, 0.327421, 0.752384}, {0.0327285, 0.904697, 0.100851}, {0.359224, 0.249223, 0.517551}, {0.950194, 0.789121, 0.0532271}, {0.99356, 0.593224, 0.61156}, {0.684628, 0.522665, 0.00709728}, {0.44603, 0.513007, 0.935685}, {0.410912, 0.792653, 0.344096}, {0.117512, 0.753647, 0.13852}, {0.132721, 0.659495, 0.394635}, {0.736248, 0.49194, 0.251733}, {0.693392, 0.962335, 0.865559}, {0.70945, 0.86121, 0.421748}, {0.680542, 0.542652, 0.369787}, {0.0312656, 0.480646, 0.760866}, {0.646873, 0.247627, 0.895697}, {0.54367, 0.00593499, 0.301158}, {0.699351, 0.301545, 0.654943}, {0.193912, 0.421942, 0.697311}, {0.751935, 0.237465, 0.825829}, {0.422338, 0.566461, 0.530516}, {0.631359, 0.0231242, 0.467609}, {0.0863867, 0.606916, 0.775582}, {0.839756, 0.2044, 0.294849}, {0.0965092, 0.411698, 0.358314}, {0.140526, 0.212392, 0.967572}, {0.642693, 0.274274, 0.0103627}, {0.0887435, 0.572453, 0.926324}, {0.775209, 0.904975, 0.0621536}, {0.0345072, 0.375661, 0.189455}, {0.733727, 0.218087, 0.428466}, {0.732654, 0.842918, 0.45356}, {0.574002, 0.935366, 0.118979}, {0.188419, 0.248744, 0.456161}, {0.481806, 0.732507, 0.465398}, {0.277487, 0.53784, 0.00997986}, {0.287168, 0.0703124, 0.0883075}, {0.797783, 0.694918, 0.168075}, {0.746118, 0.276116, 0.902486}, {0.736967, 0.167549, 0.238691}, {0.969747, 0.482076, 0.758215}, {0.0205377, 0.157385, 0.0930851}, {0.618819, 0.170885, 0.726863}, {0.838024, 0.0285217, 0.0389864}, {0.894442, 0.940634, 0.931401}, {0.3279, 0.246165, 0.468215}, {0.433882, 0.828407, 0.664319}, {0.742804, 0.0998661, 0.161048}, {0.2929, 0.542249, 0.857384}, {0.806432, 0.473839, 0.4005}};
bool btable[numpoints] = {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0};
float distlist[numpoints] = {5.41379, 5.71802, 5.39547, 4.99605, 5.17392, 4.90728, 5.19415, 5.48499, 5.45073, 4.80318, 5.43799, 5.23267, 5.18208, 5.24169, 5.52068, 5.16298, 5.00824, 5.08153, 5.48682, 5.29341, 5.79609, 4.84304, 5.19291, 4.9827, 5.23925, 4.92481, 5.20102, 5.34226, 5.69303, 5.14199, 5.32113, 5.20274, 5.46746, 5.17168, 5.6752, 5.4527, 4.81235, 5.11327, 5.41152, 5.44025, 4.94046, 5.0388, 5.25683, 5.12748, 5.12437, 4.85396, 5.79729, 5.24748, 5.25857, 5.08004, 5.14665, 5.5259, 5.42, 5.32531, 4.98901, 5.58134, 4.92183, 5.25361, 5.5373, 5.37461, 5.39206, 4.66284, 5.06298, 5.28588, 5.20787, 5.0488, 5.6775, 5.19333, 5.23508, 5.08483, 5.22037, 5.51663, 5.11401, 5.49787, 5.54069, 5.1482, 5.72822, 5.01067, 5.30421, 5.71371, 5.41018, 5.04088, 5.30572, 5.5189, 5.16596, 5.69319, 5.87656, 5.32843, 5.00384, 5.58683, 4.9453, 5.90676, 5.23167, 5.80072, 4.56535, 5.46952, 4.97367, 5.6853, 5.01424, 5.26761};

float TrianglePointDistance(Triangle tri, vec3f p)
{
  // actually implement
  vec3f a = tri.vertices[0];
  vec3f b = tri.vertices[1];
  vec3f c = tri.vertices[2];
  vec3f v0 = b - a;
  vec3f v1 = c - a;
  vec3f n = cross(v0, v1);
  vec3f v2 = p - a;
  float d = dot(v2, n) / norm(n);
  vec3f proj = p - (d * normalize(n));
  vec3f vbp = proj - a;
  float d00 = dot(v0, v0);
  float d01 = dot(v0, v1);
  float d11 = dot(v1, v1);
  float d20 = dot(vbp, v0);
  float d21 = dot(vbp, v1);
  float denom = (d00 * d11) - (d01 * d01);
  float v = ((d11 * d20) - (d01 * d21)) / denom;
  float w = ((d00 * d21) - (d01 * d20)) / denom;
  float u = 1 - v - w;
  vec3f closestPoint;
  if (1 >= u && u >= 0 && 1 >= v && v >= 0 && 1 >= w && w >= 0)
  {
    closestPoint = proj;
  }
  else
  {
    vec3f vecLastSide = c - b;
    vec3f vap = proj - a;
    vec3f vcp = proj - b;
    float t1 = std::clamp(dot(vap, v0) / dot(v0, v0), 0.0f, 1.0f);
    float t2 = std::clamp(dot(vap, v1) / dot(v1, v1), 0.0f, 1.0f);
    float t3 = std::clamp(dot(vcp, vecLastSide) / dot(vecLastSide, vecLastSide), 0.0f, 1.0f);

    vec3f ptAB = a + t1 * v0;
    vec3f ptAC = a + t2 * v1;
    vec3f ptBC = b + t3 * vecLastSide;

    float distAB = norm(ptAB - p);
    float distAC = norm(ptAC - p);
    float distBC = norm(ptBC - p);

    if (distAB <= distBC && distAB <= distAC)
    {
      closestPoint = ptAB;
    }
    else if (distBC <= distAC)
    {
      closestPoint = ptBC;
    }
    else
    {
      closestPoint = ptAC;
    }
  }
  float distance = norm(p - closestPoint);

  return distance;
}

float Determinant3x3(float mat[3][3])
{
  return (mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) - mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) + mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]));
}

float tetVol(vec3f a, vec3f b, vec3f c, vec3f d)
{
  float mat[3][3] =
      {{(b - a)[0], (b - a)[1], (b - a)[2]},
       {(c - a)[0], (c - a)[1], (c - a)[2]},
       {(d - a)[0], (d - a)[1], (d - a)[2]}};
  return std::abs(Determinant3x3(mat)) / 6.0f;
}

bool PointInsideTetrahedron(Tetrahedron tet, vec3f p)
{
  // actually implement
  vec3f a = tet.vertices[0];
  vec3f b = tet.vertices[1];
  vec3f c = tet.vertices[2];
  vec3f d = tet.vertices[3];

  float volo = tetVol(a, b, c, d);
  float vol1 = tetVol(p, b, c, d);
  float vol2 = tetVol(a, p, c, d);
  float vol3 = tetVol(a, b, p, d);
  float vol4 = tetVol(a, b, c, p);
  if (std::abs(volo - (vol1 + vol2 + vol3 + vol4)) < ((1e-5f) * volo))
  {
    return true;
  }
  else
  {
    return false;
  }
}

TEST(distance_queries, random_points)
{
  vec3f p1 = {3.0f, 7.0f, 2.0f};
  vec3f p2 = {6.0f, 8.0f, 0.0f};
  vec3f p3 = {0.0f, 1.0f, 7.0f};
  Triangle tri = {p1, p2, p3};

  for (int i = 0; i < numpoints; i++)
  {

    float dist = TrianglePointDistance(tri, points[i]);
    EXPECT_TRUE(fabs(dist - distlist[i]) <= 0.00001);
  }
}

TEST(distance_queries, inside_tet)
{
  Tetrahedron tet = {vec3f{1.0f, 0.0f, 0.0f}, vec3f{0.0f, 0.0f, 1.0f}, vec3f{0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
  for (int i = 0; i < numpoints; i++)
  {
    EXPECT_TRUE(PointInsideTetrahedron(tet, points[i]) == btable[i]);
  }
}
